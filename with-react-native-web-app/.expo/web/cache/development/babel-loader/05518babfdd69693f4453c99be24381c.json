{"ast":null,"code":"import _slicedToArray from \"/Users/jun/Desktop/dev/react-practice/with-react-native-web-app/node_modules/next/dist/compiled/@babel/runtime/helpers/esm/slicedToArray\";\nimport _objectWithoutProperties from \"/Users/jun/Desktop/dev/react-practice/with-react-native-web-app/node_modules/next/dist/compiled/@babel/runtime/helpers/esm/objectWithoutProperties\";\n\nvar _s = $RefreshSig$();\n\nvar _excluded = [\"children\"];\nimport { memo } from 'react';\nimport { usePropsResolution } from '../../../hooks/useThemeProps';\nimport { useBreakpointValue, useTheme, useToken } from '../../../hooks';\nimport { useColorMode } from '../../../core/color-mode/hooks';\nimport Platform from \"react-native-web/dist/cjs/exports/Platform\";\nexport function Hidden(_ref) {\n  _s();\n\n  var children = _ref.children,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  var _usePropsResolution = usePropsResolution('Hidden', props, {}, {\n    ignoreProps: ['only', 'platform']\n  }),\n      from = _usePropsResolution.from,\n      till = _usePropsResolution.till,\n      only = _usePropsResolution.only,\n      platform = _usePropsResolution.platform,\n      colorMode = _usePropsResolution.colorMode;\n\n  var _useTheme = useTheme(),\n      breakpoints = _useTheme.breakpoints;\n\n  var currentColorMode = useColorMode();\n  var breakpointValueObject = Object.keys(breakpoints).reduce(function (obj, val) {\n    obj[val] = val;\n    return obj;\n  }, {});\n  var breakpointValue = useBreakpointValue(breakpointValueObject);\n\n  var _useToken = useToken('breakpoints', [breakpointValue]),\n      _useToken2 = _slicedToArray(_useToken, 1),\n      currentBreakpointValue = _useToken2[0];\n\n  var _useToken3 = useToken('breakpoints', [from]),\n      _useToken4 = _slicedToArray(_useToken3, 1),\n      fromBreakPointValue = _useToken4[0];\n\n  var _useToken5 = useToken('breakpoints', [till]),\n      _useToken6 = _slicedToArray(_useToken5, 1),\n      tillBreakPointValue = _useToken6[0]; //if no prop is passed, it will hide the element wrapped with hidden\n\n\n  if (!from && !till && !only && !colorMode && !platform) {\n    return null;\n  } //if from and till prop exists, it will hide the element wrapped accordingly\n  else if (from && till && currentBreakpointValue >= fromBreakPointValue && currentBreakpointValue < tillBreakPointValue) {\n    return null;\n  } //if from prop exists, it will hide the element wrapped starting from that breakpoint.\n  else if (from && !till && currentBreakpointValue >= fromBreakPointValue) {\n    return null;\n  } //if till prop exists, it will hide the element wrapped starting from  0 till that breakpoint.\n  else if (till && !from && currentBreakpointValue < tillBreakPointValue) {\n    return null;\n  } //if only prop exists and is array, check that array consists current breakpoint value, and if that exists, hide on that breakpoint to next breakpoint.\n  // if only prop is string, hide on that breakpoint to next breakpoint.\n  else if (Array.isArray(only) && only.includes(breakpointValue) || only === breakpointValue) {\n    return null;\n  } //if platform prop exists and is array, check that array consists current platform value, and if that exists, hide on that platform.\n  // if platform prop is string, hide on that platform.\n  else if (Array.isArray(platform) && platform.includes(Platform.OS) || platform === Platform.OS) {\n    return null;\n  } //if colormode prop is valid string, hide on that colormode.\n  else if (colorMode === currentColorMode.colorMode) {\n    return null;\n  }\n\n  return children;\n}\n\n_s(Hidden, \"SsRVChUSwdETJkgsIKtKl7o5Vc8=\", false, function () {\n  return [usePropsResolution, useTheme, useColorMode, useBreakpointValue, useToken, useToken, useToken];\n});\n\n_c = Hidden;\nexport default /*#__PURE__*/_c2 = /*#__PURE__*/memo(Hidden);\n\nvar _c, _c2;\n\n$RefreshReg$(_c, \"Hidden\");\n$RefreshReg$(_c2, \"%default%\");\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = __webpack_module__.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      __webpack_module__.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      import.meta.webpackHot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          __webpack_module__.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        __webpack_module__.hot.invalidate();\n      }\n    }\n  }\n})();","map":{"version":3,"sources":["/Users/jun/Desktop/dev/react-practice/with-react-native-web-app/node_modules/native-base/lib/module/components/primitives/Hidden/index.js"],"names":["Hidden","children","props","from","till","only","platform","colorMode","usePropsResolution","ignoreProps","breakpoints","useTheme","currentColorMode","useColorMode","breakpointValueObject","obj","breakpointValue","useBreakpointValue","currentBreakpointValue","useToken","fromBreakPointValue","tillBreakPointValue","Array","Platform","memo"],"mappings":"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","sourcesContent":["import { memo } from 'react';\nimport { usePropsResolution } from '../../../hooks/useThemeProps';\nimport { useBreakpointValue, useTheme, useToken } from '../../../hooks';\nimport { useColorMode } from '../../../core/color-mode/hooks';\nimport { Platform } from 'react-native';\nexport function Hidden({\n  children,\n  ...props\n}) {\n  const {\n    from,\n    till,\n    only,\n    platform,\n    colorMode\n  } = usePropsResolution('Hidden', props, {}, {\n    ignoreProps: ['only', 'platform']\n  });\n  const {\n    breakpoints\n  } = useTheme();\n  const currentColorMode = useColorMode();\n  const breakpointValueObject = Object.keys(breakpoints).reduce((obj, val) => {\n    obj[val] = val;\n    return obj;\n  }, {});\n  const breakpointValue = useBreakpointValue(breakpointValueObject);\n  const [currentBreakpointValue] = useToken('breakpoints', [breakpointValue]);\n  const [fromBreakPointValue] = useToken('breakpoints', [from]);\n  const [tillBreakPointValue] = useToken('breakpoints', [till]); //if no prop is passed, it will hide the element wrapped with hidden\n\n  if (!from && !till && !only && !colorMode && !platform) {\n    return null;\n  } //if from and till prop exists, it will hide the element wrapped accordingly\n  else if (from && till && currentBreakpointValue >= fromBreakPointValue && currentBreakpointValue < tillBreakPointValue) {\n      return null;\n    } //if from prop exists, it will hide the element wrapped starting from that breakpoint.\n    else if (from && !till && currentBreakpointValue >= fromBreakPointValue) {\n        return null;\n      } //if till prop exists, it will hide the element wrapped starting from  0 till that breakpoint.\n      else if (till && !from && currentBreakpointValue < tillBreakPointValue) {\n          return null;\n        } //if only prop exists and is array, check that array consists current breakpoint value, and if that exists, hide on that breakpoint to next breakpoint.\n        // if only prop is string, hide on that breakpoint to next breakpoint.\n        else if (Array.isArray(only) && only.includes(breakpointValue) || only === breakpointValue) {\n            return null;\n          } //if platform prop exists and is array, check that array consists current platform value, and if that exists, hide on that platform.\n          // if platform prop is string, hide on that platform.\n          else if (Array.isArray(platform) && platform.includes(Platform.OS) || platform === Platform.OS) {\n              return null;\n            } //if colormode prop is valid string, hide on that colormode.\n            else if (colorMode === currentColorMode.colorMode) {\n                return null;\n              }\n\n  return children;\n}\nexport default /*#__PURE__*/memo(Hidden);\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}