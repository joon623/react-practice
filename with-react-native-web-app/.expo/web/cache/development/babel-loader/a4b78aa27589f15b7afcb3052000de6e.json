{"ast":null,"code":"/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n'use strict';\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _AnimatedEvent = require(\"./AnimatedEvent\");\n\nvar _AnimatedProps = _interopRequireDefault(require(\"./nodes/AnimatedProps\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _invariant = _interopRequireDefault(require(\"fbjs/lib/invariant\"));\n\nvar _mergeRefs = _interopRequireDefault(require(\"../../../modules/mergeRefs\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction createAnimatedComponent(Component, defaultProps) {\n  (0, _invariant[\"default\"])(typeof Component !== 'function' || Component.prototype && Component.prototype.isReactComponent, '`createAnimatedComponent` does not support stateless functional components; ' + 'use a class component instead.');\n\n  var AnimatedComponent = /*#__PURE__*/function (_React$Component) {\n    _inheritsLoose(AnimatedComponent, _React$Component);\n\n    function AnimatedComponent(props) {\n      var _this;\n\n      _this = _React$Component.call(this, props) || this;\n      _this._invokeAnimatedPropsCallbackOnMount = false;\n      _this._eventDetachers = [];\n\n      _this._animatedPropsCallback = function () {\n        if (_this._component == null) {\n          // AnimatedProps is created in will-mount because it's used in render.\n          // But this callback may be invoked before mount in async mode,\n          // In which case we should defer the setNativeProps() call.\n          // React may throw away uncommitted work in async mode,\n          // So a deferred call won't always be invoked.\n          _this._invokeAnimatedPropsCallbackOnMount = true;\n        } else if (AnimatedComponent.__skipSetNativeProps_FOR_TESTS_ONLY || typeof _this._component.setNativeProps !== 'function') {\n          _this.forceUpdate();\n        } else if (!_this._propsAnimated.__isNative) {\n          _this._component.setNativeProps(_this._propsAnimated.__getAnimatedValue());\n        } else {\n          throw new Error('Attempting to run JS driven animation on animated ' + 'node that has been moved to \"native\" earlier by starting an ' + 'animation with `useNativeDriver: true`');\n        }\n      };\n\n      _this._setComponentRef = (0, _mergeRefs[\"default\"])(_this.props.forwardedRef, function (ref) {\n        _this._prevComponent = _this._component;\n        _this._component = ref; // TODO: Delete this in a future release.\n\n        if (ref != null && ref.getNode == null) {\n          ref.getNode = function () {\n            var _ref$constructor$name;\n\n            console.warn('%s: Calling `getNode()` on the ref of an Animated component ' + 'is no longer necessary. You can now directly use the ref ' + 'instead. This method will be removed in a future release.', (_ref$constructor$name = ref.constructor.name) !== null && _ref$constructor$name !== void 0 ? _ref$constructor$name : '<<anonymous>>');\n            return ref;\n          };\n        }\n      });\n      return _this;\n    }\n\n    var _proto = AnimatedComponent.prototype;\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      this._propsAnimated && this._propsAnimated.__detach();\n\n      this._detachNativeEvents();\n    };\n\n    _proto.UNSAFE_componentWillMount = function UNSAFE_componentWillMount() {\n      this._attachProps(this.props);\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      if (this._invokeAnimatedPropsCallbackOnMount) {\n        this._invokeAnimatedPropsCallbackOnMount = false;\n\n        this._animatedPropsCallback();\n      }\n\n      this._propsAnimated.setNativeView(this._component);\n\n      this._attachNativeEvents();\n    };\n\n    _proto._attachNativeEvents = function _attachNativeEvents() {\n      var _this2 = this; // Make sure to get the scrollable node for components that implement\n      // `ScrollResponder.Mixin`.\n\n\n      var scrollableNode = this._component && this._component.getScrollableNode ? this._component.getScrollableNode() : this._component;\n\n      var _loop = function _loop(key) {\n        var prop = _this2.props[key];\n\n        if (prop instanceof _AnimatedEvent.AnimatedEvent && prop.__isNative) {\n          prop.__attach(scrollableNode, key);\n\n          _this2._eventDetachers.push(function () {\n            return prop.__detach(scrollableNode, key);\n          });\n        }\n      };\n\n      for (var key in this.props) {\n        _loop(key);\n      }\n    };\n\n    _proto._detachNativeEvents = function _detachNativeEvents() {\n      this._eventDetachers.forEach(function (remove) {\n        return remove();\n      });\n\n      this._eventDetachers = [];\n    } // The system is best designed when setNativeProps is implemented. It is\n    // able to avoid re-rendering and directly set the attributes that changed.\n    // However, setNativeProps can only be implemented on leaf native\n    // components. If you want to animate a composite component, you need to\n    // re-render it. In this case, we have a fallback that uses forceUpdate.\n    ;\n\n    _proto._attachProps = function _attachProps(nextProps) {\n      var oldPropsAnimated = this._propsAnimated;\n      this._propsAnimated = new _AnimatedProps[\"default\"](nextProps, this._animatedPropsCallback); // When you call detach, it removes the element from the parent list\n      // of children. If it goes to 0, then the parent also detaches itself\n      // and so on.\n      // An optimization is to attach the new elements and THEN detach the old\n      // ones instead of detaching and THEN attaching.\n      // This way the intermediate state isn't to go to 0 and trigger\n      // this expensive recursive detaching to then re-attach everything on\n      // the very next operation.\n\n      oldPropsAnimated && oldPropsAnimated.__detach();\n    };\n\n    _proto.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(newProps) {\n      this._attachProps(newProps);\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n      if (this._component !== this._prevComponent) {\n        this._propsAnimated.setNativeView(this._component);\n      }\n\n      if (this._component !== this._prevComponent || prevProps !== this.props) {\n        this._detachNativeEvents();\n\n        this._attachNativeEvents();\n      }\n    };\n\n    _proto.render = function render() {\n      var props = this._propsAnimated.__getValue();\n\n      return _react[\"default\"].createElement(Component, _extends({}, defaultProps, props, {\n        ref: this._setComponentRef // The native driver updates views directly through the UI thread so we\n        // have to make sure the view doesn't get optimized away because it cannot\n        // go through the NativeViewHierarchyManager since it operates on the shadow\n        // thread.\n        ,\n        collapsable: false\n      }));\n    };\n\n    return AnimatedComponent;\n  }(_react[\"default\"].Component);\n\n  AnimatedComponent.__skipSetNativeProps_FOR_TESTS_ONLY = false;\n  var propTypes = Component.propTypes;\n  return _react[\"default\"].forwardRef(function AnimatedComponentWrapper(props, ref) {\n    return _react[\"default\"].createElement(AnimatedComponent, _extends({}, props, ref == null ? null : {\n      forwardedRef: ref\n    }));\n  });\n}\n\nvar _default = createAnimatedComponent;\nexports[\"default\"] = _default;\nmodule.exports = exports[\"default\"];\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = __webpack_module__.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      __webpack_module__.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      import.meta.webpackHot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          __webpack_module__.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        __webpack_module__.hot.invalidate();\n      }\n    }\n  }\n})();","map":{"version":3,"sources":["/Users/jun/Desktop/dev/react-practice/with-react-native-web-app/node_modules/react-native-web/dist/cjs/vendor/react-native/Animated/createAnimatedComponent.js"],"names":["exports","_AnimatedEvent","require","_AnimatedProps","_interopRequireDefault","_react","_invariant","_mergeRefs","obj","_extends","Object","i","arguments","source","target","subClass","superClass","Component","AnimatedComponent","_inheritsLoose","_this","_React$Component","ref","console","_ref$constructor$name","_proto","_this2","scrollableNode","_loop","prop","remove","oldPropsAnimated","prevProps","props","collapsable","propTypes","forwardedRef","_default","module"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n'use strict';\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _AnimatedEvent = require(\"./AnimatedEvent\");\n\nvar _AnimatedProps = _interopRequireDefault(require(\"./nodes/AnimatedProps\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _invariant = _interopRequireDefault(require(\"fbjs/lib/invariant\"));\n\nvar _mergeRefs = _interopRequireDefault(require(\"../../../modules/mergeRefs\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }\n\nfunction createAnimatedComponent(Component, defaultProps) {\n  (0, _invariant.default)(typeof Component !== 'function' || Component.prototype && Component.prototype.isReactComponent, '`createAnimatedComponent` does not support stateless functional components; ' + 'use a class component instead.');\n\n  var AnimatedComponent =\n  /*#__PURE__*/\n  function (_React$Component) {\n    _inheritsLoose(AnimatedComponent, _React$Component);\n\n    function AnimatedComponent(props) {\n      var _this;\n\n      _this = _React$Component.call(this, props) || this;\n      _this._invokeAnimatedPropsCallbackOnMount = false;\n      _this._eventDetachers = [];\n\n      _this._animatedPropsCallback = function () {\n        if (_this._component == null) {\n          // AnimatedProps is created in will-mount because it's used in render.\n          // But this callback may be invoked before mount in async mode,\n          // In which case we should defer the setNativeProps() call.\n          // React may throw away uncommitted work in async mode,\n          // So a deferred call won't always be invoked.\n          _this._invokeAnimatedPropsCallbackOnMount = true;\n        } else if (AnimatedComponent.__skipSetNativeProps_FOR_TESTS_ONLY || typeof _this._component.setNativeProps !== 'function') {\n          _this.forceUpdate();\n        } else if (!_this._propsAnimated.__isNative) {\n          _this._component.setNativeProps(_this._propsAnimated.__getAnimatedValue());\n        } else {\n          throw new Error('Attempting to run JS driven animation on animated ' + 'node that has been moved to \"native\" earlier by starting an ' + 'animation with `useNativeDriver: true`');\n        }\n      };\n\n      _this._setComponentRef = (0, _mergeRefs.default)(_this.props.forwardedRef, function (ref) {\n        _this._prevComponent = _this._component;\n        _this._component = ref; // TODO: Delete this in a future release.\n\n        if (ref != null && ref.getNode == null) {\n          ref.getNode = function () {\n            var _ref$constructor$name;\n\n            console.warn('%s: Calling `getNode()` on the ref of an Animated component ' + 'is no longer necessary. You can now directly use the ref ' + 'instead. This method will be removed in a future release.', (_ref$constructor$name = ref.constructor.name) !== null && _ref$constructor$name !== void 0 ? _ref$constructor$name : '<<anonymous>>');\n            return ref;\n          };\n        }\n      });\n      return _this;\n    }\n\n    var _proto = AnimatedComponent.prototype;\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      this._propsAnimated && this._propsAnimated.__detach();\n\n      this._detachNativeEvents();\n    };\n\n    _proto.UNSAFE_componentWillMount = function UNSAFE_componentWillMount() {\n      this._attachProps(this.props);\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      if (this._invokeAnimatedPropsCallbackOnMount) {\n        this._invokeAnimatedPropsCallbackOnMount = false;\n\n        this._animatedPropsCallback();\n      }\n\n      this._propsAnimated.setNativeView(this._component);\n\n      this._attachNativeEvents();\n    };\n\n    _proto._attachNativeEvents = function _attachNativeEvents() {\n      var _this2 = this;\n\n      // Make sure to get the scrollable node for components that implement\n      // `ScrollResponder.Mixin`.\n      var scrollableNode = this._component && this._component.getScrollableNode ? this._component.getScrollableNode() : this._component;\n\n      var _loop = function _loop(key) {\n        var prop = _this2.props[key];\n\n        if (prop instanceof _AnimatedEvent.AnimatedEvent && prop.__isNative) {\n          prop.__attach(scrollableNode, key);\n\n          _this2._eventDetachers.push(function () {\n            return prop.__detach(scrollableNode, key);\n          });\n        }\n      };\n\n      for (var key in this.props) {\n        _loop(key);\n      }\n    };\n\n    _proto._detachNativeEvents = function _detachNativeEvents() {\n      this._eventDetachers.forEach(function (remove) {\n        return remove();\n      });\n\n      this._eventDetachers = [];\n    } // The system is best designed when setNativeProps is implemented. It is\n    // able to avoid re-rendering and directly set the attributes that changed.\n    // However, setNativeProps can only be implemented on leaf native\n    // components. If you want to animate a composite component, you need to\n    // re-render it. In this case, we have a fallback that uses forceUpdate.\n    ;\n\n    _proto._attachProps = function _attachProps(nextProps) {\n      var oldPropsAnimated = this._propsAnimated;\n      this._propsAnimated = new _AnimatedProps.default(nextProps, this._animatedPropsCallback); // When you call detach, it removes the element from the parent list\n      // of children. If it goes to 0, then the parent also detaches itself\n      // and so on.\n      // An optimization is to attach the new elements and THEN detach the old\n      // ones instead of detaching and THEN attaching.\n      // This way the intermediate state isn't to go to 0 and trigger\n      // this expensive recursive detaching to then re-attach everything on\n      // the very next operation.\n\n      oldPropsAnimated && oldPropsAnimated.__detach();\n    };\n\n    _proto.UNSAFE_componentWillReceiveProps = function UNSAFE_componentWillReceiveProps(newProps) {\n      this._attachProps(newProps);\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate(prevProps) {\n      if (this._component !== this._prevComponent) {\n        this._propsAnimated.setNativeView(this._component);\n      }\n\n      if (this._component !== this._prevComponent || prevProps !== this.props) {\n        this._detachNativeEvents();\n\n        this._attachNativeEvents();\n      }\n    };\n\n    _proto.render = function render() {\n      var props = this._propsAnimated.__getValue();\n\n      return _react.default.createElement(Component, _extends({}, defaultProps, props, {\n        ref: this._setComponentRef // The native driver updates views directly through the UI thread so we\n        // have to make sure the view doesn't get optimized away because it cannot\n        // go through the NativeViewHierarchyManager since it operates on the shadow\n        // thread.\n        ,\n        collapsable: false\n      }));\n    };\n\n    return AnimatedComponent;\n  }(_react.default.Component);\n\n  AnimatedComponent.__skipSetNativeProps_FOR_TESTS_ONLY = false;\n  var propTypes = Component.propTypes;\n  return _react.default.forwardRef(function AnimatedComponentWrapper(props, ref) {\n    return _react.default.createElement(AnimatedComponent, _extends({}, props, ref == null ? null : {\n      forwardedRef: ref\n    }));\n  });\n}\n\nvar _default = createAnimatedComponent;\nexports.default = _default;\nmodule.exports = exports.default;"]},"metadata":{},"sourceType":"module"}