{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * BezierEasing - use bezier curve for transition easing function\n * https://github.com/gre/bezier-easing\n *\n * \n * @format\n * @copyright 2014-2015 Gaëtan Renaudeau. MIT License.\n */\n'use strict'; // These values are established by empiricism with tests (tradeoff: performance VS precision)\n\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\nvar float32ArraySupported = typeof Float32Array === 'function';\n\nfunction A(aA1, aA2) {\n  return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n}\n\n_c = A;\n\nfunction B(aA1, aA2) {\n  return 3.0 * aA2 - 6.0 * aA1;\n}\n\n_c2 = B;\n\nfunction C(aA1) {\n  return 3.0 * aA1;\n} // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\n\n\n_c3 = C;\n\nfunction calcBezier(aT, aA1, aA2) {\n  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n} // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\n\n\nfunction getSlope(aT, aA1, aA2) {\n  return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n}\n\nfunction binarySubdivide(aX, _aA, _aB, mX1, mX2) {\n  var currentX,\n      currentT,\n      i = 0,\n      aA = _aA,\n      aB = _aB;\n\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n\n  return currentT;\n}\n\nfunction newtonRaphsonIterate(aX, _aGuessT, mX1, mX2) {\n  var aGuessT = _aGuessT;\n\n  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n    var currentSlope = getSlope(aGuessT, mX1, mX2);\n\n    if (currentSlope === 0.0) {\n      return aGuessT;\n    }\n\n    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n\n  return aGuessT;\n}\n\nmodule.exports = function bezier(mX1, mY1, mX2, mY2) {\n  if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) {\n    throw new Error('bezier x values must be in [0, 1] range');\n  } // Precompute samples table\n\n\n  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n\n  if (mX1 !== mY1 || mX2 !== mY2) {\n    for (var i = 0; i < kSplineTableSize; ++i) {\n      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  function getTForX(aX) {\n    var intervalStart = 0.0;\n    var currentSample = 1;\n    var lastSample = kSplineTableSize - 1;\n\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n\n    --currentSample; // Interpolate to provide an initial guess for t\n\n    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    var guessForT = intervalStart + dist * kSampleStepSize;\n    var initialSlope = getSlope(guessForT, mX1, mX2);\n\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  return function BezierEasing(x) {\n    if (mX1 === mY1 && mX2 === mY2) {\n      return x; // linear\n    } // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n\n\n    if (x === 0) {\n      return 0;\n    }\n\n    if (x === 1) {\n      return 1;\n    }\n\n    return calcBezier(getTForX(x), mY1, mY2);\n  };\n};\n\nvar _c, _c2, _c3;\n\n$RefreshReg$(_c, \"A\");\n$RefreshReg$(_c2, \"B\");\n$RefreshReg$(_c3, \"C\");\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = __webpack_module__.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      __webpack_module__.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      import.meta.webpackHot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          __webpack_module__.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        __webpack_module__.hot.invalidate();\n      }\n    }\n  }\n})();","map":{"version":3,"sources":["/Users/jun/Desktop/dev/react-practice/with-react-native-web-app/node_modules/react-native-web/dist/cjs/vendor/react-native/Animated/bezier.js"],"names":["NEWTON_ITERATIONS","NEWTON_MIN_SLOPE","SUBDIVISION_PRECISION","SUBDIVISION_MAX_ITERATIONS","kSplineTableSize","kSampleStepSize","float32ArraySupported","A","B","C","i","aA","aB","currentT","currentX","calcBezier","Math","aGuessT","currentSlope","getSlope","module","mX1","mX2","sampleValues","intervalStart","currentSample","lastSample","dist","aX","guessForT","initialSlope","newtonRaphsonIterate","binarySubdivide","x","getTForX"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * BezierEasing - use bezier curve for transition easing function\n * https://github.com/gre/bezier-easing\n *\n * \n * @format\n * @copyright 2014-2015 Gaëtan Renaudeau. MIT License.\n */\n'use strict'; // These values are established by empiricism with tests (tradeoff: performance VS precision)\n\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\nvar float32ArraySupported = typeof Float32Array === 'function';\n\nfunction A(aA1, aA2) {\n  return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n}\n\nfunction B(aA1, aA2) {\n  return 3.0 * aA2 - 6.0 * aA1;\n}\n\nfunction C(aA1) {\n  return 3.0 * aA1;\n} // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\n\n\nfunction calcBezier(aT, aA1, aA2) {\n  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n} // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\n\n\nfunction getSlope(aT, aA1, aA2) {\n  return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n}\n\nfunction binarySubdivide(aX, _aA, _aB, mX1, mX2) {\n  var currentX,\n      currentT,\n      i = 0,\n      aA = _aA,\n      aB = _aB;\n\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n\n  return currentT;\n}\n\nfunction newtonRaphsonIterate(aX, _aGuessT, mX1, mX2) {\n  var aGuessT = _aGuessT;\n\n  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n    var currentSlope = getSlope(aGuessT, mX1, mX2);\n\n    if (currentSlope === 0.0) {\n      return aGuessT;\n    }\n\n    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n\n  return aGuessT;\n}\n\nmodule.exports = function bezier(mX1, mY1, mX2, mY2) {\n  if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) {\n    throw new Error('bezier x values must be in [0, 1] range');\n  } // Precompute samples table\n\n\n  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n\n  if (mX1 !== mY1 || mX2 !== mY2) {\n    for (var i = 0; i < kSplineTableSize; ++i) {\n      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  function getTForX(aX) {\n    var intervalStart = 0.0;\n    var currentSample = 1;\n    var lastSample = kSplineTableSize - 1;\n\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n\n    --currentSample; // Interpolate to provide an initial guess for t\n\n    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    var guessForT = intervalStart + dist * kSampleStepSize;\n    var initialSlope = getSlope(guessForT, mX1, mX2);\n\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  return function BezierEasing(x) {\n    if (mX1 === mY1 && mX2 === mY2) {\n      return x; // linear\n    } // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n\n\n    if (x === 0) {\n      return 0;\n    }\n\n    if (x === 1) {\n      return 1;\n    }\n\n    return calcBezier(getTForX(x), mY1, mY2);\n  };\n};"]},"metadata":{},"sourceType":"module"}