{"ast":null,"code":"/**\n * Copyright (c) Nicolas Gallagher.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nvar slice = Array.prototype.slice;\n/**\n * Order-based insertion of CSS.\n *\n * Each rule is associated with a numerically defined group.\n * Groups are ordered within the style sheet according to their number, with the\n * lowest first.\n *\n * Groups are implemented using marker rules. The selector of the first rule of\n * each group is used only to encode the group number for hydration. An\n * alternative implementation could rely on CSSMediaRule, allowing groups to be\n * treated as a sub-sheet, but the Edge implementation of CSSMediaRule is\n * broken.\n * https://developer.mozilla.org/en-US/docs/Web/API/CSSMediaRule\n * https://gist.github.com/necolas/aa0c37846ad6bd3b05b727b959e82674\n */\n\nexport default function createOrderedCSSStyleSheet(sheet) {\n  var groups = {};\n  var selectors = {};\n  /**\n   * Hydrate approximate record from any existing rules in the sheet.\n   */\n\n  if (sheet != null) {\n    var group;\n    slice.call(sheet.cssRules).forEach(function (cssRule, i) {\n      var cssText = cssRule.cssText; // Create record of existing selectors and rules\n\n      if (cssText.indexOf('stylesheet-group') > -1) {\n        group = decodeGroupRule(cssRule);\n        groups[group] = {\n          start: i,\n          rules: [cssText]\n        };\n      } else {\n        var selectorText = getSelectorText(cssText);\n\n        if (selectorText != null) {\n          selectors[selectorText] = true;\n          groups[group].rules.push(cssText);\n        }\n      }\n    });\n  }\n\n  function sheetInsert(sheet, group, text) {\n    var orderedGroups = getOrderedGroups(groups);\n    var groupIndex = orderedGroups.indexOf(group);\n    var nextGroupIndex = groupIndex + 1;\n    var nextGroup = orderedGroups[nextGroupIndex]; // Insert rule before the next group, or at the end of the stylesheet\n\n    var position = nextGroup != null && groups[nextGroup].start != null ? groups[nextGroup].start : sheet.cssRules.length;\n    var isInserted = insertRuleAt(sheet, text, position);\n\n    if (isInserted) {\n      // Set the starting index of the new group\n      if (groups[group].start == null) {\n        groups[group].start = position;\n      } // Increment the starting index of all subsequent groups\n\n\n      for (var i = nextGroupIndex; i < orderedGroups.length; i += 1) {\n        var groupNumber = orderedGroups[i];\n        var previousStart = groups[groupNumber].start;\n        groups[groupNumber].start = previousStart + 1;\n      }\n    }\n\n    return isInserted;\n  }\n\n  var OrderedCSSStyleSheet = {\n    /**\n     * The textContent of the style sheet.\n     */\n    getTextContent: function getTextContent() {\n      return getOrderedGroups(groups).map(function (group) {\n        var rules = groups[group].rules;\n        return rules.join('\\n');\n      }).join('\\n');\n    },\n\n    /**\n     * Insert a rule into the style sheet\n     */\n    insert: function insert(cssText, groupValue) {\n      var group = Number(groupValue); // Create a new group.\n\n      if (groups[group] == null) {\n        var markerRule = encodeGroupRule(group); // Create the internal record.\n\n        groups[group] = {\n          start: null,\n          rules: [markerRule]\n        }; // Update CSSOM.\n\n        if (sheet != null) {\n          sheetInsert(sheet, group, markerRule);\n        }\n      } // selectorText is more reliable than cssText for insertion checks. The\n      // browser excludes vendor-prefixed properties and rewrites certain values\n      // making cssText more likely to be different from what was inserted.\n\n\n      var selectorText = getSelectorText(cssText);\n\n      if (selectorText != null && selectors[selectorText] == null) {\n        // Update the internal records.\n        selectors[selectorText] = true;\n        groups[group].rules.push(cssText); // Update CSSOM.\n\n        if (sheet != null) {\n          var isInserted = sheetInsert(sheet, group, cssText);\n\n          if (!isInserted) {\n            // Revert internal record change if a rule was rejected (e.g.,\n            // unrecognized pseudo-selector)\n            groups[group].rules.pop();\n          }\n        }\n      }\n    }\n  };\n  return OrderedCSSStyleSheet;\n}\n/**\n * Helper functions\n */\n\nfunction encodeGroupRule(group) {\n  return \"[stylesheet-group=\\\"\" + group + \"\\\"]{}\";\n}\n\nfunction decodeGroupRule(cssRule) {\n  return Number(cssRule.selectorText.split(/[\"']/)[1]);\n}\n\nfunction getOrderedGroups(obj) {\n  return Object.keys(obj).map(Number).sort(function (a, b) {\n    return a > b ? 1 : -1;\n  });\n}\n\nvar pattern = /\\s*([,])\\s*/g;\n\nfunction getSelectorText(cssText) {\n  var selector = cssText.split('{')[0].trim();\n  return selector !== '' ? selector.replace(pattern, '$1') : null;\n}\n\nfunction insertRuleAt(root, cssText, position) {\n  try {\n    // $FlowFixMe: Flow is missing CSSOM types needed to type 'root'.\n    root.insertRule(cssText, position);\n    return true;\n  } catch (e) {\n    // JSDOM doesn't support `CSSSMediaRule#insertRule`.\n    // Also ignore errors that occur from attempting to insert vendor-prefixed selectors.\n    return false;\n  }\n}","map":{"version":3,"sources":["/Users/jun/Desktop/dev/react-practice/with-react-native-web-app/node_modules/react-native-web/dist/exports/StyleSheet/createOrderedCSSStyleSheet.js"],"names":["slice","Array","groups","selectors","sheet","cssText","cssRule","group","decodeGroupRule","start","rules","selectorText","getSelectorText","orderedGroups","getOrderedGroups","groupIndex","nextGroupIndex","nextGroup","position","isInserted","insertRuleAt","i","groupNumber","previousStart","OrderedCSSStyleSheet","getTextContent","insert","Number","markerRule","encodeGroupRule","sheetInsert","a","pattern","selector","root"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Nicolas Gallagher.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nvar slice = Array.prototype.slice;\n/**\n * Order-based insertion of CSS.\n *\n * Each rule is associated with a numerically defined group.\n * Groups are ordered within the style sheet according to their number, with the\n * lowest first.\n *\n * Groups are implemented using marker rules. The selector of the first rule of\n * each group is used only to encode the group number for hydration. An\n * alternative implementation could rely on CSSMediaRule, allowing groups to be\n * treated as a sub-sheet, but the Edge implementation of CSSMediaRule is\n * broken.\n * https://developer.mozilla.org/en-US/docs/Web/API/CSSMediaRule\n * https://gist.github.com/necolas/aa0c37846ad6bd3b05b727b959e82674\n */\n\nexport default function createOrderedCSSStyleSheet(sheet) {\n  var groups = {};\n  var selectors = {};\n  /**\n   * Hydrate approximate record from any existing rules in the sheet.\n   */\n\n  if (sheet != null) {\n    var group;\n    slice.call(sheet.cssRules).forEach(function (cssRule, i) {\n      var cssText = cssRule.cssText; // Create record of existing selectors and rules\n\n      if (cssText.indexOf('stylesheet-group') > -1) {\n        group = decodeGroupRule(cssRule);\n        groups[group] = {\n          start: i,\n          rules: [cssText]\n        };\n      } else {\n        var selectorText = getSelectorText(cssText);\n\n        if (selectorText != null) {\n          selectors[selectorText] = true;\n          groups[group].rules.push(cssText);\n        }\n      }\n    });\n  }\n\n  function sheetInsert(sheet, group, text) {\n    var orderedGroups = getOrderedGroups(groups);\n    var groupIndex = orderedGroups.indexOf(group);\n    var nextGroupIndex = groupIndex + 1;\n    var nextGroup = orderedGroups[nextGroupIndex]; // Insert rule before the next group, or at the end of the stylesheet\n\n    var position = nextGroup != null && groups[nextGroup].start != null ? groups[nextGroup].start : sheet.cssRules.length;\n    var isInserted = insertRuleAt(sheet, text, position);\n\n    if (isInserted) {\n      // Set the starting index of the new group\n      if (groups[group].start == null) {\n        groups[group].start = position;\n      } // Increment the starting index of all subsequent groups\n\n\n      for (var i = nextGroupIndex; i < orderedGroups.length; i += 1) {\n        var groupNumber = orderedGroups[i];\n        var previousStart = groups[groupNumber].start;\n        groups[groupNumber].start = previousStart + 1;\n      }\n    }\n\n    return isInserted;\n  }\n\n  var OrderedCSSStyleSheet = {\n    /**\n     * The textContent of the style sheet.\n     */\n    getTextContent: function getTextContent() {\n      return getOrderedGroups(groups).map(function (group) {\n        var rules = groups[group].rules;\n        return rules.join('\\n');\n      }).join('\\n');\n    },\n\n    /**\n     * Insert a rule into the style sheet\n     */\n    insert: function insert(cssText, groupValue) {\n      var group = Number(groupValue); // Create a new group.\n\n      if (groups[group] == null) {\n        var markerRule = encodeGroupRule(group); // Create the internal record.\n\n        groups[group] = {\n          start: null,\n          rules: [markerRule]\n        }; // Update CSSOM.\n\n        if (sheet != null) {\n          sheetInsert(sheet, group, markerRule);\n        }\n      } // selectorText is more reliable than cssText for insertion checks. The\n      // browser excludes vendor-prefixed properties and rewrites certain values\n      // making cssText more likely to be different from what was inserted.\n\n\n      var selectorText = getSelectorText(cssText);\n\n      if (selectorText != null && selectors[selectorText] == null) {\n        // Update the internal records.\n        selectors[selectorText] = true;\n        groups[group].rules.push(cssText); // Update CSSOM.\n\n        if (sheet != null) {\n          var isInserted = sheetInsert(sheet, group, cssText);\n\n          if (!isInserted) {\n            // Revert internal record change if a rule was rejected (e.g.,\n            // unrecognized pseudo-selector)\n            groups[group].rules.pop();\n          }\n        }\n      }\n    }\n  };\n  return OrderedCSSStyleSheet;\n}\n/**\n * Helper functions\n */\n\nfunction encodeGroupRule(group) {\n  return \"[stylesheet-group=\\\"\" + group + \"\\\"]{}\";\n}\n\nfunction decodeGroupRule(cssRule) {\n  return Number(cssRule.selectorText.split(/[\"']/)[1]);\n}\n\nfunction getOrderedGroups(obj) {\n  return Object.keys(obj).map(Number).sort(function (a, b) {\n    return a > b ? 1 : -1;\n  });\n}\n\nvar pattern = /\\s*([,])\\s*/g;\n\nfunction getSelectorText(cssText) {\n  var selector = cssText.split('{')[0].trim();\n  return selector !== '' ? selector.replace(pattern, '$1') : null;\n}\n\nfunction insertRuleAt(root, cssText, position) {\n  try {\n    // $FlowFixMe: Flow is missing CSSOM types needed to type 'root'.\n    root.insertRule(cssText, position);\n    return true;\n  } catch (e) {\n    // JSDOM doesn't support `CSSSMediaRule#insertRule`.\n    // Also ignore errors that occur from attempting to insert vendor-prefixed selectors.\n    return false;\n  }\n}"]},"metadata":{},"sourceType":"module"}