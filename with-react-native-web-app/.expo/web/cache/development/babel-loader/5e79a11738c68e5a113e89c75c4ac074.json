{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.setResponderId = setResponderId;\nexports.getResponderPaths = getResponderPaths;\nexports.getLowestCommonAncestor = getLowestCommonAncestor;\nexports.hasTargetTouches = hasTargetTouches;\nexports.hasValidSelection = hasValidSelection;\nexports.isPrimaryPointerDown = isPrimaryPointerDown;\n\nvar _isSelectionValid = _interopRequireDefault(require(\"../../modules/isSelectionValid\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n/**\n * Copyright (c) Nicolas Gallagher\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nvar keyName = '__reactResponderId';\n\nfunction getEventPath(domEvent) {\n  // The 'selectionchange' event always has the 'document' as the target.\n  // Use the anchor node as the initial target to reconstruct a path.\n  // (We actually only need the first \"responder\" node in practice.)\n  if (domEvent.type === 'selectionchange') {\n    var target = window.getSelection().anchorNode;\n    return composedPathFallback(target);\n  } else {\n    var path = domEvent.composedPath != null ? domEvent.composedPath() : composedPathFallback(domEvent.target);\n    return path;\n  }\n}\n\nfunction composedPathFallback(target) {\n  var path = [];\n\n  while (target != null && target !== document.body) {\n    path.push(target);\n    target = target.parentNode;\n  }\n\n  return path;\n}\n/**\n * Retrieve the responderId from a host node\n */\n\n\nfunction getResponderId(node) {\n  if (node != null) {\n    return node[keyName];\n  }\n\n  return null;\n}\n/**\n * Store the responderId on a host node\n */\n\n\nfunction setResponderId(node, id) {\n  if (node != null) {\n    node[keyName] = id;\n  }\n}\n/**\n * Filter the event path to contain only the nodes attached to the responder system\n */\n\n\nfunction getResponderPaths(domEvent) {\n  var idPath = [];\n  var nodePath = [];\n  var eventPath = getEventPath(domEvent);\n\n  for (var i = 0; i < eventPath.length; i++) {\n    var node = eventPath[i];\n    var id = getResponderId(node);\n\n    if (id != null) {\n      idPath.push(id);\n      nodePath.push(node);\n    }\n  }\n\n  return {\n    idPath: idPath,\n    nodePath: nodePath\n  };\n}\n/**\n * Walk the paths and find the first common ancestor\n */\n\n\nfunction getLowestCommonAncestor(pathA, pathB) {\n  var pathALength = pathA.length;\n  var pathBLength = pathB.length;\n\n  if ( // If either path is empty\n  pathALength === 0 || pathBLength === 0 || // If the last elements aren't the same there can't be a common ancestor\n  // that is connected to the responder system\n  pathA[pathALength - 1] !== pathB[pathBLength - 1]) {\n    return null;\n  }\n\n  var itemA = pathA[0];\n  var indexA = 0;\n  var itemB = pathB[0];\n  var indexB = 0; // If A is deeper, skip indices that can't match.\n\n  if (pathALength - pathBLength > 0) {\n    indexA = pathALength - pathBLength;\n    itemA = pathA[indexA];\n    pathALength = pathBLength;\n  } // If B is deeper, skip indices that can't match\n\n\n  if (pathBLength - pathALength > 0) {\n    indexB = pathBLength - pathALength;\n    itemB = pathB[indexB];\n    pathBLength = pathALength;\n  } // Walk in lockstep until a match is found\n\n\n  var depth = pathALength;\n\n  while (depth--) {\n    if (itemA === itemB) {\n      return itemA;\n    }\n\n    itemA = pathA[indexA++];\n    itemB = pathB[indexB++];\n  }\n\n  return null;\n}\n/**\n * Determine whether any of the active touches are within the current responder.\n * This cannot rely on W3C `targetTouches`, as neither IE11 nor Safari implement it.\n */\n\n\nfunction hasTargetTouches(target, touches) {\n  if (!touches || touches.length === 0) {\n    return false;\n  }\n\n  for (var i = 0; i < touches.length; i++) {\n    var node = touches[i].target;\n\n    if (node != null) {\n      if (target.contains(node)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n/**\n * Ignore 'selectionchange' events that don't correspond with a person's intent to\n * select text.\n */\n\n\nfunction hasValidSelection(domEvent) {\n  if (domEvent.type === 'selectionchange') {\n    return (0, _isSelectionValid[\"default\"])();\n  }\n\n  return domEvent.type === 'select';\n}\n/**\n * Events are only valid if the primary button was used without specific modifier keys.\n */\n\n\nfunction isPrimaryPointerDown(domEvent) {\n  var altKey = domEvent.altKey,\n      button = domEvent.button,\n      buttons = domEvent.buttons,\n      ctrlKey = domEvent.ctrlKey,\n      type = domEvent.type;\n  var isTouch = type === 'touchstart' || type === 'touchmove';\n  var isPrimaryMouseDown = type === 'mousedown' && (button === 0 || buttons === 1);\n  var isPrimaryMouseMove = type === 'mousemove' && buttons === 1;\n  var noModifiers = altKey === false && ctrlKey === false;\n\n  if (isTouch || isPrimaryMouseDown && noModifiers || isPrimaryMouseMove && noModifiers) {\n    return true;\n  }\n\n  return false;\n}","map":{"version":3,"sources":["/Users/jun/Desktop/dev/react-practice/with-react-native-web-app/node_modules/react-native-web/dist/cjs/hooks/useResponderEvents/utils.js"],"names":["exports","_isSelectionValid","_interopRequireDefault","require","obj","default","keyName","domEvent","target","window","composedPathFallback","path","document","node","idPath","nodePath","eventPath","getEventPath","i","id","getResponderId","pathALength","pathA","pathBLength","pathB","itemA","indexA","itemB","indexB","depth","touches","altKey","button","buttons","ctrlKey","type","isTouch","isPrimaryMouseDown","isPrimaryMouseMove","noModifiers"],"mappings":"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","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.setResponderId = setResponderId;\nexports.getResponderPaths = getResponderPaths;\nexports.getLowestCommonAncestor = getLowestCommonAncestor;\nexports.hasTargetTouches = hasTargetTouches;\nexports.hasValidSelection = hasValidSelection;\nexports.isPrimaryPointerDown = isPrimaryPointerDown;\n\nvar _isSelectionValid = _interopRequireDefault(require(\"../../modules/isSelectionValid\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) Nicolas Gallagher\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nvar keyName = '__reactResponderId';\n\nfunction getEventPath(domEvent) {\n  // The 'selectionchange' event always has the 'document' as the target.\n  // Use the anchor node as the initial target to reconstruct a path.\n  // (We actually only need the first \"responder\" node in practice.)\n  if (domEvent.type === 'selectionchange') {\n    var target = window.getSelection().anchorNode;\n    return composedPathFallback(target);\n  } else {\n    var path = domEvent.composedPath != null ? domEvent.composedPath() : composedPathFallback(domEvent.target);\n    return path;\n  }\n}\n\nfunction composedPathFallback(target) {\n  var path = [];\n\n  while (target != null && target !== document.body) {\n    path.push(target);\n    target = target.parentNode;\n  }\n\n  return path;\n}\n/**\n * Retrieve the responderId from a host node\n */\n\n\nfunction getResponderId(node) {\n  if (node != null) {\n    return node[keyName];\n  }\n\n  return null;\n}\n/**\n * Store the responderId on a host node\n */\n\n\nfunction setResponderId(node, id) {\n  if (node != null) {\n    node[keyName] = id;\n  }\n}\n/**\n * Filter the event path to contain only the nodes attached to the responder system\n */\n\n\nfunction getResponderPaths(domEvent) {\n  var idPath = [];\n  var nodePath = [];\n  var eventPath = getEventPath(domEvent);\n\n  for (var i = 0; i < eventPath.length; i++) {\n    var node = eventPath[i];\n    var id = getResponderId(node);\n\n    if (id != null) {\n      idPath.push(id);\n      nodePath.push(node);\n    }\n  }\n\n  return {\n    idPath: idPath,\n    nodePath: nodePath\n  };\n}\n/**\n * Walk the paths and find the first common ancestor\n */\n\n\nfunction getLowestCommonAncestor(pathA, pathB) {\n  var pathALength = pathA.length;\n  var pathBLength = pathB.length;\n\n  if ( // If either path is empty\n  pathALength === 0 || pathBLength === 0 || // If the last elements aren't the same there can't be a common ancestor\n  // that is connected to the responder system\n  pathA[pathALength - 1] !== pathB[pathBLength - 1]) {\n    return null;\n  }\n\n  var itemA = pathA[0];\n  var indexA = 0;\n  var itemB = pathB[0];\n  var indexB = 0; // If A is deeper, skip indices that can't match.\n\n  if (pathALength - pathBLength > 0) {\n    indexA = pathALength - pathBLength;\n    itemA = pathA[indexA];\n    pathALength = pathBLength;\n  } // If B is deeper, skip indices that can't match\n\n\n  if (pathBLength - pathALength > 0) {\n    indexB = pathBLength - pathALength;\n    itemB = pathB[indexB];\n    pathBLength = pathALength;\n  } // Walk in lockstep until a match is found\n\n\n  var depth = pathALength;\n\n  while (depth--) {\n    if (itemA === itemB) {\n      return itemA;\n    }\n\n    itemA = pathA[indexA++];\n    itemB = pathB[indexB++];\n  }\n\n  return null;\n}\n/**\n * Determine whether any of the active touches are within the current responder.\n * This cannot rely on W3C `targetTouches`, as neither IE11 nor Safari implement it.\n */\n\n\nfunction hasTargetTouches(target, touches) {\n  if (!touches || touches.length === 0) {\n    return false;\n  }\n\n  for (var i = 0; i < touches.length; i++) {\n    var node = touches[i].target;\n\n    if (node != null) {\n      if (target.contains(node)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n/**\n * Ignore 'selectionchange' events that don't correspond with a person's intent to\n * select text.\n */\n\n\nfunction hasValidSelection(domEvent) {\n  if (domEvent.type === 'selectionchange') {\n    return (0, _isSelectionValid.default)();\n  }\n\n  return domEvent.type === 'select';\n}\n/**\n * Events are only valid if the primary button was used without specific modifier keys.\n */\n\n\nfunction isPrimaryPointerDown(domEvent) {\n  var altKey = domEvent.altKey,\n      button = domEvent.button,\n      buttons = domEvent.buttons,\n      ctrlKey = domEvent.ctrlKey,\n      type = domEvent.type;\n  var isTouch = type === 'touchstart' || type === 'touchmove';\n  var isPrimaryMouseDown = type === 'mousedown' && (button === 0 || buttons === 1);\n  var isPrimaryMouseMove = type === 'mousemove' && buttons === 1;\n  var noModifiers = altKey === false && ctrlKey === false;\n\n  if (isTouch || isPrimaryMouseDown && noModifiers || isPrimaryMouseMove && noModifiers) {\n    return true;\n  }\n\n  return false;\n}"]},"metadata":{},"sourceType":"script"}