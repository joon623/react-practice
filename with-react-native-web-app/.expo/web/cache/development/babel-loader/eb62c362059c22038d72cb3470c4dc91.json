{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n'use strict';\n\nexports.__esModule = true;\nexports.computeWindowedRenderLimits = computeWindowedRenderLimits;\nexports.elementsThatOverlapOffsets = elementsThatOverlapOffsets;\nexports.newRangeCount = newRangeCount;\nexports[\"default\"] = void 0;\n\nvar _invariant = _interopRequireDefault(require(\"fbjs/lib/invariant\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n/**\n * Used to find the indices of the frames that overlap the given offsets. Useful for finding the\n * items that bound different windows of content, such as the visible area or the buffered overscan\n * area.\n */\n\n\nfunction elementsThatOverlapOffsets(offsets, itemCount, getFrameMetrics) {\n  var out = [];\n  var outLength = 0;\n\n  for (var ii = 0; ii < itemCount; ii++) {\n    var frame = getFrameMetrics(ii);\n    var trailingOffset = frame.offset + frame.length;\n\n    for (var kk = 0; kk < offsets.length; kk++) {\n      if (out[kk] == null && trailingOffset >= offsets[kk]) {\n        out[kk] = ii;\n        outLength++;\n\n        if (kk === offsets.length - 1) {\n          (0, _invariant[\"default\"])(outLength === offsets.length, 'bad offsets input, should be in increasing order: %s', JSON.stringify(offsets));\n          return out;\n        }\n      }\n    }\n  }\n\n  return out;\n}\n/**\n * Computes the number of elements in the `next` range that are new compared to the `prev` range.\n * Handy for calculating how many new items will be rendered when the render window changes so we\n * can restrict the number of new items render at once so that content can appear on the screen\n * faster.\n */\n\n\nfunction newRangeCount(prev, next) {\n  return next.last - next.first + 1 - Math.max(0, 1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first));\n}\n/**\n * Custom logic for determining which items should be rendered given the current frame and scroll\n * metrics, as well as the previous render state. The algorithm may evolve over time, but generally\n * prioritizes the visible area first, then expands that with overscan regions ahead and behind,\n * biased in the direction of scroll.\n */\n\n\nfunction computeWindowedRenderLimits(props, prev, getFrameMetricsApprox, scrollMetrics) {\n  var data = props.data,\n      getItemCount = props.getItemCount,\n      maxToRenderPerBatch = props.maxToRenderPerBatch,\n      windowSize = props.windowSize;\n  var itemCount = getItemCount(data);\n\n  if (itemCount === 0) {\n    return prev;\n  }\n\n  var offset = scrollMetrics.offset,\n      velocity = scrollMetrics.velocity,\n      visibleLength = scrollMetrics.visibleLength; // Start with visible area, then compute maximum overscan region by expanding from there, biased\n  // in the direction of scroll. Total overscan area is capped, which should cap memory consumption\n  // too.\n\n  var visibleBegin = Math.max(0, offset);\n  var visibleEnd = visibleBegin + visibleLength;\n  var overscanLength = (windowSize - 1) * visibleLength; // Considering velocity seems to introduce more churn than it's worth.\n\n  var leadFactor = 0.5; // Math.max(0, Math.min(1, velocity / 25 + 0.5));\n\n  var fillPreference = velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';\n  var overscanBegin = Math.max(0, visibleBegin - (1 - leadFactor) * overscanLength);\n  var overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);\n  var lastItemOffset = getFrameMetricsApprox(itemCount - 1).offset;\n\n  if (lastItemOffset < overscanBegin) {\n    // Entire list is before our overscan window\n    return {\n      first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),\n      last: itemCount - 1\n    };\n  } // Find the indices that correspond to the items at the render boundaries we're targeting.\n\n\n  var _elementsThatOverlapO = elementsThatOverlapOffsets([overscanBegin, visibleBegin, visibleEnd, overscanEnd], props.getItemCount(props.data), getFrameMetricsApprox),\n      overscanFirst = _elementsThatOverlapO[0],\n      first = _elementsThatOverlapO[1],\n      last = _elementsThatOverlapO[2],\n      overscanLast = _elementsThatOverlapO[3];\n\n  overscanFirst = overscanFirst == null ? 0 : overscanFirst;\n  first = first == null ? Math.max(0, overscanFirst) : first;\n  overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;\n  last = last == null ? Math.min(overscanLast, first + maxToRenderPerBatch - 1) : last;\n  var visible = {\n    first: first,\n    last: last\n  }; // We want to limit the number of new cells we're rendering per batch so that we can fill the\n  // content on the screen quickly. If we rendered the entire overscan window at once, the user\n  // could be staring at white space for a long time waiting for a bunch of offscreen content to\n  // render.\n\n  var newCellCount = newRangeCount(prev, visible);\n\n  while (true) {\n    if (first <= overscanFirst && last >= overscanLast) {\n      // If we fill the entire overscan range, we're done.\n      break;\n    }\n\n    var maxNewCells = newCellCount >= maxToRenderPerBatch;\n    var firstWillAddMore = first <= prev.first || first > prev.last;\n    var firstShouldIncrement = first > overscanFirst && (!maxNewCells || !firstWillAddMore);\n    var lastWillAddMore = last >= prev.last || last < prev.first;\n    var lastShouldIncrement = last < overscanLast && (!maxNewCells || !lastWillAddMore);\n\n    if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {\n      // We only want to stop if we've hit maxNewCells AND we cannot increment first or last\n      // without rendering new items. This let's us preserve as many already rendered items as\n      // possible, reducing render churn and keeping the rendered overscan range as large as\n      // possible.\n      break;\n    }\n\n    if (firstShouldIncrement && !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)) {\n      if (firstWillAddMore) {\n        newCellCount++;\n      }\n\n      first--;\n    }\n\n    if (lastShouldIncrement && !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)) {\n      if (lastWillAddMore) {\n        newCellCount++;\n      }\n\n      last++;\n    }\n  }\n\n  if (!(last >= first && first >= 0 && last < itemCount && first >= overscanFirst && last <= overscanLast && first <= visible.first && last >= visible.last)) {\n    throw new Error('Bad window calculation ' + JSON.stringify({\n      first: first,\n      last: last,\n      itemCount: itemCount,\n      overscanFirst: overscanFirst,\n      overscanLast: overscanLast,\n      visible: visible\n    }));\n  }\n\n  return {\n    first: first,\n    last: last\n  };\n}\n\nvar VirtualizeUtils = {\n  computeWindowedRenderLimits: computeWindowedRenderLimits,\n  elementsThatOverlapOffsets: elementsThatOverlapOffsets,\n  newRangeCount: newRangeCount\n};\nvar _default = VirtualizeUtils;\nexports[\"default\"] = _default;\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = __webpack_module__.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      __webpack_module__.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      import.meta.webpackHot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          __webpack_module__.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        __webpack_module__.hot.invalidate();\n      }\n    }\n  }\n})();","map":{"version":3,"sources":["/Users/jun/Desktop/dev/react-practice/with-react-native-web-app/node_modules/react-native-web/dist/cjs/vendor/react-native/VirtualizeUtils/index.js"],"names":["exports","_invariant","_interopRequireDefault","require","obj","out","outLength","ii","frame","getFrameMetrics","trailingOffset","kk","offsets","JSON","next","Math","prev","data","props","getItemCount","maxToRenderPerBatch","windowSize","itemCount","offset","scrollMetrics","velocity","visibleLength","visibleBegin","visibleEnd","overscanLength","leadFactor","fillPreference","overscanBegin","overscanEnd","lastItemOffset","getFrameMetricsApprox","first","last","_elementsThatOverlapO","elementsThatOverlapOffsets","overscanFirst","overscanLast","visible","newCellCount","newRangeCount","maxNewCells","firstWillAddMore","firstShouldIncrement","lastWillAddMore","lastShouldIncrement","VirtualizeUtils","computeWindowedRenderLimits","_default"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n'use strict';\n\nexports.__esModule = true;\nexports.computeWindowedRenderLimits = computeWindowedRenderLimits;\nexports.elementsThatOverlapOffsets = elementsThatOverlapOffsets;\nexports.newRangeCount = newRangeCount;\nexports.default = void 0;\n\nvar _invariant = _interopRequireDefault(require(\"fbjs/lib/invariant\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Used to find the indices of the frames that overlap the given offsets. Useful for finding the\n * items that bound different windows of content, such as the visible area or the buffered overscan\n * area.\n */\nfunction elementsThatOverlapOffsets(offsets, itemCount, getFrameMetrics) {\n  var out = [];\n  var outLength = 0;\n\n  for (var ii = 0; ii < itemCount; ii++) {\n    var frame = getFrameMetrics(ii);\n    var trailingOffset = frame.offset + frame.length;\n\n    for (var kk = 0; kk < offsets.length; kk++) {\n      if (out[kk] == null && trailingOffset >= offsets[kk]) {\n        out[kk] = ii;\n        outLength++;\n\n        if (kk === offsets.length - 1) {\n          (0, _invariant.default)(outLength === offsets.length, 'bad offsets input, should be in increasing order: %s', JSON.stringify(offsets));\n          return out;\n        }\n      }\n    }\n  }\n\n  return out;\n}\n/**\n * Computes the number of elements in the `next` range that are new compared to the `prev` range.\n * Handy for calculating how many new items will be rendered when the render window changes so we\n * can restrict the number of new items render at once so that content can appear on the screen\n * faster.\n */\n\n\nfunction newRangeCount(prev, next) {\n  return next.last - next.first + 1 - Math.max(0, 1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first));\n}\n/**\n * Custom logic for determining which items should be rendered given the current frame and scroll\n * metrics, as well as the previous render state. The algorithm may evolve over time, but generally\n * prioritizes the visible area first, then expands that with overscan regions ahead and behind,\n * biased in the direction of scroll.\n */\n\n\nfunction computeWindowedRenderLimits(props, prev, getFrameMetricsApprox, scrollMetrics) {\n  var data = props.data,\n      getItemCount = props.getItemCount,\n      maxToRenderPerBatch = props.maxToRenderPerBatch,\n      windowSize = props.windowSize;\n  var itemCount = getItemCount(data);\n\n  if (itemCount === 0) {\n    return prev;\n  }\n\n  var offset = scrollMetrics.offset,\n      velocity = scrollMetrics.velocity,\n      visibleLength = scrollMetrics.visibleLength; // Start with visible area, then compute maximum overscan region by expanding from there, biased\n  // in the direction of scroll. Total overscan area is capped, which should cap memory consumption\n  // too.\n\n  var visibleBegin = Math.max(0, offset);\n  var visibleEnd = visibleBegin + visibleLength;\n  var overscanLength = (windowSize - 1) * visibleLength; // Considering velocity seems to introduce more churn than it's worth.\n\n  var leadFactor = 0.5; // Math.max(0, Math.min(1, velocity / 25 + 0.5));\n\n  var fillPreference = velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';\n  var overscanBegin = Math.max(0, visibleBegin - (1 - leadFactor) * overscanLength);\n  var overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);\n  var lastItemOffset = getFrameMetricsApprox(itemCount - 1).offset;\n\n  if (lastItemOffset < overscanBegin) {\n    // Entire list is before our overscan window\n    return {\n      first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),\n      last: itemCount - 1\n    };\n  } // Find the indices that correspond to the items at the render boundaries we're targeting.\n\n\n  var _elementsThatOverlapO = elementsThatOverlapOffsets([overscanBegin, visibleBegin, visibleEnd, overscanEnd], props.getItemCount(props.data), getFrameMetricsApprox),\n      overscanFirst = _elementsThatOverlapO[0],\n      first = _elementsThatOverlapO[1],\n      last = _elementsThatOverlapO[2],\n      overscanLast = _elementsThatOverlapO[3];\n\n  overscanFirst = overscanFirst == null ? 0 : overscanFirst;\n  first = first == null ? Math.max(0, overscanFirst) : first;\n  overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;\n  last = last == null ? Math.min(overscanLast, first + maxToRenderPerBatch - 1) : last;\n  var visible = {\n    first: first,\n    last: last\n  }; // We want to limit the number of new cells we're rendering per batch so that we can fill the\n  // content on the screen quickly. If we rendered the entire overscan window at once, the user\n  // could be staring at white space for a long time waiting for a bunch of offscreen content to\n  // render.\n\n  var newCellCount = newRangeCount(prev, visible);\n\n  while (true) {\n    if (first <= overscanFirst && last >= overscanLast) {\n      // If we fill the entire overscan range, we're done.\n      break;\n    }\n\n    var maxNewCells = newCellCount >= maxToRenderPerBatch;\n    var firstWillAddMore = first <= prev.first || first > prev.last;\n    var firstShouldIncrement = first > overscanFirst && (!maxNewCells || !firstWillAddMore);\n    var lastWillAddMore = last >= prev.last || last < prev.first;\n    var lastShouldIncrement = last < overscanLast && (!maxNewCells || !lastWillAddMore);\n\n    if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {\n      // We only want to stop if we've hit maxNewCells AND we cannot increment first or last\n      // without rendering new items. This let's us preserve as many already rendered items as\n      // possible, reducing render churn and keeping the rendered overscan range as large as\n      // possible.\n      break;\n    }\n\n    if (firstShouldIncrement && !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)) {\n      if (firstWillAddMore) {\n        newCellCount++;\n      }\n\n      first--;\n    }\n\n    if (lastShouldIncrement && !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)) {\n      if (lastWillAddMore) {\n        newCellCount++;\n      }\n\n      last++;\n    }\n  }\n\n  if (!(last >= first && first >= 0 && last < itemCount && first >= overscanFirst && last <= overscanLast && first <= visible.first && last >= visible.last)) {\n    throw new Error('Bad window calculation ' + JSON.stringify({\n      first: first,\n      last: last,\n      itemCount: itemCount,\n      overscanFirst: overscanFirst,\n      overscanLast: overscanLast,\n      visible: visible\n    }));\n  }\n\n  return {\n    first: first,\n    last: last\n  };\n}\n\nvar VirtualizeUtils = {\n  computeWindowedRenderLimits: computeWindowedRenderLimits,\n  elementsThatOverlapOffsets: elementsThatOverlapOffsets,\n  newRangeCount: newRangeCount\n};\nvar _default = VirtualizeUtils;\nexports.default = _default;"]},"metadata":{},"sourceType":"module"}