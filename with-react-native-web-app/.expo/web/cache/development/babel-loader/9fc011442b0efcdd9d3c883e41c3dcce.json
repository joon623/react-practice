{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"/Users/jun/Desktop/dev/react-practice/with-react-native-web-app/node_modules/next/dist/compiled/@babel/runtime/helpers/slicedToArray\");\n\nvar _objectDestructuringEmpty = require(\"/Users/jun/Desktop/dev/react-practice/with-react-native-web-app/node_modules/next/dist/compiled/@babel/runtime/helpers/objectDestructuringEmpty\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extractProps = extractProps;\nexports.mergeUnderscoreProps = mergeUnderscoreProps;\nexports.calculateProps = calculateProps;\nexports.resolveValueWithBreakpoint = exports.extractPropertyFromFunction = void 0;\n\nvar _lodash = _interopRequireDefault(require(\"lodash.get\"));\n\nvar _lodash2 = _interopRequireDefault(require(\"lodash.isnil\"));\n\nvar _lodash3 = _interopRequireDefault(require(\"lodash.mergewith\"));\n\nvar _lodash4 = _interopRequireDefault(require(\"lodash.clonedeep\"));\n\nvar _base = require(\"./../../theme/base\");\n\nvar _tools = require(\"./../../theme/tools\");\n\nvar _useContrastText = require(\"../useContrastText\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n/*\n Extract props from theme props and omit those from props\n*/\n\n/**\n *\n * @param props Props passed by the user\n * @param theme Theme object\n * @param colorModeProps `colorMode` object\n * @param componentTheme Theme for specific components\n * @param currentBreakpoint Current breakpoint values\n * @returns Extracting props from defaultProps while overriding the props that are already present\n */\n\n\nfunction extractProps(props, theme, _ref, componentTheme, currentBreakpoint) {\n  _objectDestructuringEmpty(_ref);\n\n  var newProps = {};\n\n  for (var property in props) {\n    // If the property exists in themePropertyMap then get its value\n    if (_base.themePropertyMap[property]) {\n      var propValues = extractPropertyFromFunction(property, props, theme, componentTheme);\n\n      if (typeof propValues === 'string' || typeof propValues === 'number') {\n        newProps[property] = propValues;\n      } else if (!(0, _lodash2[\"default\"])(propValues)) {\n        for (var nestedProp in propValues) {\n          newProps[nestedProp] = (0, _lodash[\"default\"])(theme, \"\".concat(_base.themePropertyMap[nestedProp], \".\").concat(propValues[nestedProp]), propValues[nestedProp]);\n        }\n      } else if (property === 'shadow') {\n        var shadowProps = theme[_base.themePropertyMap[property]][props[property]];\n\n        if (!(0, _lodash2[\"default\"])(shadowProps)) {\n          newProps = _objectSpread(_objectSpread({}, newProps), shadowProps);\n        }\n      } else {\n        newProps[property] = resolveValueWithBreakpoint(props[property], theme.breakpoints, currentBreakpoint, property);\n      }\n    } else {\n      newProps[property] = resolveValueWithBreakpoint(props[property], theme.breakpoints, currentBreakpoint, property);\n    }\n  }\n\n  return (0, _lodash4[\"default\"])(newProps);\n}\n/*\nRemove props from defaultProps that are already present in props\n*/\n\n\nfunction filterDefaultProps(props, defaultProps) {\n  var _ref2 = (0, _tools.extractInObject)(defaultProps, Object.keys(props)),\n      _ref3 = _slicedToArray(_ref2, 2),\n      resultProps = _ref3[1];\n\n  return resultProps;\n}\n/**\n * If property is functional in componentTheme, get its returned object\n *\n * @param property : name of the prop\n * @param props : all props\n * @param theme : provided theme without components\n * @param componentTheme : component specific theme\n * @returns\n */\n\n\nvar extractPropertyFromFunction = function extractPropertyFromFunction(property, props, theme, componentTheme) {\n  var propValues; // Check if the entry in the theme is a function then calling it with all theme and props as params\n\n  if (componentTheme && typeof componentTheme[_base.themePropertyMap[property]] === 'function') {\n    var funcProps = componentTheme[_base.themePropertyMap[property]](_objectSpread({\n      theme: theme\n    }, props)); // Check if returned object from componentTheme is a nested object\n\n\n    var isNested = Object.keys(funcProps).some(function (key) {\n      return funcProps[key] && typeof funcProps[key] === 'object';\n    }); // If the returned value is nested object then find the property value in it, otherwise return the whole object\n\n    propValues = isNested ? _objectSpread({}, (0, _lodash[\"default\"])(funcProps, \"\".concat(props[property]))) : _objectSpread({}, funcProps);\n  } else {\n    // If the entry is any value other than function then return the whole object or value\n    propValues = (0, _lodash[\"default\"])(componentTheme, \"\".concat(_base.themePropertyMap[property], \".\").concat(props[property]));\n  }\n\n  return propValues;\n};\n/*\nMerge _props and apply contrastText color if not passed by theme or user\n*/\n\n\nexports.extractPropertyFromFunction = extractPropertyFromFunction;\n\nfunction mergeUnderscoreProps(newProps, props) {\n  var _props = Object.keys(newProps).filter(function (propName) {\n    return propName.startsWith('_');\n  });\n\n  _props.forEach(function (propName) {\n    var _newProps$bg, _newProps$propName$co, _newProps$propName, _props$propName; // Adding color based on bg contrast if no color is given\n\n\n    var bg = (_newProps$bg = newProps.bg) !== null && _newProps$bg !== void 0 ? _newProps$bg : newProps.backgroundColor;\n    var textColor = bg ? {\n      color: (0, _useContrastText.useContrastText)(bg, (_newProps$propName$co = (_newProps$propName = newProps[propName]) === null || _newProps$propName === void 0 ? void 0 : _newProps$propName.color) !== null && _newProps$propName$co !== void 0 ? _newProps$propName$co : (_props$propName = props[propName]) === null || _props$propName === void 0 ? void 0 : _props$propName.color)\n    } : {}; // Overriding calculated props with user added props\n\n    newProps[propName] = _objectSpread(_objectSpread(_objectSpread({}, textColor), newProps[propName]), props[propName]);\n  });\n\n  return newProps;\n}\n/**\n *\n * Checks the property and resolves it if it has breakpoints\n * @param values : value from props\n * @param currentBreakpoint : current value for which breakpoint will be calculated\n * @param property : property name\n * @returns\n */\n\n\nvar resolveValueWithBreakpoint = function resolveValueWithBreakpoint(values, breakpointTheme, currentBreakpoint, property) {\n  if ((0, _tools.hasValidBreakpointFormat)(values, breakpointTheme, property)) {\n    // Check the last valid breakpoint value from all values\n    // If current breakpoint is `md` and we have `base` then `lg`, then last value will be taken(`base` in this case)\n    return (0, _tools.findLastValidBreakpoint)(values, breakpointTheme, currentBreakpoint);\n  } else {\n    return values;\n  }\n};\n/**\n * Takes all prop related data and returns the props that needs to be applied to the component\n *\n * @param theme Theme object\n * @param colorModeProps Color mode information\n * @param componentTheme Theme object for the specific component\n * @param props Props passed by the user\n * @param windowWidth Width of the current window\n * @returns props to be applied\n */\n\n\nexports.resolveValueWithBreakpoint = resolveValueWithBreakpoint;\n\nfunction calculateProps(theme, colorModeProps, componentTheme, props, windowWidth) {\n  var currentBreakpoint = (0, _tools.getClosestBreakpoint)(theme.breakpoints, windowWidth);\n\n  if (!props) {\n    props = {};\n  }\n\n  var newProps;\n\n  if (componentTheme) {\n    // Extracting props from defaultProps\n    newProps = extractProps(filterDefaultProps(props, componentTheme.defaultProps), theme, colorModeProps, componentTheme, currentBreakpoint); // Extracting props from base style\n\n    var componentBaseStyle = typeof componentTheme.baseStyle !== 'function' ? componentTheme.baseStyle : componentTheme.baseStyle(_objectSpread(_objectSpread(_objectSpread({\n      theme: theme\n    }, newProps), props), colorModeProps));\n    newProps = (0, _lodash3[\"default\"])(newProps, componentBaseStyle, // @ts-ignore\n    function (objValue, srcValue, key) {\n      if (!(0, _lodash2[\"default\"])(objValue)) {\n        delete newProps[key];\n      }\n    });\n    var variant = props.variant || (0, _lodash[\"default\"])(componentTheme, 'defaultProps.variant'); // Extracting props from variant\n\n    if (variant && componentTheme.variants && componentTheme.variants[variant]) {\n      var colorScheme = props.colorScheme || (0, _lodash[\"default\"])(componentTheme, 'defaultProps.colorScheme');\n      var variantProps = componentTheme.variants[variant](_objectSpread(_objectSpread(_objectSpread({}, props), newProps), {}, {\n        colorScheme: colorScheme,\n        theme: theme\n      }, colorModeProps));\n      variantProps = extractProps(variantProps, theme, colorModeProps, componentTheme, currentBreakpoint); // added this to handle order of props\n\n      newProps = (0, _lodash3[\"default\"])(newProps, variantProps, // @ts-ignore\n      function (objValue, srcValue, key) {\n        if (!(0, _lodash2[\"default\"])(objValue)) {\n          delete newProps[key];\n        }\n      });\n      delete newProps.variant;\n      delete newProps.colorScheme;\n    }\n  } // Extracting props from normal props\n\n\n  var extractedProps = extractProps(props, theme, colorModeProps, componentTheme, currentBreakpoint); // added this to handle order of props\n  // @ts-ignore\n\n  newProps = (0, _lodash3[\"default\"])(newProps, extractedProps, function (objValue, srcValue, key) {\n    if (!(0, _lodash2[\"default\"])(objValue)) {\n      delete newProps[key];\n    }\n  });\n  newProps = mergeUnderscoreProps(newProps, props);\n  return newProps;\n}","map":{"version":3,"sources":["/Users/jun/Desktop/dev/react-practice/with-react-native-web-app/node_modules/native-base/lib/commonjs/hooks/useThemeProps/utils.js"],"names":["Object","value","exports","_lodash","_interopRequireDefault","require","_lodash2","_lodash3","_lodash4","_base","_tools","_useContrastText","obj","default","newProps","propValues","extractPropertyFromFunction","property","shadowProps","theme","props","resolveValueWithBreakpoint","componentTheme","funcProps","isNested","_props","propName","bg","_newProps$bg","textColor","color","_newProps$propName$co","_newProps$propName","_props$propName","currentBreakpoint","extractProps","filterDefaultProps","componentBaseStyle","variant","colorScheme","variantProps","extractedProps","mergeUnderscoreProps"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.extractProps = extractProps;\nexports.mergeUnderscoreProps = mergeUnderscoreProps;\nexports.calculateProps = calculateProps;\nexports.resolveValueWithBreakpoint = exports.extractPropertyFromFunction = void 0;\n\nvar _lodash = _interopRequireDefault(require(\"lodash.get\"));\n\nvar _lodash2 = _interopRequireDefault(require(\"lodash.isnil\"));\n\nvar _lodash3 = _interopRequireDefault(require(\"lodash.mergewith\"));\n\nvar _lodash4 = _interopRequireDefault(require(\"lodash.clonedeep\"));\n\nvar _base = require(\"./../../theme/base\");\n\nvar _tools = require(\"./../../theme/tools\");\n\nvar _useContrastText = require(\"../useContrastText\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n Extract props from theme props and omit those from props\n*/\n\n/**\n *\n * @param props Props passed by the user\n * @param theme Theme object\n * @param colorModeProps `colorMode` object\n * @param componentTheme Theme for specific components\n * @param currentBreakpoint Current breakpoint values\n * @returns Extracting props from defaultProps while overriding the props that are already present\n */\nfunction extractProps(props, theme, {}, componentTheme, currentBreakpoint) {\n  let newProps = {};\n\n  for (let property in props) {\n    // If the property exists in themePropertyMap then get its value\n    if (_base.themePropertyMap[property]) {\n      let propValues = extractPropertyFromFunction(property, props, theme, componentTheme);\n\n      if (typeof propValues === 'string' || typeof propValues === 'number') {\n        newProps[property] = propValues;\n      } else if (!(0, _lodash2.default)(propValues)) {\n        for (let nestedProp in propValues) {\n          newProps[nestedProp] = (0, _lodash.default)(theme, \"\".concat(_base.themePropertyMap[nestedProp], \".\").concat(propValues[nestedProp]), propValues[nestedProp]);\n        }\n      } else if (property === 'shadow') {\n        let shadowProps = theme[_base.themePropertyMap[property]][props[property]];\n\n        if (!(0, _lodash2.default)(shadowProps)) {\n          newProps = { ...newProps,\n            ...shadowProps\n          };\n        }\n      } else {\n        newProps[property] = resolveValueWithBreakpoint(props[property], theme.breakpoints, currentBreakpoint, property);\n      }\n    } else {\n      newProps[property] = resolveValueWithBreakpoint(props[property], theme.breakpoints, currentBreakpoint, property);\n    }\n  }\n\n  return (0, _lodash4.default)(newProps);\n}\n/*\nRemove props from defaultProps that are already present in props\n*/\n\n\nfunction filterDefaultProps(props, defaultProps) {\n  let [, resultProps] = (0, _tools.extractInObject)(defaultProps, Object.keys(props));\n  return resultProps;\n}\n/**\n * If property is functional in componentTheme, get its returned object\n *\n * @param property : name of the prop\n * @param props : all props\n * @param theme : provided theme without components\n * @param componentTheme : component specific theme\n * @returns\n */\n\n\nconst extractPropertyFromFunction = (property, props, theme, componentTheme) => {\n  let propValues; // Check if the entry in the theme is a function then calling it with all theme and props as params\n\n  if (componentTheme && typeof componentTheme[_base.themePropertyMap[property]] === 'function') {\n    let funcProps = componentTheme[_base.themePropertyMap[property]]({\n      theme,\n      ...props\n    }); // Check if returned object from componentTheme is a nested object\n\n\n    let isNested = Object.keys(funcProps).some(function (key) {\n      return funcProps[key] && typeof funcProps[key] === 'object';\n    }); // If the returned value is nested object then find the property value in it, otherwise return the whole object\n\n    propValues = isNested ? { ...(0, _lodash.default)(funcProps, \"\".concat(props[property]))\n    } : { ...funcProps\n    };\n  } else {\n    // If the entry is any value other than function then return the whole object or value\n    propValues = (0, _lodash.default)(componentTheme, \"\".concat(_base.themePropertyMap[property], \".\").concat(props[property]));\n  }\n\n  return propValues;\n};\n/*\nMerge _props and apply contrastText color if not passed by theme or user\n*/\n\n\nexports.extractPropertyFromFunction = extractPropertyFromFunction;\n\nfunction mergeUnderscoreProps(newProps, props) {\n  const _props = Object.keys(newProps).filter(propName => propName.startsWith('_'));\n\n  _props.forEach(propName => {\n    var _newProps$bg, _newProps$propName$co, _newProps$propName, _props$propName;\n\n    // Adding color based on bg contrast if no color is given\n    const bg = (_newProps$bg = newProps.bg) !== null && _newProps$bg !== void 0 ? _newProps$bg : newProps.backgroundColor;\n    const textColor = bg ? {\n      color: (0, _useContrastText.useContrastText)(bg, (_newProps$propName$co = (_newProps$propName = newProps[propName]) === null || _newProps$propName === void 0 ? void 0 : _newProps$propName.color) !== null && _newProps$propName$co !== void 0 ? _newProps$propName$co : (_props$propName = props[propName]) === null || _props$propName === void 0 ? void 0 : _props$propName.color)\n    } : {}; // Overriding calculated props with user added props\n\n    newProps[propName] = { ...textColor,\n      ...newProps[propName],\n      ...props[propName]\n    };\n  });\n\n  return newProps;\n}\n/**\n *\n * Checks the property and resolves it if it has breakpoints\n * @param values : value from props\n * @param currentBreakpoint : current value for which breakpoint will be calculated\n * @param property : property name\n * @returns\n */\n\n\nconst resolveValueWithBreakpoint = (values, breakpointTheme, currentBreakpoint, property) => {\n  if ((0, _tools.hasValidBreakpointFormat)(values, breakpointTheme, property)) {\n    // Check the last valid breakpoint value from all values\n    // If current breakpoint is `md` and we have `base` then `lg`, then last value will be taken(`base` in this case)\n    return (0, _tools.findLastValidBreakpoint)(values, breakpointTheme, currentBreakpoint);\n  } else {\n    return values;\n  }\n};\n/**\n * Takes all prop related data and returns the props that needs to be applied to the component\n *\n * @param theme Theme object\n * @param colorModeProps Color mode information\n * @param componentTheme Theme object for the specific component\n * @param props Props passed by the user\n * @param windowWidth Width of the current window\n * @returns props to be applied\n */\n\n\nexports.resolveValueWithBreakpoint = resolveValueWithBreakpoint;\n\nfunction calculateProps(theme, colorModeProps, componentTheme, props, windowWidth) {\n  let currentBreakpoint = (0, _tools.getClosestBreakpoint)(theme.breakpoints, windowWidth);\n\n  if (!props) {\n    props = {};\n  }\n\n  let newProps;\n\n  if (componentTheme) {\n    // Extracting props from defaultProps\n    newProps = extractProps(filterDefaultProps(props, componentTheme.defaultProps), theme, colorModeProps, componentTheme, currentBreakpoint); // Extracting props from base style\n\n    let componentBaseStyle = typeof componentTheme.baseStyle !== 'function' ? componentTheme.baseStyle : componentTheme.baseStyle({\n      theme,\n      ...newProps,\n      ...props,\n      ...colorModeProps\n    });\n    newProps = (0, _lodash3.default)(newProps, componentBaseStyle, // @ts-ignore\n    (objValue, srcValue, key) => {\n      if (!(0, _lodash2.default)(objValue)) {\n        delete newProps[key];\n      }\n    });\n    const variant = props.variant || (0, _lodash.default)(componentTheme, 'defaultProps.variant'); // Extracting props from variant\n\n    if (variant && componentTheme.variants && componentTheme.variants[variant]) {\n      const colorScheme = props.colorScheme || (0, _lodash.default)(componentTheme, 'defaultProps.colorScheme');\n      let variantProps = componentTheme.variants[variant]({ ...props,\n        ...newProps,\n        colorScheme,\n        theme,\n        ...colorModeProps\n      });\n      variantProps = extractProps(variantProps, theme, colorModeProps, componentTheme, currentBreakpoint); // added this to handle order of props\n\n      newProps = (0, _lodash3.default)(newProps, variantProps, // @ts-ignore\n      (objValue, srcValue, key) => {\n        if (!(0, _lodash2.default)(objValue)) {\n          delete newProps[key];\n        }\n      });\n      delete newProps.variant;\n      delete newProps.colorScheme;\n    }\n  } // Extracting props from normal props\n\n\n  let extractedProps = extractProps(props, theme, colorModeProps, componentTheme, currentBreakpoint); // added this to handle order of props\n  // @ts-ignore\n\n  newProps = (0, _lodash3.default)(newProps, extractedProps, (objValue, srcValue, key) => {\n    if (!(0, _lodash2.default)(objValue)) {\n      delete newProps[key];\n    }\n  });\n  newProps = mergeUnderscoreProps(newProps, props);\n  return newProps;\n}\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"script"}