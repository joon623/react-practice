{"ast":null,"code":"/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n'use strict';\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _performanceNow = _interopRequireDefault(require(\"fbjs/lib/performanceNow\"));\n\nvar _warning = _interopRequireDefault(require(\"fbjs/lib/warning\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar Info = function Info() {\n  this.any_blank_count = 0;\n  this.any_blank_ms = 0;\n  this.any_blank_speed_sum = 0;\n  this.mostly_blank_count = 0;\n  this.mostly_blank_ms = 0;\n  this.pixels_blank = 0;\n  this.pixels_sampled = 0;\n  this.pixels_scrolled = 0;\n  this.total_time_spent = 0;\n  this.sample_count = 0;\n};\n\n_c = Info;\nvar DEBUG = false;\nvar _listeners = [];\nvar _minSampleCount = 10;\n\nvar _sampleRate = DEBUG ? 1 : null;\n/**\n * A helper class for detecting when the maximem fill rate of `VirtualizedList` is exceeded.\n * By default the sampling rate is set to zero and this will do nothing. If you want to collect\n * samples (e.g. to log them), make sure to call `FillRateHelper.setSampleRate(0.0-1.0)`.\n *\n * Listeners and sample rate are global for all `VirtualizedList`s - typical usage will combine with\n * `SceneTracker.getActiveScene` to determine the context of the events.\n */\n\n\nvar FillRateHelper = /*#__PURE__*/function () {\n  FillRateHelper.addListener = function addListener(callback) {\n    (0, _warning[\"default\"])(_sampleRate !== null, 'Call `FillRateHelper.setSampleRate` before `addListener`.');\n\n    _listeners.push(callback);\n\n    return {\n      remove: function remove() {\n        _listeners = _listeners.filter(function (listener) {\n          return callback !== listener;\n        });\n      }\n    };\n  };\n\n  FillRateHelper.setSampleRate = function setSampleRate(sampleRate) {\n    _sampleRate = sampleRate;\n  };\n\n  FillRateHelper.setMinSampleCount = function setMinSampleCount(minSampleCount) {\n    _minSampleCount = minSampleCount;\n  };\n\n  function FillRateHelper(getFrameMetrics) {\n    this._anyBlankStartTime = null;\n    this._enabled = false;\n    this._info = new Info();\n    this._mostlyBlankStartTime = null;\n    this._samplesStartTime = null;\n    this._getFrameMetrics = getFrameMetrics;\n    this._enabled = (_sampleRate || 0) > Math.random();\n\n    this._resetData();\n  }\n\n  var _proto = FillRateHelper.prototype;\n\n  _proto.activate = function activate() {\n    if (this._enabled && this._samplesStartTime == null) {\n      DEBUG && console.debug('FillRateHelper: activate');\n      this._samplesStartTime = (0, _performanceNow[\"default\"])();\n    }\n  };\n\n  _proto.deactivateAndFlush = function deactivateAndFlush() {\n    if (!this._enabled) {\n      return;\n    }\n\n    var start = this._samplesStartTime; // const for flow\n\n    if (start == null) {\n      DEBUG && console.debug('FillRateHelper: bail on deactivate with no start time');\n      return;\n    }\n\n    if (this._info.sample_count < _minSampleCount) {\n      // Don't bother with under-sampled events.\n      this._resetData();\n\n      return;\n    }\n\n    var total_time_spent = (0, _performanceNow[\"default\"])() - start;\n\n    var info = _objectSpread({}, this._info, {\n      total_time_spent: total_time_spent\n    });\n\n    if (DEBUG) {\n      var derived = {\n        avg_blankness: this._info.pixels_blank / this._info.pixels_sampled,\n        avg_speed: this._info.pixels_scrolled / (total_time_spent / 1000),\n        avg_speed_when_any_blank: this._info.any_blank_speed_sum / this._info.any_blank_count,\n        any_blank_per_min: this._info.any_blank_count / (total_time_spent / 1000 / 60),\n        any_blank_time_frac: this._info.any_blank_ms / total_time_spent,\n        mostly_blank_per_min: this._info.mostly_blank_count / (total_time_spent / 1000 / 60),\n        mostly_blank_time_frac: this._info.mostly_blank_ms / total_time_spent\n      };\n\n      for (var key in derived) {\n        derived[key] = Math.round(1000 * derived[key]) / 1000;\n      }\n\n      console.debug('FillRateHelper deactivateAndFlush: ', {\n        derived: derived,\n        info: info\n      });\n    }\n\n    _listeners.forEach(function (listener) {\n      return listener(info);\n    });\n\n    this._resetData();\n  };\n\n  _proto.computeBlankness = function computeBlankness(props, state, scrollMetrics) {\n    if (!this._enabled || props.getItemCount(props.data) === 0 || this._samplesStartTime == null) {\n      return 0;\n    }\n\n    var dOffset = scrollMetrics.dOffset,\n        offset = scrollMetrics.offset,\n        velocity = scrollMetrics.velocity,\n        visibleLength = scrollMetrics.visibleLength; // Denominator metrics that we track for all events - most of the time there is no blankness and\n    // we want to capture that.\n\n    this._info.sample_count++;\n    this._info.pixels_sampled += Math.round(visibleLength);\n    this._info.pixels_scrolled += Math.round(Math.abs(dOffset));\n    var scrollSpeed = Math.round(Math.abs(velocity) * 1000); // px / sec\n    // Whether blank now or not, record the elapsed time blank if we were blank last time.\n\n    var now = (0, _performanceNow[\"default\"])();\n\n    if (this._anyBlankStartTime != null) {\n      this._info.any_blank_ms += now - this._anyBlankStartTime;\n    }\n\n    this._anyBlankStartTime = null;\n\n    if (this._mostlyBlankStartTime != null) {\n      this._info.mostly_blank_ms += now - this._mostlyBlankStartTime;\n    }\n\n    this._mostlyBlankStartTime = null;\n    var blankTop = 0;\n    var first = state.first;\n\n    var firstFrame = this._getFrameMetrics(first);\n\n    while (first <= state.last && (!firstFrame || !firstFrame.inLayout)) {\n      firstFrame = this._getFrameMetrics(first);\n      first++;\n    } // Only count blankTop if we aren't rendering the first item, otherwise we will count the header\n    // as blank.\n\n\n    if (firstFrame && first > 0) {\n      blankTop = Math.min(visibleLength, Math.max(0, firstFrame.offset - offset));\n    }\n\n    var blankBottom = 0;\n    var last = state.last;\n\n    var lastFrame = this._getFrameMetrics(last);\n\n    while (last >= state.first && (!lastFrame || !lastFrame.inLayout)) {\n      lastFrame = this._getFrameMetrics(last);\n      last--;\n    } // Only count blankBottom if we aren't rendering the last item, otherwise we will count the\n    // footer as blank.\n\n\n    if (lastFrame && last < props.getItemCount(props.data) - 1) {\n      var bottomEdge = lastFrame.offset + lastFrame.length;\n      blankBottom = Math.min(visibleLength, Math.max(0, offset + visibleLength - bottomEdge));\n    }\n\n    var pixels_blank = Math.round(blankTop + blankBottom);\n    var blankness = pixels_blank / visibleLength;\n\n    if (blankness > 0) {\n      this._anyBlankStartTime = now;\n      this._info.any_blank_speed_sum += scrollSpeed;\n      this._info.any_blank_count++;\n      this._info.pixels_blank += pixels_blank;\n\n      if (blankness > 0.5) {\n        this._mostlyBlankStartTime = now;\n        this._info.mostly_blank_count++;\n      }\n    } else if (scrollSpeed < 0.01 || Math.abs(dOffset) < 1) {\n      this.deactivateAndFlush();\n    }\n\n    return blankness;\n  };\n\n  _proto.enabled = function enabled() {\n    return this._enabled;\n  };\n\n  _proto._resetData = function _resetData() {\n    this._anyBlankStartTime = null;\n    this._info = new Info();\n    this._mostlyBlankStartTime = null;\n    this._samplesStartTime = null;\n  };\n\n  return FillRateHelper;\n}();\n\nvar _default = FillRateHelper;\nexports[\"default\"] = _default;\nmodule.exports = exports[\"default\"];\n\nvar _c;\n\n$RefreshReg$(_c, \"Info\");\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = __webpack_module__.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      __webpack_module__.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      import.meta.webpackHot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          __webpack_module__.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        __webpack_module__.hot.invalidate();\n      }\n    }\n  }\n})();","map":{"version":3,"sources":["/Users/jun/Desktop/dev/react-practice/with-react-native-web-app/node_modules/react-native-web/dist/cjs/vendor/react-native/FillRateHelper/index.js"],"names":["exports","_performanceNow","_interopRequireDefault","require","_warning","obj","keys","Object","symbols","i","arguments","source","ownKeys","_defineProperty","key","value","enumerable","configurable","writable","Info","DEBUG","_listeners","_minSampleCount","_sampleRate","FillRateHelper","remove","callback","Math","_proto","console","start","total_time_spent","info","_objectSpread","derived","avg_blankness","avg_speed","avg_speed_when_any_blank","any_blank_per_min","any_blank_time_frac","mostly_blank_per_min","mostly_blank_time_frac","listener","props","dOffset","scrollMetrics","offset","velocity","visibleLength","scrollSpeed","now","blankTop","first","state","firstFrame","blankBottom","last","lastFrame","bottomEdge","pixels_blank","blankness","_default","module"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2015-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n'use strict';\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _performanceNow = _interopRequireDefault(require(\"fbjs/lib/performanceNow\"));\n\nvar _warning = _interopRequireDefault(require(\"fbjs/lib/warning\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar Info = function Info() {\n  this.any_blank_count = 0;\n  this.any_blank_ms = 0;\n  this.any_blank_speed_sum = 0;\n  this.mostly_blank_count = 0;\n  this.mostly_blank_ms = 0;\n  this.pixels_blank = 0;\n  this.pixels_sampled = 0;\n  this.pixels_scrolled = 0;\n  this.total_time_spent = 0;\n  this.sample_count = 0;\n};\n\nvar DEBUG = false;\nvar _listeners = [];\nvar _minSampleCount = 10;\n\nvar _sampleRate = DEBUG ? 1 : null;\n/**\n * A helper class for detecting when the maximem fill rate of `VirtualizedList` is exceeded.\n * By default the sampling rate is set to zero and this will do nothing. If you want to collect\n * samples (e.g. to log them), make sure to call `FillRateHelper.setSampleRate(0.0-1.0)`.\n *\n * Listeners and sample rate are global for all `VirtualizedList`s - typical usage will combine with\n * `SceneTracker.getActiveScene` to determine the context of the events.\n */\n\n\nvar FillRateHelper =\n/*#__PURE__*/\nfunction () {\n  FillRateHelper.addListener = function addListener(callback) {\n    (0, _warning.default)(_sampleRate !== null, 'Call `FillRateHelper.setSampleRate` before `addListener`.');\n\n    _listeners.push(callback);\n\n    return {\n      remove: function remove() {\n        _listeners = _listeners.filter(function (listener) {\n          return callback !== listener;\n        });\n      }\n    };\n  };\n\n  FillRateHelper.setSampleRate = function setSampleRate(sampleRate) {\n    _sampleRate = sampleRate;\n  };\n\n  FillRateHelper.setMinSampleCount = function setMinSampleCount(minSampleCount) {\n    _minSampleCount = minSampleCount;\n  };\n\n  function FillRateHelper(getFrameMetrics) {\n    this._anyBlankStartTime = null;\n    this._enabled = false;\n    this._info = new Info();\n    this._mostlyBlankStartTime = null;\n    this._samplesStartTime = null;\n    this._getFrameMetrics = getFrameMetrics;\n    this._enabled = (_sampleRate || 0) > Math.random();\n\n    this._resetData();\n  }\n\n  var _proto = FillRateHelper.prototype;\n\n  _proto.activate = function activate() {\n    if (this._enabled && this._samplesStartTime == null) {\n      DEBUG && console.debug('FillRateHelper: activate');\n      this._samplesStartTime = (0, _performanceNow.default)();\n    }\n  };\n\n  _proto.deactivateAndFlush = function deactivateAndFlush() {\n    if (!this._enabled) {\n      return;\n    }\n\n    var start = this._samplesStartTime; // const for flow\n\n    if (start == null) {\n      DEBUG && console.debug('FillRateHelper: bail on deactivate with no start time');\n      return;\n    }\n\n    if (this._info.sample_count < _minSampleCount) {\n      // Don't bother with under-sampled events.\n      this._resetData();\n\n      return;\n    }\n\n    var total_time_spent = (0, _performanceNow.default)() - start;\n\n    var info = _objectSpread({}, this._info, {\n      total_time_spent: total_time_spent\n    });\n\n    if (DEBUG) {\n      var derived = {\n        avg_blankness: this._info.pixels_blank / this._info.pixels_sampled,\n        avg_speed: this._info.pixels_scrolled / (total_time_spent / 1000),\n        avg_speed_when_any_blank: this._info.any_blank_speed_sum / this._info.any_blank_count,\n        any_blank_per_min: this._info.any_blank_count / (total_time_spent / 1000 / 60),\n        any_blank_time_frac: this._info.any_blank_ms / total_time_spent,\n        mostly_blank_per_min: this._info.mostly_blank_count / (total_time_spent / 1000 / 60),\n        mostly_blank_time_frac: this._info.mostly_blank_ms / total_time_spent\n      };\n\n      for (var key in derived) {\n        derived[key] = Math.round(1000 * derived[key]) / 1000;\n      }\n\n      console.debug('FillRateHelper deactivateAndFlush: ', {\n        derived: derived,\n        info: info\n      });\n    }\n\n    _listeners.forEach(function (listener) {\n      return listener(info);\n    });\n\n    this._resetData();\n  };\n\n  _proto.computeBlankness = function computeBlankness(props, state, scrollMetrics) {\n    if (!this._enabled || props.getItemCount(props.data) === 0 || this._samplesStartTime == null) {\n      return 0;\n    }\n\n    var dOffset = scrollMetrics.dOffset,\n        offset = scrollMetrics.offset,\n        velocity = scrollMetrics.velocity,\n        visibleLength = scrollMetrics.visibleLength; // Denominator metrics that we track for all events - most of the time there is no blankness and\n    // we want to capture that.\n\n    this._info.sample_count++;\n    this._info.pixels_sampled += Math.round(visibleLength);\n    this._info.pixels_scrolled += Math.round(Math.abs(dOffset));\n    var scrollSpeed = Math.round(Math.abs(velocity) * 1000); // px / sec\n    // Whether blank now or not, record the elapsed time blank if we were blank last time.\n\n    var now = (0, _performanceNow.default)();\n\n    if (this._anyBlankStartTime != null) {\n      this._info.any_blank_ms += now - this._anyBlankStartTime;\n    }\n\n    this._anyBlankStartTime = null;\n\n    if (this._mostlyBlankStartTime != null) {\n      this._info.mostly_blank_ms += now - this._mostlyBlankStartTime;\n    }\n\n    this._mostlyBlankStartTime = null;\n    var blankTop = 0;\n    var first = state.first;\n\n    var firstFrame = this._getFrameMetrics(first);\n\n    while (first <= state.last && (!firstFrame || !firstFrame.inLayout)) {\n      firstFrame = this._getFrameMetrics(first);\n      first++;\n    } // Only count blankTop if we aren't rendering the first item, otherwise we will count the header\n    // as blank.\n\n\n    if (firstFrame && first > 0) {\n      blankTop = Math.min(visibleLength, Math.max(0, firstFrame.offset - offset));\n    }\n\n    var blankBottom = 0;\n    var last = state.last;\n\n    var lastFrame = this._getFrameMetrics(last);\n\n    while (last >= state.first && (!lastFrame || !lastFrame.inLayout)) {\n      lastFrame = this._getFrameMetrics(last);\n      last--;\n    } // Only count blankBottom if we aren't rendering the last item, otherwise we will count the\n    // footer as blank.\n\n\n    if (lastFrame && last < props.getItemCount(props.data) - 1) {\n      var bottomEdge = lastFrame.offset + lastFrame.length;\n      blankBottom = Math.min(visibleLength, Math.max(0, offset + visibleLength - bottomEdge));\n    }\n\n    var pixels_blank = Math.round(blankTop + blankBottom);\n    var blankness = pixels_blank / visibleLength;\n\n    if (blankness > 0) {\n      this._anyBlankStartTime = now;\n      this._info.any_blank_speed_sum += scrollSpeed;\n      this._info.any_blank_count++;\n      this._info.pixels_blank += pixels_blank;\n\n      if (blankness > 0.5) {\n        this._mostlyBlankStartTime = now;\n        this._info.mostly_blank_count++;\n      }\n    } else if (scrollSpeed < 0.01 || Math.abs(dOffset) < 1) {\n      this.deactivateAndFlush();\n    }\n\n    return blankness;\n  };\n\n  _proto.enabled = function enabled() {\n    return this._enabled;\n  };\n\n  _proto._resetData = function _resetData() {\n    this._anyBlankStartTime = null;\n    this._info = new Info();\n    this._mostlyBlankStartTime = null;\n    this._samplesStartTime = null;\n  };\n\n  return FillRateHelper;\n}();\n\nvar _default = FillRateHelper;\nexports.default = _default;\nmodule.exports = exports.default;"]},"metadata":{},"sourceType":"module"}