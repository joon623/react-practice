{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nimport { useFocusManager } from '@react-aria/focus';\nimport { useId } from '@react-aria/utils';\nimport Platform from \"react-native-web/dist/cjs/exports/Platform\";\nexport var useMenuTrigger = function useMenuTrigger(_ref) {\n  _s();\n\n  var handleOpen = _ref.handleOpen,\n      isOpen = _ref.isOpen;\n  var menuTriggerId = useId();\n  return {\n    'onKeyDownCapture': function onKeyDownCapture(event) {\n      if ([' ', 'Enter', 'ArrowUp', 'ArrowDown'].includes(event.key)) {\n        event.preventDefault();\n        handleOpen();\n      }\n    },\n    'aria-haspopup': 'menu',\n    'aria-expanded': isOpen ? true : undefined,\n    'nativeID': menuTriggerId\n  };\n};\n\n_s(useMenuTrigger, \"WIniQbgrG9QuwlCGdx2QSzgUCpE=\", false, function () {\n  return [useId];\n});\n\nexport var useMenu = function useMenu() {\n  _s2();\n\n  var focusManager = useFocusManager();\n\n  var onKeyDown = function onKeyDown(e) {\n    switch (e.key) {\n      case 'ArrowDown':\n        {\n          e.preventDefault();\n          focusManager.focusNext({\n            wrap: true\n          });\n          break;\n        }\n\n      case 'ArrowUp':\n        {\n          e.preventDefault();\n          focusManager.focusPrevious({\n            wrap: true\n          });\n          break;\n        }\n    }\n  };\n\n  return {\n    onKeyDown: onKeyDown,\n    accessibilityRole: 'menu'\n  };\n};\n\n_s2(useMenu, \"TUPiCS0a6rVuat3V2m5berkSuMI=\", false, function () {\n  return [useFocusManager];\n});\n\nexport var useMenuItem = function useMenuItem(_ref2) {\n  var textValue = _ref2.textValue,\n      ref = _ref2.ref;\n  return {\n    accessibilityRole: 'menuitem',\n    dataSet: {\n      nativebaseMenuItem: textValue\n    },\n    onHoverIn: function onHoverIn() {\n      if (ref.current && Platform.OS === 'web') ref.current.focus();\n    }\n  };\n};\nexport var useMenuOptionItem = function useMenuOptionItem(_ref3) {\n  var isChecked = _ref3.isChecked,\n      type = _ref3.type;\n  return {\n    accessibilityRole: 'menuitem' + (Platform.OS === 'web' ? type : ''),\n    accessibilityState: {\n      checked: isChecked\n    },\n    accessibilityChecked: isChecked\n  };\n};\nvar ITEM_ATTR = 'data-nativebase-menu-item';\n\nvar getValue = function getValue(element) {\n  var _element$getAttribute;\n\n  return (_element$getAttribute = element.getAttribute(ITEM_ATTR)) !== null && _element$getAttribute !== void 0 ? _element$getAttribute : '';\n};\n\nexport var useMenuTypeahead = function useMenuTypeahead(props) {\n  return {\n    onKeyDown: function onKeyDown(event) {\n      if (props.onKeyDown) {\n        props.onKeyDown(event);\n      }\n\n      if (event.key.length === 1 && !(event.ctrlKey || event.altKey || event.metaKey)) {\n        var container = event.currentTarget;\n        var values = Array.from(container.querySelectorAll(\"[\".concat(ITEM_ATTR, \"]\"))).map(getValue);\n        var searchKey = event.key;\n        var foundValue = values.find(function (value) {\n          return value.toLowerCase().startsWith(searchKey);\n        });\n        var newItem = container.querySelector(\"[\".concat(ITEM_ATTR, \"=\\\"\").concat(foundValue, \"\\\"]\"));\n\n        if (newItem) {\n          /**\n           * Imperative focus during keydown is risky so we prevent React's batching updates\n           * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n           */\n          setTimeout(function () {\n            return newItem.focus();\n          });\n        }\n      }\n    }\n  };\n};\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = __webpack_module__.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      __webpack_module__.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      import.meta.webpackHot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          __webpack_module__.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        __webpack_module__.hot.invalidate();\n      }\n    }\n  }\n})();","map":{"version":3,"sources":["/Users/jun/Desktop/dev/react-practice/with-react-native-web-app/node_modules/native-base/lib/module/components/composites/Menu/useMenu.js"],"names":["useMenuTrigger","handleOpen","isOpen","menuTriggerId","useId","event","useMenu","focusManager","useFocusManager","onKeyDown","e","wrap","accessibilityRole","useMenuItem","textValue","ref","dataSet","nativebaseMenuItem","onHoverIn","Platform","useMenuOptionItem","isChecked","type","accessibilityState","checked","accessibilityChecked","ITEM_ATTR","getValue","_element$getAttribute","element","useMenuTypeahead","props","container","values","Array","searchKey","foundValue","value","newItem","setTimeout"],"mappings":"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","sourcesContent":["import { useFocusManager } from '@react-aria/focus';\nimport { useId } from '@react-aria/utils';\nimport { Platform } from 'react-native';\nexport const useMenuTrigger = ({\n  handleOpen,\n  isOpen\n}) => {\n  const menuTriggerId = useId();\n  return {\n    'onKeyDownCapture': event => {\n      if ([' ', 'Enter', 'ArrowUp', 'ArrowDown'].includes(event.key)) {\n        event.preventDefault();\n        handleOpen();\n      }\n    },\n    'aria-haspopup': 'menu',\n    'aria-expanded': isOpen ? true : undefined,\n    'nativeID': menuTriggerId\n  };\n};\nexport const useMenu = () => {\n  const focusManager = useFocusManager();\n\n  const onKeyDown = e => {\n    switch (e.key) {\n      case 'ArrowDown':\n        {\n          e.preventDefault();\n          focusManager.focusNext({\n            wrap: true\n          });\n          break;\n        }\n\n      case 'ArrowUp':\n        {\n          e.preventDefault();\n          focusManager.focusPrevious({\n            wrap: true\n          });\n          break;\n        }\n    }\n  };\n\n  return {\n    onKeyDown,\n    accessibilityRole: 'menu'\n  };\n};\nexport const useMenuItem = ({\n  textValue,\n  ref\n}) => {\n  return {\n    accessibilityRole: 'menuitem',\n    dataSet: {\n      nativebaseMenuItem: textValue\n    },\n    onHoverIn: () => {\n      if (ref.current && Platform.OS === 'web') ref.current.focus();\n    }\n  };\n};\nexport const useMenuOptionItem = ({\n  isChecked,\n  type\n}) => {\n  return {\n    accessibilityRole: 'menuitem' + (Platform.OS === 'web' ? type : ''),\n    accessibilityState: {\n      checked: isChecked\n    },\n    accessibilityChecked: isChecked\n  };\n};\nconst ITEM_ATTR = 'data-nativebase-menu-item';\n\nconst getValue = element => {\n  var _element$getAttribute;\n\n  return (_element$getAttribute = element.getAttribute(ITEM_ATTR)) !== null && _element$getAttribute !== void 0 ? _element$getAttribute : '';\n};\n\nexport const useMenuTypeahead = props => {\n  return {\n    onKeyDown(event) {\n      if (props.onKeyDown) {\n        props.onKeyDown(event);\n      }\n\n      if (event.key.length === 1 && !(event.ctrlKey || event.altKey || event.metaKey)) {\n        const container = event.currentTarget;\n        const values = Array.from(container.querySelectorAll(\"[\".concat(ITEM_ATTR, \"]\"))).map(getValue);\n        const searchKey = event.key;\n        const foundValue = values.find(value => value.toLowerCase().startsWith(searchKey));\n        const newItem = container.querySelector(\"[\".concat(ITEM_ATTR, \"=\\\"\").concat(foundValue, \"\\\"]\"));\n\n        if (newItem) {\n          /**\n           * Imperative focus during keydown is risky so we prevent React's batching updates\n           * to avoid potential bugs. See: https://github.com/facebook/react/issues/20332\n           */\n          setTimeout(() => newItem.focus());\n        }\n      }\n    }\n\n  };\n};\n//# sourceMappingURL=useMenu.js.map"]},"metadata":{},"sourceType":"module"}