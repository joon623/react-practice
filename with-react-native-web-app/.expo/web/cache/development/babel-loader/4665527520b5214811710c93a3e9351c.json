{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = exports.ImageUriCache = void 0;\n/**\n * Copyright (c) Nicolas Gallagher.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\nvar dataUriPattern = /^data:/;\n\nvar ImageUriCache = /*#__PURE__*/function () {\n  function ImageUriCache() {}\n\n  ImageUriCache.has = function has(uri) {\n    var entries = ImageUriCache._entries;\n    var isDataUri = dataUriPattern.test(uri);\n    return isDataUri || Boolean(entries[uri]);\n  };\n\n  ImageUriCache.add = function add(uri) {\n    var entries = ImageUriCache._entries;\n    var lastUsedTimestamp = Date.now();\n\n    if (entries[uri]) {\n      entries[uri].lastUsedTimestamp = lastUsedTimestamp;\n      entries[uri].refCount += 1;\n    } else {\n      entries[uri] = {\n        lastUsedTimestamp: lastUsedTimestamp,\n        refCount: 1\n      };\n    }\n  };\n\n  ImageUriCache.remove = function remove(uri) {\n    var entries = ImageUriCache._entries;\n\n    if (entries[uri]) {\n      entries[uri].refCount -= 1;\n    } // Free up entries when the cache is \"full\"\n\n\n    ImageUriCache._cleanUpIfNeeded();\n  };\n\n  ImageUriCache._cleanUpIfNeeded = function _cleanUpIfNeeded() {\n    var entries = ImageUriCache._entries;\n    var imageUris = Object.keys(entries);\n\n    if (imageUris.length + 1 > ImageUriCache._maximumEntries) {\n      var leastRecentlyUsedKey;\n      var leastRecentlyUsedEntry;\n      imageUris.forEach(function (uri) {\n        var entry = entries[uri];\n\n        if ((!leastRecentlyUsedEntry || entry.lastUsedTimestamp < leastRecentlyUsedEntry.lastUsedTimestamp) && entry.refCount === 0) {\n          leastRecentlyUsedKey = uri;\n          leastRecentlyUsedEntry = entry;\n        }\n      });\n\n      if (leastRecentlyUsedKey) {\n        delete entries[leastRecentlyUsedKey];\n      }\n    }\n  };\n\n  return ImageUriCache;\n}();\n\nexports.ImageUriCache = ImageUriCache;\nImageUriCache._maximumEntries = 256;\nImageUriCache._entries = {};\nvar id = 0;\nvar requests = {};\nvar ImageLoader = {\n  abort: function abort(requestId) {\n    var image = requests[\"\" + requestId];\n\n    if (image) {\n      image.onerror = null;\n      image.onload = null;\n      image = null;\n      delete requests[\"\" + requestId];\n    }\n  },\n  getSize: function getSize(uri, success, failure) {\n    var complete = false;\n    var interval = setInterval(callback, 16);\n    var requestId = ImageLoader.load(uri, callback, errorCallback);\n\n    function callback() {\n      var image = requests[\"\" + requestId];\n\n      if (image) {\n        var naturalHeight = image.naturalHeight,\n            naturalWidth = image.naturalWidth;\n\n        if (naturalHeight && naturalWidth) {\n          success(naturalWidth, naturalHeight);\n          complete = true;\n        }\n      }\n\n      if (complete) {\n        ImageLoader.abort(requestId);\n        clearInterval(interval);\n      }\n    }\n\n    function errorCallback() {\n      if (typeof failure === 'function') {\n        failure();\n      }\n\n      ImageLoader.abort(requestId);\n      clearInterval(interval);\n    }\n  },\n  has: function has(uri) {\n    return ImageUriCache.has(uri);\n  },\n  load: function load(uri, onLoad, onError) {\n    id += 1;\n    var image = new window.Image();\n    image.onerror = onError;\n\n    image.onload = function (e) {\n      // avoid blocking the main thread\n      var onDecode = function onDecode() {\n        return onLoad({\n          nativeEvent: e\n        });\n      };\n\n      if (typeof image.decode === 'function') {\n        // Safari currently throws exceptions when decoding svgs.\n        // We want to catch that error and allow the load handler\n        // to be forwarded to the onLoad handler in this case\n        image.decode().then(onDecode, onDecode);\n      } else {\n        setTimeout(onDecode, 0);\n      }\n    };\n\n    image.src = uri;\n    requests[\"\" + id] = image;\n    return id;\n  },\n  prefetch: function prefetch(uri) {\n    return new Promise(function (resolve, reject) {\n      ImageLoader.load(uri, function () {\n        // Add the uri to the cache so it can be immediately displayed when used\n        // but also immediately remove it to correctly reflect that it has no active references\n        ImageUriCache.add(uri);\n        ImageUriCache.remove(uri);\n        resolve();\n      }, reject);\n    });\n  },\n  queryCache: function queryCache(uris) {\n    var result = {};\n    uris.forEach(function (u) {\n      if (ImageUriCache.has(u)) {\n        result[u] = 'disk/memory';\n      }\n    });\n    return Promise.resolve(result);\n  }\n};\nvar _default = ImageLoader;\nexports[\"default\"] = _default;","map":{"version":3,"sources":["/Users/jun/Desktop/dev/react-practice/with-react-native-web-app/node_modules/react-native-web/dist/cjs/modules/ImageLoader/index.js"],"names":["exports","dataUriPattern","ImageUriCache","entries","isDataUri","Boolean","lastUsedTimestamp","Date","refCount","imageUris","Object","entry","leastRecentlyUsedEntry","leastRecentlyUsedKey","id","requests","ImageLoader","abort","image","getSize","complete","interval","setInterval","requestId","naturalHeight","naturalWidth","success","clearInterval","failure","has","load","window","onDecode","onLoad","nativeEvent","e","setTimeout","prefetch","resolve","queryCache","result","uris","Promise","_default"],"mappings":"AAAA;;AAEAA,OAAO,CAAPA,UAAAA,GAAAA,IAAAA;AACAA,OAAAA,WAAAA,GAAkBA,OAAO,CAAPA,aAAAA,GAAwB,KAA1CA,CAAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAIC,cAAc,GAAlB,QAAA;;AAEA,IAAIC,aAAa,GACjB,aACA,YAAY;EACV,SAAA,aAAA,GAAyB,CAAE;;EAE3BA,aAAa,CAAbA,GAAAA,GAAoB,SAAA,GAAA,CAAA,GAAA,EAAkB;IACpC,IAAIC,OAAO,GAAGD,aAAa,CAA3B,QAAA;IACA,IAAIE,SAAS,GAAGH,cAAc,CAAdA,IAAAA,CAAhB,GAAgBA,CAAhB;IACA,OAAOG,SAAS,IAAIC,OAAO,CAACF,OAAO,CAAnC,GAAmC,CAAR,CAA3B;EAHFD,CAAAA;;EAMAA,aAAa,CAAbA,GAAAA,GAAoB,SAAA,GAAA,CAAA,GAAA,EAAkB;IACpC,IAAIC,OAAO,GAAGD,aAAa,CAA3B,QAAA;IACA,IAAII,iBAAiB,GAAGC,IAAI,CAA5B,GAAwBA,EAAxB;;IAEA,IAAIJ,OAAO,CAAX,GAAW,CAAX,EAAkB;MAChBA,OAAO,CAAPA,GAAO,CAAPA,CAAAA,iBAAAA,GAAAA,iBAAAA;MACAA,OAAO,CAAPA,GAAO,CAAPA,CAAAA,QAAAA,IAAAA,CAAAA;IAFF,CAAA,MAGO;MACLA,OAAO,CAAPA,GAAO,CAAPA,GAAe;QACbG,iBAAiB,EADJ,iBAAA;QAEbE,QAAQ,EAAE;MAFG,CAAfL;IAID;EAZHD,CAAAA;;EAeAA,aAAa,CAAbA,MAAAA,GAAuB,SAAA,MAAA,CAAA,GAAA,EAAqB;IAC1C,IAAIC,OAAO,GAAGD,aAAa,CAA3B,QAAA;;IAEA,IAAIC,OAAO,CAAX,GAAW,CAAX,EAAkB;MAChBA,OAAO,CAAPA,GAAO,CAAPA,CAAAA,QAAAA,IAAAA,CAAAA;IAJwC,CAAA,CAKxC;;;IAGFD,aAAa,CAAbA,gBAAAA;EARFA,CAAAA;;EAWAA,aAAa,CAAbA,gBAAAA,GAAiC,SAAA,gBAAA,GAA4B;IAC3D,IAAIC,OAAO,GAAGD,aAAa,CAA3B,QAAA;IACA,IAAIO,SAAS,GAAGC,MAAM,CAANA,IAAAA,CAAhB,OAAgBA,CAAhB;;IAEA,IAAID,SAAS,CAATA,MAAAA,GAAAA,CAAAA,GAAuBP,aAAa,CAAxC,eAAA,EAA0D;MACxD,IAAA,oBAAA;MACA,IAAA,sBAAA;MACAO,SAAS,CAATA,OAAAA,CAAkB,UAAA,GAAA,EAAe;QAC/B,IAAIE,KAAK,GAAGR,OAAO,CAAnB,GAAmB,CAAnB;;QAEA,IAAI,CAAC,CAAA,sBAAA,IAA2BQ,KAAK,CAALA,iBAAAA,GAA0BC,sBAAsB,CAA5E,iBAAA,KAAmGD,KAAK,CAALA,QAAAA,KAAvG,CAAA,EAA6H;UAC3HE,oBAAoB,GAApBA,GAAAA;UACAD,sBAAsB,GAAtBA,KAAAA;QACD;MANHH,CAAAA;;MASA,IAAA,oBAAA,EAA0B;QACxB,OAAON,OAAO,CAAd,oBAAc,CAAd;MACD;IACF;EAnBHD,CAAAA;;EAsBA,OAAA,aAAA;AA3DF,CAEA,EAFA;;AA8DAF,OAAO,CAAPA,aAAAA,GAAAA,aAAAA;AACAE,aAAa,CAAbA,eAAAA,GAAAA,GAAAA;AACAA,aAAa,CAAbA,QAAAA,GAAAA,EAAAA;AACA,IAAIY,EAAE,GAAN,CAAA;AACA,IAAIC,QAAQ,GAAZ,EAAA;AACA,IAAIC,WAAW,GAAG;EAChBC,KAAK,EAAE,SAAA,KAAA,CAAA,SAAA,EAA0B;IAC/B,IAAIC,KAAK,GAAGH,QAAQ,CAAC,KAArB,SAAoB,CAApB;;IAEA,IAAA,KAAA,EAAW;MACTG,KAAK,CAALA,OAAAA,GAAAA,IAAAA;MACAA,KAAK,CAALA,MAAAA,GAAAA,IAAAA;MACAA,KAAK,GAALA,IAAAA;MACA,OAAOH,QAAQ,CAAC,KAAhB,SAAe,CAAf;IACD;EATa,CAAA;EAWhBI,OAAO,EAAE,SAAA,OAAA,CAAA,GAAA,EAAA,OAAA,EAAA,OAAA,EAAwC;IAC/C,IAAIC,QAAQ,GAAZ,KAAA;IACA,IAAIC,QAAQ,GAAGC,WAAW,CAAA,QAAA,EAA1B,EAA0B,CAA1B;IACA,IAAIC,SAAS,GAAGP,WAAW,CAAXA,IAAAA,CAAAA,GAAAA,EAAAA,QAAAA,EAAhB,aAAgBA,CAAhB;;IAEA,SAAA,QAAA,GAAoB;MAClB,IAAIE,KAAK,GAAGH,QAAQ,CAAC,KAArB,SAAoB,CAApB;;MAEA,IAAA,KAAA,EAAW;QACT,IAAIS,aAAa,GAAGN,KAAK,CAAzB,aAAA;QAAA,IACIO,YAAY,GAAGP,KAAK,CADxB,YAAA;;QAGA,IAAIM,aAAa,IAAjB,YAAA,EAAmC;UACjCE,OAAO,CAAA,YAAA,EAAPA,aAAO,CAAPA;UACAN,QAAQ,GAARA,IAAAA;QACD;MACF;;MAED,IAAA,QAAA,EAAc;QACZJ,WAAW,CAAXA,KAAAA,CAAAA,SAAAA;QACAW,aAAa,CAAbA,QAAa,CAAbA;MACD;IACF;;IAED,SAAA,aAAA,GAAyB;MACvB,IAAI,OAAA,OAAA,KAAJ,UAAA,EAAmC;QACjCC,OAAO;MACR;;MAEDZ,WAAW,CAAXA,KAAAA,CAAAA,SAAAA;MACAW,aAAa,CAAbA,QAAa,CAAbA;IACD;EA1Ca,CAAA;EA4ChBE,GAAG,EAAE,SAAA,GAAA,CAAA,GAAA,EAAkB;IACrB,OAAO3B,aAAa,CAAbA,GAAAA,CAAP,GAAOA,CAAP;EA7Cc,CAAA;EA+ChB4B,IAAI,EAAE,SAAA,IAAA,CAAA,GAAA,EAAA,MAAA,EAAA,OAAA,EAAoC;IACxChB,EAAE,IAAFA,CAAAA;IACA,IAAII,KAAK,GAAG,IAAIa,MAAM,CAAtB,KAAY,EAAZ;IACAb,KAAK,CAALA,OAAAA,GAAAA,OAAAA;;IAEAA,KAAK,CAALA,MAAAA,GAAe,UAAA,CAAA,EAAa;MAC1B;MACA,IAAIc,QAAQ,GAAG,SAAA,QAAA,GAAoB;QACjC,OAAOC,MAAM,CAAC;UACZC,WAAW,EAAEC;QADD,CAAD,CAAb;MADF,CAAA;;MAMA,IAAI,OAAOjB,KAAK,CAAZ,MAAA,KAAJ,UAAA,EAAwC;QACtC;QACA;QACA;QACAA,KAAK,CAALA,MAAAA,GAAAA,IAAAA,CAAAA,QAAAA,EAAAA,QAAAA;MAJF,CAAA,MAKO;QACLkB,UAAU,CAAA,QAAA,EAAVA,CAAU,CAAVA;MACD;IAfHlB,CAAAA;;IAkBAA,KAAK,CAALA,GAAAA,GAAAA,GAAAA;IACAH,QAAQ,CAAC,KAATA,EAAQ,CAARA,GAAAA,KAAAA;IACA,OAAA,EAAA;EAxEc,CAAA;EA0EhBsB,QAAQ,EAAE,SAAA,QAAA,CAAA,GAAA,EAAuB;IAC/B,OAAO,IAAA,OAAA,CAAY,UAAA,OAAA,EAAA,MAAA,EAA2B;MAC5CrB,WAAW,CAAXA,IAAAA,CAAAA,GAAAA,EAAsB,YAAY;QAChC;QACA;QACAd,aAAa,CAAbA,GAAAA,CAAAA,GAAAA;QACAA,aAAa,CAAbA,MAAAA,CAAAA,GAAAA;QACAoC,OAAO;MALTtB,CAAAA,EAAAA,MAAAA;IADF,CAAO,CAAP;EA3Ec,CAAA;EAqFhBuB,UAAU,EAAE,SAAA,UAAA,CAAA,IAAA,EAA0B;IACpC,IAAIC,MAAM,GAAV,EAAA;IACAC,IAAI,CAAJA,OAAAA,CAAa,UAAA,CAAA,EAAa;MACxB,IAAIvC,aAAa,CAAbA,GAAAA,CAAJ,CAAIA,CAAJ,EAA0B;QACxBsC,MAAM,CAANA,CAAM,CAANA,GAAAA,aAAAA;MACD;IAHHC,CAAAA;IAKA,OAAOC,OAAO,CAAPA,OAAAA,CAAP,MAAOA,CAAP;EACD;AA7Fe,CAAlB;AA+FA,IAAIC,QAAQ,GAAZ,WAAA;AACA3C,OAAAA,WAAAA,GAAAA,QAAAA","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = exports.ImageUriCache = void 0;\n\n/**\n * Copyright (c) Nicolas Gallagher.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nvar dataUriPattern = /^data:/;\n\nvar ImageUriCache =\n/*#__PURE__*/\nfunction () {\n  function ImageUriCache() {}\n\n  ImageUriCache.has = function has(uri) {\n    var entries = ImageUriCache._entries;\n    var isDataUri = dataUriPattern.test(uri);\n    return isDataUri || Boolean(entries[uri]);\n  };\n\n  ImageUriCache.add = function add(uri) {\n    var entries = ImageUriCache._entries;\n    var lastUsedTimestamp = Date.now();\n\n    if (entries[uri]) {\n      entries[uri].lastUsedTimestamp = lastUsedTimestamp;\n      entries[uri].refCount += 1;\n    } else {\n      entries[uri] = {\n        lastUsedTimestamp: lastUsedTimestamp,\n        refCount: 1\n      };\n    }\n  };\n\n  ImageUriCache.remove = function remove(uri) {\n    var entries = ImageUriCache._entries;\n\n    if (entries[uri]) {\n      entries[uri].refCount -= 1;\n    } // Free up entries when the cache is \"full\"\n\n\n    ImageUriCache._cleanUpIfNeeded();\n  };\n\n  ImageUriCache._cleanUpIfNeeded = function _cleanUpIfNeeded() {\n    var entries = ImageUriCache._entries;\n    var imageUris = Object.keys(entries);\n\n    if (imageUris.length + 1 > ImageUriCache._maximumEntries) {\n      var leastRecentlyUsedKey;\n      var leastRecentlyUsedEntry;\n      imageUris.forEach(function (uri) {\n        var entry = entries[uri];\n\n        if ((!leastRecentlyUsedEntry || entry.lastUsedTimestamp < leastRecentlyUsedEntry.lastUsedTimestamp) && entry.refCount === 0) {\n          leastRecentlyUsedKey = uri;\n          leastRecentlyUsedEntry = entry;\n        }\n      });\n\n      if (leastRecentlyUsedKey) {\n        delete entries[leastRecentlyUsedKey];\n      }\n    }\n  };\n\n  return ImageUriCache;\n}();\n\nexports.ImageUriCache = ImageUriCache;\nImageUriCache._maximumEntries = 256;\nImageUriCache._entries = {};\nvar id = 0;\nvar requests = {};\nvar ImageLoader = {\n  abort: function abort(requestId) {\n    var image = requests[\"\" + requestId];\n\n    if (image) {\n      image.onerror = null;\n      image.onload = null;\n      image = null;\n      delete requests[\"\" + requestId];\n    }\n  },\n  getSize: function getSize(uri, success, failure) {\n    var complete = false;\n    var interval = setInterval(callback, 16);\n    var requestId = ImageLoader.load(uri, callback, errorCallback);\n\n    function callback() {\n      var image = requests[\"\" + requestId];\n\n      if (image) {\n        var naturalHeight = image.naturalHeight,\n            naturalWidth = image.naturalWidth;\n\n        if (naturalHeight && naturalWidth) {\n          success(naturalWidth, naturalHeight);\n          complete = true;\n        }\n      }\n\n      if (complete) {\n        ImageLoader.abort(requestId);\n        clearInterval(interval);\n      }\n    }\n\n    function errorCallback() {\n      if (typeof failure === 'function') {\n        failure();\n      }\n\n      ImageLoader.abort(requestId);\n      clearInterval(interval);\n    }\n  },\n  has: function has(uri) {\n    return ImageUriCache.has(uri);\n  },\n  load: function load(uri, onLoad, onError) {\n    id += 1;\n    var image = new window.Image();\n    image.onerror = onError;\n\n    image.onload = function (e) {\n      // avoid blocking the main thread\n      var onDecode = function onDecode() {\n        return onLoad({\n          nativeEvent: e\n        });\n      };\n\n      if (typeof image.decode === 'function') {\n        // Safari currently throws exceptions when decoding svgs.\n        // We want to catch that error and allow the load handler\n        // to be forwarded to the onLoad handler in this case\n        image.decode().then(onDecode, onDecode);\n      } else {\n        setTimeout(onDecode, 0);\n      }\n    };\n\n    image.src = uri;\n    requests[\"\" + id] = image;\n    return id;\n  },\n  prefetch: function prefetch(uri) {\n    return new Promise(function (resolve, reject) {\n      ImageLoader.load(uri, function () {\n        // Add the uri to the cache so it can be immediately displayed when used\n        // but also immediately remove it to correctly reflect that it has no active references\n        ImageUriCache.add(uri);\n        ImageUriCache.remove(uri);\n        resolve();\n      }, reject);\n    });\n  },\n  queryCache: function queryCache(uris) {\n    var result = {};\n    uris.forEach(function (u) {\n      if (ImageUriCache.has(u)) {\n        result[u] = 'disk/memory';\n      }\n    });\n    return Promise.resolve(result);\n  }\n};\nvar _default = ImageLoader;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}