{"ast":null,"code":"/**\n * Adapts focus styles based on the user's active input modality (i.e., how\n * they are interacting with the UI right now).\n *\n * Focus styles are only relevant when using the keyboard to interact with the\n * page. If we only show the focus ring when relevant, we can avoid user\n * confusion without compromising accessibility.\n *\n * The script uses two heuristics to determine whether the keyboard is being used:\n *\n * 1. a keydown event occurred immediately before a focus event;\n * 2. a focus event happened on an element which requires keyboard interaction (e.g., a text field);\n *\n * This software or document includes material copied from or derived from https://github.com/WICG/focus-visible.\n * Copyright © 2018 W3C® (MIT, ERCIM, Keio, Beihang).\n * W3C Software Notice and License: https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document\n *\n * \n */\nimport { canUseDOM } from 'fbjs/lib/ExecutionEnvironment';\nvar focusVisibleAttributeName = 'data-focusvisible-polyfill';\nvar rule = \":focus:not([\" + focusVisibleAttributeName + \"]){outline: none;}\";\n\nvar modality = function modality(insertRule) {\n  insertRule(rule);\n\n  if (!canUseDOM) {\n    return;\n  }\n\n  var hadKeyboardEvent = true;\n  var hadFocusVisibleRecently = false;\n  var hadFocusVisibleRecentlyTimeout = null;\n  var inputTypesWhitelist = {\n    text: true,\n    search: true,\n    url: true,\n    tel: true,\n    email: true,\n    password: true,\n    number: true,\n    date: true,\n    month: true,\n    week: true,\n    time: true,\n    datetime: true,\n    'datetime-local': true\n  };\n  /**\n   * Helper function for legacy browsers and iframes which sometimes focus\n   * elements like document, body, and non-interactive SVG.\n   */\n\n  function isValidFocusTarget(el) {\n    if (el && el !== document && el.nodeName !== 'HTML' && el.nodeName !== 'BODY' && 'classList' in el && 'contains' in el.classList) {\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Computes whether the given element should automatically trigger the\n   * `focus-visible` attribute being added, i.e. whether it should always match\n   * `:focus-visible` when focused.\n   */\n\n\n  function focusTriggersKeyboardModality(el) {\n    var type = el.type;\n    var tagName = el.tagName;\n    var isReadOnly = el.readOnly;\n\n    if (tagName === 'INPUT' && inputTypesWhitelist[type] && !isReadOnly) {\n      return true;\n    }\n\n    if (tagName === 'TEXTAREA' && !isReadOnly) {\n      return true;\n    }\n\n    if (el.isContentEditable) {\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Add the `focus-visible` attribute to the given element if it was not added by\n   * the author.\n   */\n\n\n  function addFocusVisibleAttribute(el) {\n    if (el.hasAttribute(focusVisibleAttributeName)) {\n      return;\n    }\n\n    el.setAttribute(focusVisibleAttributeName, true);\n  }\n  /**\n   * Remove the `focus-visible` attribute from the given element if it was not\n   * originally added by the author.\n   */\n\n\n  function removeFocusVisibleAttribute(el) {\n    el.removeAttribute(focusVisibleAttributeName);\n  }\n  /**\n   * Remove the `focus-visible` attribute from all elements in the document.\n   */\n\n\n  function removeAllFocusVisibleAttributes() {\n    var list = document.querySelectorAll(\"[\" + focusVisibleAttributeName + \"]\");\n\n    for (var i = 0; i < list.length; i += 1) {\n      removeFocusVisibleAttribute(list[i]);\n    }\n  }\n  /**\n   * Treat `keydown` as a signal that the user is in keyboard modality.\n   * Apply `focus-visible` to any current active element and keep track\n   * of our keyboard modality state with `hadKeyboardEvent`.\n   */\n\n\n  function onKeyDown(e) {\n    if (e.key !== 'Tab' && (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)) {\n      return;\n    }\n\n    if (isValidFocusTarget(document.activeElement)) {\n      addFocusVisibleAttribute(document.activeElement);\n    }\n\n    hadKeyboardEvent = true;\n  }\n  /**\n   * If at any point a user clicks with a pointing device, ensure that we change\n   * the modality away from keyboard.\n   * This avoids the situation where a user presses a key on an already focused\n   * element, and then clicks on a different element, focusing it with a\n   * pointing device, while we still think we're in keyboard modality.\n   * It also avoids the situation where a user presses on an element within a\n   * previously keyboard-focused element (i.e., `e.target` is not the previously\n   * focused element, but one of its descendants) and we need to remove the\n   * focus ring because a `blur` event doesn't occur.\n   */\n\n\n  function onPointerDown(e) {\n    if (hadKeyboardEvent === true) {\n      removeAllFocusVisibleAttributes();\n    }\n\n    hadKeyboardEvent = false;\n  }\n  /**\n   * On `focus`, add the `focus-visible` attribute to the target if:\n   * - the target received focus as a result of keyboard navigation, or\n   * - the event target is an element that will likely require interaction\n   *   via the keyboard (e.g. a text box)\n   */\n\n\n  function onFocus(e) {\n    // Prevent IE from focusing the document or HTML element.\n    if (!isValidFocusTarget(e.target)) {\n      return;\n    }\n\n    if (hadKeyboardEvent || focusTriggersKeyboardModality(e.target)) {\n      addFocusVisibleAttribute(e.target);\n    }\n  }\n  /**\n   * On `blur`, remove the `focus-visible` attribute from the target.\n   */\n\n\n  function onBlur(e) {\n    if (!isValidFocusTarget(e.target)) {\n      return;\n    }\n\n    if (e.target.hasAttribute(focusVisibleAttributeName)) {\n      // To detect a tab/window switch, we look for a blur event followed\n      // rapidly by a visibility change.\n      // If we don't see a visibility change within 100ms, it's probably a\n      // regular focus change.\n      hadFocusVisibleRecently = true;\n      window.clearTimeout(hadFocusVisibleRecentlyTimeout);\n      hadFocusVisibleRecentlyTimeout = window.setTimeout(function () {\n        hadFocusVisibleRecently = false;\n        window.clearTimeout(hadFocusVisibleRecentlyTimeout);\n      }, 100);\n      removeFocusVisibleAttribute(e.target);\n    }\n  }\n  /**\n   * If the user changes tabs, keep track of whether or not the previously\n   * focused element had the focus-visible attribute.\n   */\n\n\n  function onVisibilityChange(e) {\n    if (document.visibilityState === 'hidden') {\n      // If the tab becomes active again, the browser will handle calling focus\n      // on the element (Safari actually calls it twice).\n      // If this tab change caused a blur on an element with focus-visible,\n      // re-apply the attribute when the user switches back to the tab.\n      if (hadFocusVisibleRecently) {\n        hadKeyboardEvent = true;\n      }\n\n      addInitialPointerMoveListeners();\n    }\n  }\n  /**\n   * Add a group of listeners to detect usage of any pointing devices.\n   * These listeners will be added when the polyfill first loads, and anytime\n   * the window is blurred, so that they are active when the window regains\n   * focus.\n   */\n\n\n  function addInitialPointerMoveListeners() {\n    document.addEventListener('mousemove', onInitialPointerMove);\n    document.addEventListener('mousedown', onInitialPointerMove);\n    document.addEventListener('mouseup', onInitialPointerMove);\n    document.addEventListener('pointermove', onInitialPointerMove);\n    document.addEventListener('pointerdown', onInitialPointerMove);\n    document.addEventListener('pointerup', onInitialPointerMove);\n    document.addEventListener('touchmove', onInitialPointerMove);\n    document.addEventListener('touchstart', onInitialPointerMove);\n    document.addEventListener('touchend', onInitialPointerMove);\n  }\n\n  function removeInitialPointerMoveListeners() {\n    document.removeEventListener('mousemove', onInitialPointerMove);\n    document.removeEventListener('mousedown', onInitialPointerMove);\n    document.removeEventListener('mouseup', onInitialPointerMove);\n    document.removeEventListener('pointermove', onInitialPointerMove);\n    document.removeEventListener('pointerdown', onInitialPointerMove);\n    document.removeEventListener('pointerup', onInitialPointerMove);\n    document.removeEventListener('touchmove', onInitialPointerMove);\n    document.removeEventListener('touchstart', onInitialPointerMove);\n    document.removeEventListener('touchend', onInitialPointerMove);\n  }\n  /**\n   * When the polfyill first loads, assume the user is in keyboard modality.\n   * If any event is received from a pointing device (e.g. mouse, pointer,\n   * touch), turn off keyboard modality.\n   * This accounts for situations where focus enters the page from the URL bar.\n   */\n\n\n  function onInitialPointerMove(e) {\n    // Work around a Safari quirk that fires a mousemove on <html> whenever the\n    // window blurs, even if you're tabbing out of the page. ¯\\_(ツ)_/¯\n    if (e.target.nodeName === 'HTML') {\n      return;\n    }\n\n    hadKeyboardEvent = false;\n    removeInitialPointerMoveListeners();\n  }\n\n  document.addEventListener('keydown', onKeyDown, true);\n  document.addEventListener('mousedown', onPointerDown, true);\n  document.addEventListener('pointerdown', onPointerDown, true);\n  document.addEventListener('touchstart', onPointerDown, true);\n  document.addEventListener('focus', onFocus, true);\n  document.addEventListener('blur', onBlur, true);\n  document.addEventListener('visibilitychange', onVisibilityChange, true);\n  addInitialPointerMoveListeners();\n};\n\nexport default modality;","map":{"version":3,"sources":["/Users/jun/Desktop/dev/react-practice/with-react-native-web-app/node_modules/react-native-web/dist/exports/StyleSheet/modality.js"],"names":["focusVisibleAttributeName","rule","modality","insertRule","hadKeyboardEvent","hadFocusVisibleRecently","hadFocusVisibleRecentlyTimeout","inputTypesWhitelist","text","search","url","tel","email","password","number","date","month","week","time","datetime","el","type","tagName","isReadOnly","list","document","i","removeFocusVisibleAttribute","e","isValidFocusTarget","addFocusVisibleAttribute","removeAllFocusVisibleAttributes","focusTriggersKeyboardModality","window","addInitialPointerMoveListeners","removeInitialPointerMoveListeners"],"mappings":"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","sourcesContent":["/**\n * Adapts focus styles based on the user's active input modality (i.e., how\n * they are interacting with the UI right now).\n *\n * Focus styles are only relevant when using the keyboard to interact with the\n * page. If we only show the focus ring when relevant, we can avoid user\n * confusion without compromising accessibility.\n *\n * The script uses two heuristics to determine whether the keyboard is being used:\n *\n * 1. a keydown event occurred immediately before a focus event;\n * 2. a focus event happened on an element which requires keyboard interaction (e.g., a text field);\n *\n * This software or document includes material copied from or derived from https://github.com/WICG/focus-visible.\n * Copyright © 2018 W3C® (MIT, ERCIM, Keio, Beihang).\n * W3C Software Notice and License: https://www.w3.org/Consortium/Legal/2015/copyright-software-and-document\n *\n * \n */\nimport { canUseDOM } from 'fbjs/lib/ExecutionEnvironment';\nvar focusVisibleAttributeName = 'data-focusvisible-polyfill';\nvar rule = \":focus:not([\" + focusVisibleAttributeName + \"]){outline: none;}\";\n\nvar modality = function modality(insertRule) {\n  insertRule(rule);\n\n  if (!canUseDOM) {\n    return;\n  }\n\n  var hadKeyboardEvent = true;\n  var hadFocusVisibleRecently = false;\n  var hadFocusVisibleRecentlyTimeout = null;\n  var inputTypesWhitelist = {\n    text: true,\n    search: true,\n    url: true,\n    tel: true,\n    email: true,\n    password: true,\n    number: true,\n    date: true,\n    month: true,\n    week: true,\n    time: true,\n    datetime: true,\n    'datetime-local': true\n  };\n  /**\n   * Helper function for legacy browsers and iframes which sometimes focus\n   * elements like document, body, and non-interactive SVG.\n   */\n\n  function isValidFocusTarget(el) {\n    if (el && el !== document && el.nodeName !== 'HTML' && el.nodeName !== 'BODY' && 'classList' in el && 'contains' in el.classList) {\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Computes whether the given element should automatically trigger the\n   * `focus-visible` attribute being added, i.e. whether it should always match\n   * `:focus-visible` when focused.\n   */\n\n\n  function focusTriggersKeyboardModality(el) {\n    var type = el.type;\n    var tagName = el.tagName;\n    var isReadOnly = el.readOnly;\n\n    if (tagName === 'INPUT' && inputTypesWhitelist[type] && !isReadOnly) {\n      return true;\n    }\n\n    if (tagName === 'TEXTAREA' && !isReadOnly) {\n      return true;\n    }\n\n    if (el.isContentEditable) {\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * Add the `focus-visible` attribute to the given element if it was not added by\n   * the author.\n   */\n\n\n  function addFocusVisibleAttribute(el) {\n    if (el.hasAttribute(focusVisibleAttributeName)) {\n      return;\n    }\n\n    el.setAttribute(focusVisibleAttributeName, true);\n  }\n  /**\n   * Remove the `focus-visible` attribute from the given element if it was not\n   * originally added by the author.\n   */\n\n\n  function removeFocusVisibleAttribute(el) {\n    el.removeAttribute(focusVisibleAttributeName);\n  }\n  /**\n   * Remove the `focus-visible` attribute from all elements in the document.\n   */\n\n\n  function removeAllFocusVisibleAttributes() {\n    var list = document.querySelectorAll(\"[\" + focusVisibleAttributeName + \"]\");\n\n    for (var i = 0; i < list.length; i += 1) {\n      removeFocusVisibleAttribute(list[i]);\n    }\n  }\n  /**\n   * Treat `keydown` as a signal that the user is in keyboard modality.\n   * Apply `focus-visible` to any current active element and keep track\n   * of our keyboard modality state with `hadKeyboardEvent`.\n   */\n\n\n  function onKeyDown(e) {\n    if (e.key !== 'Tab' && (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey)) {\n      return;\n    }\n\n    if (isValidFocusTarget(document.activeElement)) {\n      addFocusVisibleAttribute(document.activeElement);\n    }\n\n    hadKeyboardEvent = true;\n  }\n  /**\n   * If at any point a user clicks with a pointing device, ensure that we change\n   * the modality away from keyboard.\n   * This avoids the situation where a user presses a key on an already focused\n   * element, and then clicks on a different element, focusing it with a\n   * pointing device, while we still think we're in keyboard modality.\n   * It also avoids the situation where a user presses on an element within a\n   * previously keyboard-focused element (i.e., `e.target` is not the previously\n   * focused element, but one of its descendants) and we need to remove the\n   * focus ring because a `blur` event doesn't occur.\n   */\n\n\n  function onPointerDown(e) {\n    if (hadKeyboardEvent === true) {\n      removeAllFocusVisibleAttributes();\n    }\n\n    hadKeyboardEvent = false;\n  }\n  /**\n   * On `focus`, add the `focus-visible` attribute to the target if:\n   * - the target received focus as a result of keyboard navigation, or\n   * - the event target is an element that will likely require interaction\n   *   via the keyboard (e.g. a text box)\n   */\n\n\n  function onFocus(e) {\n    // Prevent IE from focusing the document or HTML element.\n    if (!isValidFocusTarget(e.target)) {\n      return;\n    }\n\n    if (hadKeyboardEvent || focusTriggersKeyboardModality(e.target)) {\n      addFocusVisibleAttribute(e.target);\n    }\n  }\n  /**\n   * On `blur`, remove the `focus-visible` attribute from the target.\n   */\n\n\n  function onBlur(e) {\n    if (!isValidFocusTarget(e.target)) {\n      return;\n    }\n\n    if (e.target.hasAttribute(focusVisibleAttributeName)) {\n      // To detect a tab/window switch, we look for a blur event followed\n      // rapidly by a visibility change.\n      // If we don't see a visibility change within 100ms, it's probably a\n      // regular focus change.\n      hadFocusVisibleRecently = true;\n      window.clearTimeout(hadFocusVisibleRecentlyTimeout);\n      hadFocusVisibleRecentlyTimeout = window.setTimeout(function () {\n        hadFocusVisibleRecently = false;\n        window.clearTimeout(hadFocusVisibleRecentlyTimeout);\n      }, 100);\n      removeFocusVisibleAttribute(e.target);\n    }\n  }\n  /**\n   * If the user changes tabs, keep track of whether or not the previously\n   * focused element had the focus-visible attribute.\n   */\n\n\n  function onVisibilityChange(e) {\n    if (document.visibilityState === 'hidden') {\n      // If the tab becomes active again, the browser will handle calling focus\n      // on the element (Safari actually calls it twice).\n      // If this tab change caused a blur on an element with focus-visible,\n      // re-apply the attribute when the user switches back to the tab.\n      if (hadFocusVisibleRecently) {\n        hadKeyboardEvent = true;\n      }\n\n      addInitialPointerMoveListeners();\n    }\n  }\n  /**\n   * Add a group of listeners to detect usage of any pointing devices.\n   * These listeners will be added when the polyfill first loads, and anytime\n   * the window is blurred, so that they are active when the window regains\n   * focus.\n   */\n\n\n  function addInitialPointerMoveListeners() {\n    document.addEventListener('mousemove', onInitialPointerMove);\n    document.addEventListener('mousedown', onInitialPointerMove);\n    document.addEventListener('mouseup', onInitialPointerMove);\n    document.addEventListener('pointermove', onInitialPointerMove);\n    document.addEventListener('pointerdown', onInitialPointerMove);\n    document.addEventListener('pointerup', onInitialPointerMove);\n    document.addEventListener('touchmove', onInitialPointerMove);\n    document.addEventListener('touchstart', onInitialPointerMove);\n    document.addEventListener('touchend', onInitialPointerMove);\n  }\n\n  function removeInitialPointerMoveListeners() {\n    document.removeEventListener('mousemove', onInitialPointerMove);\n    document.removeEventListener('mousedown', onInitialPointerMove);\n    document.removeEventListener('mouseup', onInitialPointerMove);\n    document.removeEventListener('pointermove', onInitialPointerMove);\n    document.removeEventListener('pointerdown', onInitialPointerMove);\n    document.removeEventListener('pointerup', onInitialPointerMove);\n    document.removeEventListener('touchmove', onInitialPointerMove);\n    document.removeEventListener('touchstart', onInitialPointerMove);\n    document.removeEventListener('touchend', onInitialPointerMove);\n  }\n  /**\n   * When the polfyill first loads, assume the user is in keyboard modality.\n   * If any event is received from a pointing device (e.g. mouse, pointer,\n   * touch), turn off keyboard modality.\n   * This accounts for situations where focus enters the page from the URL bar.\n   */\n\n\n  function onInitialPointerMove(e) {\n    // Work around a Safari quirk that fires a mousemove on <html> whenever the\n    // window blurs, even if you're tabbing out of the page. ¯\\_(ツ)_/¯\n    if (e.target.nodeName === 'HTML') {\n      return;\n    }\n\n    hadKeyboardEvent = false;\n    removeInitialPointerMoveListeners();\n  }\n\n  document.addEventListener('keydown', onKeyDown, true);\n  document.addEventListener('mousedown', onPointerDown, true);\n  document.addEventListener('pointerdown', onPointerDown, true);\n  document.addEventListener('touchstart', onPointerDown, true);\n  document.addEventListener('focus', onFocus, true);\n  document.addEventListener('blur', onBlur, true);\n  document.addEventListener('visibilitychange', onVisibilityChange, true);\n  addInitialPointerMoveListeners();\n};\n\nexport default modality;"]},"metadata":{},"sourceType":"module"}