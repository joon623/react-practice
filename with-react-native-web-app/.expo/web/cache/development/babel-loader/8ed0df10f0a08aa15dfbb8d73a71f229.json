{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.attachListeners = attachListeners;\nexports.addNode = addNode;\nexports.removeNode = removeNode;\nexports.terminateResponder = terminateResponder;\nexports.getResponderNode = getResponderNode;\n\nvar _ExecutionEnvironment = require(\"fbjs/lib/ExecutionEnvironment\");\n\nvar _createResponderEvent = _interopRequireDefault(require(\"./createResponderEvent\"));\n\nvar _ResponderEventTypes = require(\"./ResponderEventTypes\");\n\nvar _utils = require(\"./utils\");\n\nvar _ResponderTouchHistoryStore = _interopRequireDefault(require(\"./ResponderTouchHistoryStore\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n/**\n * Copyright (c) Nicolas Gallagher\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/**\n * RESPONDER EVENT SYSTEM\n *\n * A single, global \"interaction lock\" on views. For a view to be the \"responder\" means\n * that pointer interactions are exclusive to that view and none other. The \"interaction\n * lock\" can be transferred (only) to ancestors of the current \"responder\" as long as\n * pointers continue to be active.\n *\n * Responder being granted:\n *\n * A view can become the \"responder\" after the following events:\n *  * \"pointerdown\" (implemented using \"touchstart\", \"mousedown\")\n *  * \"pointermove\" (implemented using \"touchmove\", \"mousemove\")\n *  * \"scroll\" (while a pointer is down)\n *  * \"selectionchange\" (while a pointer is down)\n *\n * If nothing is already the \"responder\", the event propagates to (capture) and from\n * (bubble) the event target until a view returns `true` for\n * `on*ShouldSetResponder(Capture)`.\n *\n * If something is already the responder, the event propagates to (capture) and from\n * (bubble) the lowest common ancestor of the event target and the current \"responder\".\n * Then negotiation happens between the current \"responder\" and a view that wants to\n * become the \"responder\": see the timing diagram below.\n *\n * (NOTE: Scrolled views either automatically become the \"responder\" or release the\n * \"interaction lock\". A native scroll view that isn't built on top of the responder\n * system must result in the current \"responder\" being notified that it no longer has\n * the \"interaction lock\" - the native system has taken over.\n *\n * Responder being released:\n *\n * As soon as there are no more active pointers that *started* inside descendants\n * of the *current* \"responder\", an `onResponderRelease` event is dispatched to the\n * current \"responder\", and the responder lock is released.\n *\n * Typical sequence of events:\n *  * startShouldSetResponder\n *  * responderGrant/Reject\n *  * responderStart\n *  * responderMove\n *  * responderEnd\n *  * responderRelease\n */\n\n/*                                             Negotiation Performed\n                                             +-----------------------+\n                                            /                         \\\nProcess low level events to    +     Current Responder      +   wantsResponderID\ndetermine who to perform negot-|   (if any exists at all)   |\niation/transition              | Otherwise just pass through|\n-------------------------------+----------------------------+------------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +--------------+          |                            |\n     | onTouchStart |          |                            |\n     +------+-------+    none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onStartShouldSetResponder|----->| onResponderStart (cur) |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | | onResponder            | |\n            +------------------->|    TerminationRequest  | |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | | onResponderTerminate   |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderStart|\n                               |                            | +----------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchMove |           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onMoveShouldSetResponder |----->| onResponderMove (cur)  |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderMove |\n                               |                            | +----------------+\n                               |                            |\n                               |                            |\n      Some active touch started|                            |\n      inside current responder | +------------------------+ |\n      +------------------------->|      onResponderEnd    | |\n      |                        | +------------------------+ |\n  +---+---------+              |                            |\n  | onTouchEnd  |              |                            |\n  +---+---------+              |                            |\n      |                        | +------------------------+ |\n      +------------------------->|     onResponderEnd     | |\n      No active touches started| +-----------+------------+ |\n      inside current responder |             |              |\n                               |             v              |\n                               | +------------------------+ |\n                               | |    onResponderRelease  | |\n                               | +------------------------+ |\n                               |                            |\n                               +                            + */\n\n\nvar emptyObject = {};\n/* ------------ IMPLEMENTATION ------------ */\n\nvar startRegistration = ['onStartShouldSetResponderCapture', 'onStartShouldSetResponder', {\n  bubbles: true\n}];\nvar moveRegistration = ['onMoveShouldSetResponderCapture', 'onMoveShouldSetResponder', {\n  bubbles: true\n}];\nvar scrollRegistration = ['onScrollShouldSetResponderCapture', 'onScrollShouldSetResponder', {\n  bubbles: false\n}];\nvar shouldSetResponderEvents = {\n  touchstart: startRegistration,\n  mousedown: startRegistration,\n  touchmove: moveRegistration,\n  mousemove: moveRegistration,\n  scroll: scrollRegistration\n};\nvar emptyResponder = {\n  id: null,\n  idPath: null,\n  node: null\n};\nvar responderListenersMap = new Map();\nvar isEmulatingMouseEvents = false;\nvar trackedTouchCount = 0;\nvar currentResponder = {\n  id: null,\n  node: null,\n  idPath: null\n};\n\nfunction changeCurrentResponder(responder) {\n  currentResponder = responder;\n}\n\nfunction getResponderConfig(id) {\n  var config = responderListenersMap.get(id);\n  return config != null ? config : emptyObject;\n}\n/**\n * Process native events\n *\n * A single event listener is used to manage the responder system.\n * All pointers are tracked in the ResponderTouchHistoryStore. Native events\n * are interpreted in terms of the Responder System and checked to see if\n * the responder should be transferred. Each host node that is attached to\n * the Responder System has an ID, which is used to look up its associated\n * callbacks.\n */\n\n\nfunction eventListener(domEvent) {\n  var eventType = domEvent.type;\n  var eventTarget = domEvent.target;\n  /**\n   * Manage emulated events and early bailout.\n   * Since PointerEvent is not used yet (lack of support in older Safari), it's\n   * necessary to manually manage the mess of browser touch/mouse events.\n   * And bailout early for termination events when there is no active responder.\n   */\n  // Flag when browser may produce emulated events\n\n  if (eventType === 'touchstart') {\n    isEmulatingMouseEvents = true;\n  } // Remove flag when browser will not produce emulated events\n\n\n  if (eventType === 'touchmove' || trackedTouchCount > 1) {\n    isEmulatingMouseEvents = false;\n  } // Ignore various events in particular circumstances\n\n\n  if ( // Ignore browser emulated mouse events\n  eventType === 'mousedown' && isEmulatingMouseEvents || eventType === 'mousemove' && isEmulatingMouseEvents || // Ignore mousemove if a mousedown didn't occur first\n  eventType === 'mousemove' && trackedTouchCount < 1) {\n    return;\n  } // Remove flag after emulated events are finished\n\n\n  if (isEmulatingMouseEvents && eventType === 'mouseup') {\n    if (trackedTouchCount === 0) {\n      isEmulatingMouseEvents = false;\n    }\n\n    return;\n  }\n\n  var isStartEvent = (0, _ResponderEventTypes.isStartish)(eventType) && (0, _utils.isPrimaryPointerDown)(domEvent);\n  var isMoveEvent = (0, _ResponderEventTypes.isMoveish)(eventType);\n  var isEndEvent = (0, _ResponderEventTypes.isEndish)(eventType);\n  var isScrollEvent = (0, _ResponderEventTypes.isScroll)(eventType);\n  var isSelectionChangeEvent = (0, _ResponderEventTypes.isSelectionChange)(eventType);\n  var responderEvent = (0, _createResponderEvent[\"default\"])(domEvent);\n  /**\n   * Record the state of active pointers\n   */\n\n  if (isStartEvent || isMoveEvent || isEndEvent) {\n    if (domEvent.touches) {\n      trackedTouchCount = domEvent.touches.length;\n    } else {\n      if (isStartEvent) {\n        trackedTouchCount = 1;\n      } else if (isEndEvent) {\n        trackedTouchCount = 0;\n      }\n    }\n\n    _ResponderTouchHistoryStore[\"default\"].recordTouchTrack(eventType, responderEvent.nativeEvent);\n  }\n  /**\n   * Responder System logic\n   */\n\n\n  var eventPaths = (0, _utils.getResponderPaths)(domEvent);\n  var wasNegotiated = false;\n  var wantsResponder; // If an event occured that might change the current responder...\n\n  if (isStartEvent || isMoveEvent || isScrollEvent && trackedTouchCount > 0) {\n    // If there is already a responder, prune the event paths to the lowest common ancestor\n    // of the existing responder and deepest target of the event.\n    var currentResponderIdPath = currentResponder.idPath;\n    var eventIdPath = eventPaths.idPath;\n\n    if (currentResponderIdPath != null && eventIdPath != null) {\n      var lowestCommonAncestor = (0, _utils.getLowestCommonAncestor)(currentResponderIdPath, eventIdPath);\n\n      if (lowestCommonAncestor != null) {\n        var indexOfLowestCommonAncestor = eventIdPath.indexOf(lowestCommonAncestor); // Skip the current responder so it doesn't receive unexpected \"shouldSet\" events.\n\n        var index = indexOfLowestCommonAncestor + (lowestCommonAncestor === currentResponder.id ? 1 : 0);\n        eventPaths = {\n          idPath: eventIdPath.slice(index),\n          nodePath: eventPaths.nodePath.slice(index)\n        };\n      } else {\n        eventPaths = null;\n      }\n    }\n\n    if (eventPaths != null) {\n      // If a node wants to become the responder, attempt to transfer.\n      wantsResponder = findWantsResponder(eventPaths, domEvent, responderEvent);\n\n      if (wantsResponder != null) {\n        // Sets responder if none exists, or negotates with existing responder.\n        attemptTransfer(responderEvent, wantsResponder);\n        wasNegotiated = true;\n      }\n    }\n  } // If there is now a responder, invoke its callbacks for the lifecycle of the gesture.\n\n\n  if (currentResponder.id != null && currentResponder.node != null) {\n    var _currentResponder = currentResponder,\n        id = _currentResponder.id,\n        node = _currentResponder.node;\n\n    var _getResponderConfig = getResponderConfig(id),\n        onResponderStart = _getResponderConfig.onResponderStart,\n        onResponderMove = _getResponderConfig.onResponderMove,\n        onResponderEnd = _getResponderConfig.onResponderEnd,\n        onResponderRelease = _getResponderConfig.onResponderRelease,\n        onResponderTerminate = _getResponderConfig.onResponderTerminate,\n        onResponderTerminationRequest = _getResponderConfig.onResponderTerminationRequest;\n\n    responderEvent.bubbles = false;\n    responderEvent.cancelable = false;\n    responderEvent.currentTarget = node; // Start\n\n    if (isStartEvent) {\n      if (onResponderStart != null) {\n        onResponderStart(responderEvent);\n      }\n    } // Move\n    else if (isMoveEvent) {\n      if (onResponderMove != null) {\n        onResponderMove(responderEvent);\n      }\n    } else {\n      var isTerminateEvent = (0, _ResponderEventTypes.isCancelish)(eventType) || // native context menu\n      eventType === 'contextmenu' || // window blur\n      eventType === 'blur' && eventTarget === window || // responder (or ancestors) blur\n      eventType === 'blur' && eventTarget.contains(node) && domEvent.relatedTarget !== node || // native scroll without using a pointer\n      isScrollEvent && trackedTouchCount === 0 || // native scroll on node that is parent of the responder (allow siblings to scroll)\n      isScrollEvent && eventTarget.contains(node) && eventTarget !== node || // native select/selectionchange on node\n      isSelectionChangeEvent && (0, _utils.hasValidSelection)(domEvent);\n      var isReleaseEvent = isEndEvent && !isTerminateEvent && !(0, _utils.hasTargetTouches)(node, domEvent.touches); // End\n\n      if (isEndEvent) {\n        if (onResponderEnd != null) {\n          onResponderEnd(responderEvent);\n        }\n      } // Release\n\n\n      if (isReleaseEvent) {\n        if (onResponderRelease != null) {\n          onResponderRelease(responderEvent);\n        }\n\n        changeCurrentResponder(emptyResponder);\n      } // Terminate\n\n\n      if (isTerminateEvent) {\n        var shouldTerminate = true; // Responders can still avoid termination but only for these events.\n\n        if (eventType === 'contextmenu' || eventType === 'scroll' || eventType === 'selectionchange') {\n          if (wasNegotiated || // Only call this function is it wasn't already called during negotiation.\n          onResponderTerminationRequest != null && onResponderTerminationRequest(responderEvent) === false) {\n            shouldTerminate = false;\n          }\n        }\n\n        if (shouldTerminate) {\n          if (onResponderTerminate != null) {\n            onResponderTerminate(responderEvent);\n          }\n\n          changeCurrentResponder(emptyResponder);\n          isEmulatingMouseEvents = false;\n          trackedTouchCount = 0;\n        }\n      }\n    }\n  }\n}\n/**\n * Walk the event path to/from the target node. At each node, stop and call the\n * relevant \"shouldSet\" functions for the given event type. If any of those functions\n * call \"stopPropagation\" on the event, stop searching for a responder.\n */\n\n\nfunction findWantsResponder(eventPaths, domEvent, responderEvent) {\n  var shouldSetCallbacks = shouldSetResponderEvents[domEvent.type]; // for Flow\n\n  if (shouldSetCallbacks != null) {\n    var idPath = eventPaths.idPath,\n        nodePath = eventPaths.nodePath;\n    var shouldSetCallbackCaptureName = shouldSetCallbacks[0];\n    var shouldSetCallbackBubbleName = shouldSetCallbacks[1];\n    var bubbles = shouldSetCallbacks[2].bubbles;\n\n    var check = function check(id, node, callbackName) {\n      var config = getResponderConfig(id);\n      var shouldSetCallback = config[callbackName];\n\n      if (shouldSetCallback != null) {\n        if (shouldSetCallback(responderEvent) === true) {\n          return {\n            id: id,\n            node: node,\n            idPath: idPath\n          };\n        }\n      }\n    }; // capture\n\n\n    for (var i = idPath.length - 1; i >= 0; i--) {\n      var id = idPath[i];\n      var node = nodePath[i];\n      var result = check(id, node, shouldSetCallbackCaptureName);\n\n      if (result != null) {\n        return result;\n      }\n\n      if (responderEvent.isPropagationStopped() === true) {\n        return;\n      }\n    } // bubble\n\n\n    if (bubbles) {\n      for (var _i = 0; _i < idPath.length; _i++) {\n        var _id = idPath[_i];\n        var _node = nodePath[_i];\n\n        var _result = check(_id, _node, shouldSetCallbackBubbleName);\n\n        if (_result != null) {\n          return _result;\n        }\n\n        if (responderEvent.isPropagationStopped() === true) {\n          return;\n        }\n      }\n    } else {\n      var _id2 = idPath[0];\n      var _node2 = nodePath[0];\n      var target = domEvent.target;\n\n      if (target === _node2) {\n        return check(_id2, _node2, shouldSetCallbackBubbleName);\n      }\n    }\n  }\n}\n/**\n * Attempt to transfer the responder.\n */\n\n\nfunction attemptTransfer(responderEvent, wantsResponder) {\n  var _currentResponder2 = currentResponder,\n      currentId = _currentResponder2.id,\n      currentNode = _currentResponder2.node;\n  var id = wantsResponder.id,\n      node = wantsResponder.node;\n\n  var _getResponderConfig2 = getResponderConfig(id),\n      onResponderGrant = _getResponderConfig2.onResponderGrant,\n      onResponderReject = _getResponderConfig2.onResponderReject;\n\n  responderEvent.bubbles = false;\n  responderEvent.cancelable = false;\n  responderEvent.currentTarget = node; // Set responder\n\n  if (currentId == null) {\n    if (onResponderGrant != null) {\n      responderEvent.currentTarget = node;\n      responderEvent.dispatchConfig.registrationName = 'onResponderGrant';\n      onResponderGrant(responderEvent);\n    }\n\n    changeCurrentResponder(wantsResponder);\n  } // Negotiate with current responder\n  else {\n    var _getResponderConfig3 = getResponderConfig(currentId),\n        onResponderTerminate = _getResponderConfig3.onResponderTerminate,\n        onResponderTerminationRequest = _getResponderConfig3.onResponderTerminationRequest;\n\n    var allowTransfer = onResponderTerminationRequest != null && onResponderTerminationRequest(responderEvent);\n\n    if (allowTransfer) {\n      // Terminate existing responder\n      if (onResponderTerminate != null) {\n        responderEvent.currentTarget = currentNode;\n        onResponderTerminate(responderEvent);\n      } // Grant next responder\n\n\n      if (onResponderGrant != null) {\n        onResponderGrant(responderEvent);\n      }\n\n      changeCurrentResponder(wantsResponder);\n    } else {\n      // Reject responder request\n      if (onResponderReject != null) {\n        onResponderReject(responderEvent);\n      }\n    }\n  }\n}\n/* ------------ PUBLIC API ------------ */\n\n/**\n * Attach Listeners\n *\n * Use native events as ReactDOM doesn't have a non-plugin API to implement\n * this system.\n */\n\n\nvar documentEventsCapturePhase = ['blur', 'scroll'];\nvar documentEventsBubblePhase = [// mouse\n'mousedown', 'mousemove', 'mouseup', 'dragstart', // touch\n'touchstart', 'touchmove', 'touchend', 'touchcancel', // other\n'contextmenu', 'select', 'selectionchange'];\n\nfunction attachListeners() {\n  if (_ExecutionEnvironment.canUseDOM && window.__reactResponderSystemActive == null) {\n    window.addEventListener('blur', eventListener);\n    documentEventsBubblePhase.forEach(function (eventType) {\n      document.addEventListener(eventType, eventListener);\n    });\n    documentEventsCapturePhase.forEach(function (eventType) {\n      document.addEventListener(eventType, eventListener, true);\n    });\n    window.__reactResponderSystemActive = true;\n  }\n}\n/**\n * Register a node with the ResponderSystem.\n */\n\n\nfunction addNode(id, node, config) {\n  (0, _utils.setResponderId)(node, id);\n  responderListenersMap.set(id, config);\n}\n/**\n * Unregister a node with the ResponderSystem.\n */\n\n\nfunction removeNode(id) {\n  if (currentResponder.id === id) {\n    terminateResponder();\n  }\n\n  if (responderListenersMap.has(id)) {\n    responderListenersMap[\"delete\"](id);\n  }\n}\n/**\n * Allow the current responder to be terminated from within components to support\n * more complex requirements, such as use with other React libraries for working\n * with scroll views, input views, etc.\n */\n\n\nfunction terminateResponder() {\n  var _currentResponder3 = currentResponder,\n      id = _currentResponder3.id,\n      node = _currentResponder3.node;\n\n  if (id != null && node != null) {\n    var _getResponderConfig4 = getResponderConfig(id),\n        onResponderTerminate = _getResponderConfig4.onResponderTerminate;\n\n    if (onResponderTerminate != null) {\n      var event = (0, _createResponderEvent[\"default\"])({});\n      event.currentTarget = node;\n      onResponderTerminate(event);\n    }\n\n    changeCurrentResponder(emptyResponder);\n  }\n\n  isEmulatingMouseEvents = false;\n  trackedTouchCount = 0;\n}\n/**\n * Allow unit tests to inspect the current responder in the system.\n * FOR TESTING ONLY.\n */\n\n\nfunction getResponderNode() {\n  return currentResponder.node;\n}\n\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = __webpack_module__.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      __webpack_module__.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      import.meta.webpackHot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          __webpack_module__.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        __webpack_module__.hot.invalidate();\n      }\n    }\n  }\n})();","map":{"version":3,"sources":["/Users/jun/Desktop/dev/react-practice/with-react-native-web-app/node_modules/react-native-web/dist/cjs/hooks/useResponderEvents/ResponderSystem.js"],"names":["exports","_ExecutionEnvironment","require","_createResponderEvent","_interopRequireDefault","_ResponderEventTypes","_utils","_ResponderTouchHistoryStore","obj","emptyObject","startRegistration","bubbles","moveRegistration","scrollRegistration","shouldSetResponderEvents","touchstart","mousedown","touchmove","mousemove","scroll","emptyResponder","id","idPath","node","responderListenersMap","isEmulatingMouseEvents","trackedTouchCount","currentResponder","config","eventType","domEvent","eventTarget","isStartEvent","isMoveEvent","isEndEvent","isScrollEvent","isSelectionChangeEvent","responderEvent","eventPaths","wasNegotiated","currentResponderIdPath","eventIdPath","lowestCommonAncestor","indexOfLowestCommonAncestor","index","nodePath","wantsResponder","findWantsResponder","attemptTransfer","_currentResponder","_getResponderConfig","getResponderConfig","onResponderStart","onResponderMove","onResponderEnd","onResponderRelease","onResponderTerminate","onResponderTerminationRequest","isTerminateEvent","isReleaseEvent","changeCurrentResponder","shouldTerminate","shouldSetCallbacks","shouldSetCallbackCaptureName","shouldSetCallbackBubbleName","check","shouldSetCallback","i","result","_i","_id","_node","_result","_id2","_node2","target","_currentResponder2","currentId","currentNode","_getResponderConfig2","onResponderGrant","onResponderReject","_getResponderConfig3","allowTransfer","documentEventsCapturePhase","documentEventsBubblePhase","window","document","terminateResponder","_currentResponder3","_getResponderConfig4","event"],"mappings":"AAAA;;AAEAA,OAAO,CAAPA,UAAAA,GAAAA,IAAAA;AACAA,OAAO,CAAPA,eAAAA,GAAAA,eAAAA;AACAA,OAAO,CAAPA,OAAAA,GAAAA,OAAAA;AACAA,OAAO,CAAPA,UAAAA,GAAAA,UAAAA;AACAA,OAAO,CAAPA,kBAAAA,GAAAA,kBAAAA;AACAA,OAAO,CAAPA,gBAAAA,GAAAA,gBAAAA;;AAEA,IAAIC,qBAAqB,GAAGC,OAAO,CAAnC,+BAAmC,CAAnC;;AAEA,IAAIC,qBAAqB,GAAGC,sBAAsB,CAACF,OAAO,CAA1D,wBAA0D,CAAR,CAAlD;;AAEA,IAAIG,oBAAoB,GAAGH,OAAO,CAAlC,uBAAkC,CAAlC;;AAEA,IAAII,MAAM,GAAGJ,OAAO,CAApB,SAAoB,CAApB;;AAEA,IAAIK,2BAA2B,GAAGH,sBAAsB,CAACF,OAAO,CAAhE,8BAAgE,CAAR,CAAxD;;AAEA,SAAA,sBAAA,CAAA,GAAA,EAAqC;EAAE,OAAOM,GAAG,IAAIA,GAAG,CAAVA,UAAAA,GAAAA,GAAAA,GAA8B;IAAE,WAASA;EAAX,CAArC;AAAwD;AAE/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;A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","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.attachListeners = attachListeners;\nexports.addNode = addNode;\nexports.removeNode = removeNode;\nexports.terminateResponder = terminateResponder;\nexports.getResponderNode = getResponderNode;\n\nvar _ExecutionEnvironment = require(\"fbjs/lib/ExecutionEnvironment\");\n\nvar _createResponderEvent = _interopRequireDefault(require(\"./createResponderEvent\"));\n\nvar _ResponderEventTypes = require(\"./ResponderEventTypes\");\n\nvar _utils = require(\"./utils\");\n\nvar _ResponderTouchHistoryStore = _interopRequireDefault(require(\"./ResponderTouchHistoryStore\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) Nicolas Gallagher\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/**\n * RESPONDER EVENT SYSTEM\n *\n * A single, global \"interaction lock\" on views. For a view to be the \"responder\" means\n * that pointer interactions are exclusive to that view and none other. The \"interaction\n * lock\" can be transferred (only) to ancestors of the current \"responder\" as long as\n * pointers continue to be active.\n *\n * Responder being granted:\n *\n * A view can become the \"responder\" after the following events:\n *  * \"pointerdown\" (implemented using \"touchstart\", \"mousedown\")\n *  * \"pointermove\" (implemented using \"touchmove\", \"mousemove\")\n *  * \"scroll\" (while a pointer is down)\n *  * \"selectionchange\" (while a pointer is down)\n *\n * If nothing is already the \"responder\", the event propagates to (capture) and from\n * (bubble) the event target until a view returns `true` for\n * `on*ShouldSetResponder(Capture)`.\n *\n * If something is already the responder, the event propagates to (capture) and from\n * (bubble) the lowest common ancestor of the event target and the current \"responder\".\n * Then negotiation happens between the current \"responder\" and a view that wants to\n * become the \"responder\": see the timing diagram below.\n *\n * (NOTE: Scrolled views either automatically become the \"responder\" or release the\n * \"interaction lock\". A native scroll view that isn't built on top of the responder\n * system must result in the current \"responder\" being notified that it no longer has\n * the \"interaction lock\" - the native system has taken over.\n *\n * Responder being released:\n *\n * As soon as there are no more active pointers that *started* inside descendants\n * of the *current* \"responder\", an `onResponderRelease` event is dispatched to the\n * current \"responder\", and the responder lock is released.\n *\n * Typical sequence of events:\n *  * startShouldSetResponder\n *  * responderGrant/Reject\n *  * responderStart\n *  * responderMove\n *  * responderEnd\n *  * responderRelease\n */\n\n/*                                             Negotiation Performed\n                                             +-----------------------+\n                                            /                         \\\nProcess low level events to    +     Current Responder      +   wantsResponderID\ndetermine who to perform negot-|   (if any exists at all)   |\niation/transition              | Otherwise just pass through|\n-------------------------------+----------------------------+------------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +--------------+          |                            |\n     | onTouchStart |          |                            |\n     +------+-------+    none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onStartShouldSetResponder|----->| onResponderStart (cur) |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | | onResponder            | |\n            +------------------->|    TerminationRequest  | |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | | onResponderTerminate   |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderStart|\n                               |                            | +----------------+\nBubble to find first ID        |                            |\nto return true:wantsResponderID|                            |\n                               |                            |\n     +-------------+           |                            |\n     | onTouchMove |           |                            |\n     +------+------+     none  |                            |\n            |            return|                            |\n+-----------v-------------+true| +------------------------+ |\n|onMoveShouldSetResponder |----->| onResponderMove (cur)  |<-----------+\n+-----------+-------------+    | +------------------------+ |          |\n            |                  |                            | +--------+-------+\n            | returned true for|       false:REJECT +-------->|onResponderReject\n            | wantsResponderID |                    |       | +----------------+\n            | (now attempt     | +------------------+-----+ |\n            |  handoff)        | |   onResponder          | |\n            +------------------->|      TerminationRequest| |\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |         true:GRANT +-------->|onResponderGrant|\n                               |                            | +--------+-------+\n                               | +------------------------+ |          |\n                               | |   onResponderTerminate |<-----------+\n                               | +------------------+-----+ |\n                               |                    |       | +----------------+\n                               |                    +-------->|onResponderMove |\n                               |                            | +----------------+\n                               |                            |\n                               |                            |\n      Some active touch started|                            |\n      inside current responder | +------------------------+ |\n      +------------------------->|      onResponderEnd    | |\n      |                        | +------------------------+ |\n  +---+---------+              |                            |\n  | onTouchEnd  |              |                            |\n  +---+---------+              |                            |\n      |                        | +------------------------+ |\n      +------------------------->|     onResponderEnd     | |\n      No active touches started| +-----------+------------+ |\n      inside current responder |             |              |\n                               |             v              |\n                               | +------------------------+ |\n                               | |    onResponderRelease  | |\n                               | +------------------------+ |\n                               |                            |\n                               +                            + */\nvar emptyObject = {};\n/* ------------ IMPLEMENTATION ------------ */\n\nvar startRegistration = ['onStartShouldSetResponderCapture', 'onStartShouldSetResponder', {\n  bubbles: true\n}];\nvar moveRegistration = ['onMoveShouldSetResponderCapture', 'onMoveShouldSetResponder', {\n  bubbles: true\n}];\nvar scrollRegistration = ['onScrollShouldSetResponderCapture', 'onScrollShouldSetResponder', {\n  bubbles: false\n}];\nvar shouldSetResponderEvents = {\n  touchstart: startRegistration,\n  mousedown: startRegistration,\n  touchmove: moveRegistration,\n  mousemove: moveRegistration,\n  scroll: scrollRegistration\n};\nvar emptyResponder = {\n  id: null,\n  idPath: null,\n  node: null\n};\nvar responderListenersMap = new Map();\nvar isEmulatingMouseEvents = false;\nvar trackedTouchCount = 0;\nvar currentResponder = {\n  id: null,\n  node: null,\n  idPath: null\n};\n\nfunction changeCurrentResponder(responder) {\n  currentResponder = responder;\n}\n\nfunction getResponderConfig(id) {\n  var config = responderListenersMap.get(id);\n  return config != null ? config : emptyObject;\n}\n/**\n * Process native events\n *\n * A single event listener is used to manage the responder system.\n * All pointers are tracked in the ResponderTouchHistoryStore. Native events\n * are interpreted in terms of the Responder System and checked to see if\n * the responder should be transferred. Each host node that is attached to\n * the Responder System has an ID, which is used to look up its associated\n * callbacks.\n */\n\n\nfunction eventListener(domEvent) {\n  var eventType = domEvent.type;\n  var eventTarget = domEvent.target;\n  /**\n   * Manage emulated events and early bailout.\n   * Since PointerEvent is not used yet (lack of support in older Safari), it's\n   * necessary to manually manage the mess of browser touch/mouse events.\n   * And bailout early for termination events when there is no active responder.\n   */\n  // Flag when browser may produce emulated events\n\n  if (eventType === 'touchstart') {\n    isEmulatingMouseEvents = true;\n  } // Remove flag when browser will not produce emulated events\n\n\n  if (eventType === 'touchmove' || trackedTouchCount > 1) {\n    isEmulatingMouseEvents = false;\n  } // Ignore various events in particular circumstances\n\n\n  if ( // Ignore browser emulated mouse events\n  eventType === 'mousedown' && isEmulatingMouseEvents || eventType === 'mousemove' && isEmulatingMouseEvents || // Ignore mousemove if a mousedown didn't occur first\n  eventType === 'mousemove' && trackedTouchCount < 1) {\n    return;\n  } // Remove flag after emulated events are finished\n\n\n  if (isEmulatingMouseEvents && eventType === 'mouseup') {\n    if (trackedTouchCount === 0) {\n      isEmulatingMouseEvents = false;\n    }\n\n    return;\n  }\n\n  var isStartEvent = (0, _ResponderEventTypes.isStartish)(eventType) && (0, _utils.isPrimaryPointerDown)(domEvent);\n  var isMoveEvent = (0, _ResponderEventTypes.isMoveish)(eventType);\n  var isEndEvent = (0, _ResponderEventTypes.isEndish)(eventType);\n  var isScrollEvent = (0, _ResponderEventTypes.isScroll)(eventType);\n  var isSelectionChangeEvent = (0, _ResponderEventTypes.isSelectionChange)(eventType);\n  var responderEvent = (0, _createResponderEvent.default)(domEvent);\n  /**\n   * Record the state of active pointers\n   */\n\n  if (isStartEvent || isMoveEvent || isEndEvent) {\n    if (domEvent.touches) {\n      trackedTouchCount = domEvent.touches.length;\n    } else {\n      if (isStartEvent) {\n        trackedTouchCount = 1;\n      } else if (isEndEvent) {\n        trackedTouchCount = 0;\n      }\n    }\n\n    _ResponderTouchHistoryStore.default.recordTouchTrack(eventType, responderEvent.nativeEvent);\n  }\n  /**\n   * Responder System logic\n   */\n\n\n  var eventPaths = (0, _utils.getResponderPaths)(domEvent);\n  var wasNegotiated = false;\n  var wantsResponder; // If an event occured that might change the current responder...\n\n  if (isStartEvent || isMoveEvent || isScrollEvent && trackedTouchCount > 0) {\n    // If there is already a responder, prune the event paths to the lowest common ancestor\n    // of the existing responder and deepest target of the event.\n    var currentResponderIdPath = currentResponder.idPath;\n    var eventIdPath = eventPaths.idPath;\n\n    if (currentResponderIdPath != null && eventIdPath != null) {\n      var lowestCommonAncestor = (0, _utils.getLowestCommonAncestor)(currentResponderIdPath, eventIdPath);\n\n      if (lowestCommonAncestor != null) {\n        var indexOfLowestCommonAncestor = eventIdPath.indexOf(lowestCommonAncestor); // Skip the current responder so it doesn't receive unexpected \"shouldSet\" events.\n\n        var index = indexOfLowestCommonAncestor + (lowestCommonAncestor === currentResponder.id ? 1 : 0);\n        eventPaths = {\n          idPath: eventIdPath.slice(index),\n          nodePath: eventPaths.nodePath.slice(index)\n        };\n      } else {\n        eventPaths = null;\n      }\n    }\n\n    if (eventPaths != null) {\n      // If a node wants to become the responder, attempt to transfer.\n      wantsResponder = findWantsResponder(eventPaths, domEvent, responderEvent);\n\n      if (wantsResponder != null) {\n        // Sets responder if none exists, or negotates with existing responder.\n        attemptTransfer(responderEvent, wantsResponder);\n        wasNegotiated = true;\n      }\n    }\n  } // If there is now a responder, invoke its callbacks for the lifecycle of the gesture.\n\n\n  if (currentResponder.id != null && currentResponder.node != null) {\n    var _currentResponder = currentResponder,\n        id = _currentResponder.id,\n        node = _currentResponder.node;\n\n    var _getResponderConfig = getResponderConfig(id),\n        onResponderStart = _getResponderConfig.onResponderStart,\n        onResponderMove = _getResponderConfig.onResponderMove,\n        onResponderEnd = _getResponderConfig.onResponderEnd,\n        onResponderRelease = _getResponderConfig.onResponderRelease,\n        onResponderTerminate = _getResponderConfig.onResponderTerminate,\n        onResponderTerminationRequest = _getResponderConfig.onResponderTerminationRequest;\n\n    responderEvent.bubbles = false;\n    responderEvent.cancelable = false;\n    responderEvent.currentTarget = node; // Start\n\n    if (isStartEvent) {\n      if (onResponderStart != null) {\n        onResponderStart(responderEvent);\n      }\n    } // Move\n    else if (isMoveEvent) {\n        if (onResponderMove != null) {\n          onResponderMove(responderEvent);\n        }\n      } else {\n        var isTerminateEvent = (0, _ResponderEventTypes.isCancelish)(eventType) || // native context menu\n        eventType === 'contextmenu' || // window blur\n        eventType === 'blur' && eventTarget === window || // responder (or ancestors) blur\n        eventType === 'blur' && eventTarget.contains(node) && domEvent.relatedTarget !== node || // native scroll without using a pointer\n        isScrollEvent && trackedTouchCount === 0 || // native scroll on node that is parent of the responder (allow siblings to scroll)\n        isScrollEvent && eventTarget.contains(node) && eventTarget !== node || // native select/selectionchange on node\n        isSelectionChangeEvent && (0, _utils.hasValidSelection)(domEvent);\n        var isReleaseEvent = isEndEvent && !isTerminateEvent && !(0, _utils.hasTargetTouches)(node, domEvent.touches); // End\n\n        if (isEndEvent) {\n          if (onResponderEnd != null) {\n            onResponderEnd(responderEvent);\n          }\n        } // Release\n\n\n        if (isReleaseEvent) {\n          if (onResponderRelease != null) {\n            onResponderRelease(responderEvent);\n          }\n\n          changeCurrentResponder(emptyResponder);\n        } // Terminate\n\n\n        if (isTerminateEvent) {\n          var shouldTerminate = true; // Responders can still avoid termination but only for these events.\n\n          if (eventType === 'contextmenu' || eventType === 'scroll' || eventType === 'selectionchange') {\n            if (wasNegotiated || // Only call this function is it wasn't already called during negotiation.\n            onResponderTerminationRequest != null && onResponderTerminationRequest(responderEvent) === false) {\n              shouldTerminate = false;\n            }\n          }\n\n          if (shouldTerminate) {\n            if (onResponderTerminate != null) {\n              onResponderTerminate(responderEvent);\n            }\n\n            changeCurrentResponder(emptyResponder);\n            isEmulatingMouseEvents = false;\n            trackedTouchCount = 0;\n          }\n        }\n      }\n  }\n}\n/**\n * Walk the event path to/from the target node. At each node, stop and call the\n * relevant \"shouldSet\" functions for the given event type. If any of those functions\n * call \"stopPropagation\" on the event, stop searching for a responder.\n */\n\n\nfunction findWantsResponder(eventPaths, domEvent, responderEvent) {\n  var shouldSetCallbacks = shouldSetResponderEvents[domEvent.type]; // for Flow\n\n  if (shouldSetCallbacks != null) {\n    var idPath = eventPaths.idPath,\n        nodePath = eventPaths.nodePath;\n    var shouldSetCallbackCaptureName = shouldSetCallbacks[0];\n    var shouldSetCallbackBubbleName = shouldSetCallbacks[1];\n    var bubbles = shouldSetCallbacks[2].bubbles;\n\n    var check = function check(id, node, callbackName) {\n      var config = getResponderConfig(id);\n      var shouldSetCallback = config[callbackName];\n\n      if (shouldSetCallback != null) {\n        if (shouldSetCallback(responderEvent) === true) {\n          return {\n            id: id,\n            node: node,\n            idPath: idPath\n          };\n        }\n      }\n    }; // capture\n\n\n    for (var i = idPath.length - 1; i >= 0; i--) {\n      var id = idPath[i];\n      var node = nodePath[i];\n      var result = check(id, node, shouldSetCallbackCaptureName);\n\n      if (result != null) {\n        return result;\n      }\n\n      if (responderEvent.isPropagationStopped() === true) {\n        return;\n      }\n    } // bubble\n\n\n    if (bubbles) {\n      for (var _i = 0; _i < idPath.length; _i++) {\n        var _id = idPath[_i];\n        var _node = nodePath[_i];\n\n        var _result = check(_id, _node, shouldSetCallbackBubbleName);\n\n        if (_result != null) {\n          return _result;\n        }\n\n        if (responderEvent.isPropagationStopped() === true) {\n          return;\n        }\n      }\n    } else {\n      var _id2 = idPath[0];\n      var _node2 = nodePath[0];\n      var target = domEvent.target;\n\n      if (target === _node2) {\n        return check(_id2, _node2, shouldSetCallbackBubbleName);\n      }\n    }\n  }\n}\n/**\n * Attempt to transfer the responder.\n */\n\n\nfunction attemptTransfer(responderEvent, wantsResponder) {\n  var _currentResponder2 = currentResponder,\n      currentId = _currentResponder2.id,\n      currentNode = _currentResponder2.node;\n  var id = wantsResponder.id,\n      node = wantsResponder.node;\n\n  var _getResponderConfig2 = getResponderConfig(id),\n      onResponderGrant = _getResponderConfig2.onResponderGrant,\n      onResponderReject = _getResponderConfig2.onResponderReject;\n\n  responderEvent.bubbles = false;\n  responderEvent.cancelable = false;\n  responderEvent.currentTarget = node; // Set responder\n\n  if (currentId == null) {\n    if (onResponderGrant != null) {\n      responderEvent.currentTarget = node;\n      responderEvent.dispatchConfig.registrationName = 'onResponderGrant';\n      onResponderGrant(responderEvent);\n    }\n\n    changeCurrentResponder(wantsResponder);\n  } // Negotiate with current responder\n  else {\n      var _getResponderConfig3 = getResponderConfig(currentId),\n          onResponderTerminate = _getResponderConfig3.onResponderTerminate,\n          onResponderTerminationRequest = _getResponderConfig3.onResponderTerminationRequest;\n\n      var allowTransfer = onResponderTerminationRequest != null && onResponderTerminationRequest(responderEvent);\n\n      if (allowTransfer) {\n        // Terminate existing responder\n        if (onResponderTerminate != null) {\n          responderEvent.currentTarget = currentNode;\n          onResponderTerminate(responderEvent);\n        } // Grant next responder\n\n\n        if (onResponderGrant != null) {\n          onResponderGrant(responderEvent);\n        }\n\n        changeCurrentResponder(wantsResponder);\n      } else {\n        // Reject responder request\n        if (onResponderReject != null) {\n          onResponderReject(responderEvent);\n        }\n      }\n    }\n}\n/* ------------ PUBLIC API ------------ */\n\n/**\n * Attach Listeners\n *\n * Use native events as ReactDOM doesn't have a non-plugin API to implement\n * this system.\n */\n\n\nvar documentEventsCapturePhase = ['blur', 'scroll'];\nvar documentEventsBubblePhase = [// mouse\n'mousedown', 'mousemove', 'mouseup', 'dragstart', // touch\n'touchstart', 'touchmove', 'touchend', 'touchcancel', // other\n'contextmenu', 'select', 'selectionchange'];\n\nfunction attachListeners() {\n  if (_ExecutionEnvironment.canUseDOM && window.__reactResponderSystemActive == null) {\n    window.addEventListener('blur', eventListener);\n    documentEventsBubblePhase.forEach(function (eventType) {\n      document.addEventListener(eventType, eventListener);\n    });\n    documentEventsCapturePhase.forEach(function (eventType) {\n      document.addEventListener(eventType, eventListener, true);\n    });\n    window.__reactResponderSystemActive = true;\n  }\n}\n/**\n * Register a node with the ResponderSystem.\n */\n\n\nfunction addNode(id, node, config) {\n  (0, _utils.setResponderId)(node, id);\n  responderListenersMap.set(id, config);\n}\n/**\n * Unregister a node with the ResponderSystem.\n */\n\n\nfunction removeNode(id) {\n  if (currentResponder.id === id) {\n    terminateResponder();\n  }\n\n  if (responderListenersMap.has(id)) {\n    responderListenersMap.delete(id);\n  }\n}\n/**\n * Allow the current responder to be terminated from within components to support\n * more complex requirements, such as use with other React libraries for working\n * with scroll views, input views, etc.\n */\n\n\nfunction terminateResponder() {\n  var _currentResponder3 = currentResponder,\n      id = _currentResponder3.id,\n      node = _currentResponder3.node;\n\n  if (id != null && node != null) {\n    var _getResponderConfig4 = getResponderConfig(id),\n        onResponderTerminate = _getResponderConfig4.onResponderTerminate;\n\n    if (onResponderTerminate != null) {\n      var event = (0, _createResponderEvent.default)({});\n      event.currentTarget = node;\n      onResponderTerminate(event);\n    }\n\n    changeCurrentResponder(emptyResponder);\n  }\n\n  isEmulatingMouseEvents = false;\n  trackedTouchCount = 0;\n}\n/**\n * Allow unit tests to inspect the current responder in the system.\n * FOR TESTING ONLY.\n */\n\n\nfunction getResponderNode() {\n  return currentResponder.node;\n}"]},"metadata":{},"sourceType":"module"}