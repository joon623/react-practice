{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n'use strict';\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\nvar DELAY = 'DELAY';\nvar ERROR = 'ERROR';\nvar LONG_PRESS_DETECTED = 'LONG_PRESS_DETECTED';\nvar NOT_RESPONDER = 'NOT_RESPONDER';\nvar RESPONDER_ACTIVE_LONG_PRESS_START = 'RESPONDER_ACTIVE_LONG_PRESS_START';\nvar RESPONDER_ACTIVE_PRESS_START = 'RESPONDER_ACTIVE_PRESS_START';\nvar RESPONDER_INACTIVE_PRESS_START = 'RESPONDER_INACTIVE_PRESS_START';\nvar RESPONDER_GRANT = 'RESPONDER_GRANT';\nvar RESPONDER_RELEASE = 'RESPONDER_RELEASE';\nvar RESPONDER_TERMINATED = 'RESPONDER_TERMINATED';\nvar Transitions = Object.freeze({\n  NOT_RESPONDER: {\n    DELAY: ERROR,\n    RESPONDER_GRANT: RESPONDER_INACTIVE_PRESS_START,\n    RESPONDER_RELEASE: ERROR,\n    RESPONDER_TERMINATED: ERROR,\n    LONG_PRESS_DETECTED: ERROR\n  },\n  RESPONDER_INACTIVE_PRESS_START: {\n    DELAY: RESPONDER_ACTIVE_PRESS_START,\n    RESPONDER_GRANT: ERROR,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: ERROR\n  },\n  RESPONDER_ACTIVE_PRESS_START: {\n    DELAY: ERROR,\n    RESPONDER_GRANT: ERROR,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: RESPONDER_ACTIVE_LONG_PRESS_START\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_START: {\n    DELAY: ERROR,\n    RESPONDER_GRANT: ERROR,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: RESPONDER_ACTIVE_LONG_PRESS_START\n  },\n  ERROR: {\n    DELAY: NOT_RESPONDER,\n    RESPONDER_GRANT: RESPONDER_INACTIVE_PRESS_START,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: NOT_RESPONDER\n  }\n});\n\nvar isActiveSignal = function isActiveSignal(signal) {\n  return signal === RESPONDER_ACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_LONG_PRESS_START;\n};\n\nvar isPressStartSignal = function isPressStartSignal(signal) {\n  return signal === RESPONDER_INACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_LONG_PRESS_START;\n};\n\nvar isTerminalSignal = function isTerminalSignal(signal) {\n  return signal === RESPONDER_TERMINATED || signal === RESPONDER_RELEASE;\n};\n\nvar isValidKeyPress = function isValidKeyPress(event) {\n  var key = event.key;\n  var target = event.currentTarget;\n  var role = target.getAttribute('role');\n  var isSpacebar = key === ' ' || key === 'Spacebar';\n  return !event.repeat && (key === 'Enter' || isSpacebar && (role === 'button' || role === 'menuitem'));\n};\n\nvar DEFAULT_LONG_PRESS_DELAY_MS = 450; // 500 - 50\n\nvar DEFAULT_PRESS_DELAY_MS = 50;\n/**\n * =========================== PressResponder Tutorial ===========================\n *\n * The `PressResponder` class helps you create press interactions by analyzing the\n * geometry of elements and observing when another responder (e.g. ScrollView)\n * has stolen the touch lock. It offers hooks for your component to provide\n * interaction feedback to the user:\n *\n * - When a press has activated (e.g. highlight an element)\n * - When a press has deactivated (e.g. un-highlight an element)\n * - When a press sould trigger an action, meaning it activated and deactivated\n *   while within the geometry of the element without the lock being stolen.\n *\n * A high quality interaction isn't as simple as you might think. There should\n * be a slight delay before activation. Moving your finger beyond an element's\n * bounds should trigger deactivation, but moving the same finger back within an\n * element's bounds should trigger reactivation.\n *\n * In order to use `PressResponder`, do the following:\n *\n *     const pressResponder = new PressResponder(config);\n *\n * 2. Choose the rendered component who should collect the press events. On that\n *    element, spread `pressability.getEventHandlers()` into its props.\n *\n *    return (\n *      <View {...this.state.pressResponder.getEventHandlers()} />\n *    );\n *\n * 3. Reset `PressResponder` when your component unmounts.\n *\n *    componentWillUnmount() {\n *      this.state.pressResponder.reset();\n *    }\n *\n * ==================== Implementation Details ====================\n *\n * `PressResponder` only assumes that there exists a `HitRect` node. The `PressRect`\n * is an abstract box that is extended beyond the `HitRect`.\n *\n * # Geometry\n *\n *  ┌────────────────────────┐\n *  │  ┌──────────────────┐  │ - Presses start anywhere within `HitRect`.\n *  │  │  ┌────────────┐  │  │\n *  │  │  │ VisualRect │  │  │\n *  │  │  └────────────┘  │  │ - When pressed down for sufficient amount of time\n *  │  │    HitRect       │  │   before letting up, `VisualRect` activates.\n *  │  └──────────────────┘  │\n *  │       Out Region   o   │\n *  └────────────────────│───┘\n *                       └────── When the press is released outside the `HitRect`,\n *                               the responder is NOT eligible for a \"press\".\n *\n * # State Machine\n *\n * ┌───────────────┐ ◀──── RESPONDER_RELEASE\n * │ NOT_RESPONDER │\n * └───┬───────────┘ ◀──── RESPONDER_TERMINATED\n *     │\n *     │ RESPONDER_GRANT (HitRect)\n *     │\n *     ▼\n * ┌─────────────────────┐          ┌───────────────────┐              ┌───────────────────┐\n * │ RESPONDER_INACTIVE_ │  DELAY   │ RESPONDER_ACTIVE_ │  T + DELAY   │ RESPONDER_ACTIVE_ │\n * │ PRESS_START         ├────────▶ │ PRESS_START       ├────────────▶ │ LONG_PRESS_START  │\n * └─────────────────────┘          └───────────────────┘              └───────────────────┘\n *\n * T + DELAY => LONG_PRESS_DELAY + DELAY\n *\n * Not drawn are the side effects of each transition. The most important side\n * effect is the invocation of `onLongPress`. Only when the browser produces a\n * `click` event is `onPress` invoked.\n */\n\nvar PressResponder = /*#__PURE__*/function () {\n  function PressResponder(config) {\n    this._eventHandlers = null;\n    this._isPointerTouch = false;\n    this._longPressDelayTimeout = null;\n    this._longPressDispatched = false;\n    this._pressDelayTimeout = null;\n    this._pressOutDelayTimeout = null;\n    this._touchState = NOT_RESPONDER;\n    this.configure(config);\n  }\n\n  var _proto = PressResponder.prototype;\n\n  _proto.configure = function configure(config) {\n    this._config = config;\n  }\n  /**\n   * Resets any pending timers. This should be called on unmount.\n   */\n  ;\n\n  _proto.reset = function reset() {\n    this._cancelLongPressDelayTimeout();\n\n    this._cancelPressDelayTimeout();\n\n    this._cancelPressOutDelayTimeout();\n  }\n  /**\n   * Returns a set of props to spread into the interactive element.\n   */\n  ;\n\n  _proto.getEventHandlers = function getEventHandlers() {\n    if (this._eventHandlers == null) {\n      this._eventHandlers = this._createEventHandlers();\n    }\n\n    return this._eventHandlers;\n  };\n\n  _proto._createEventHandlers = function _createEventHandlers() {\n    var _this = this;\n\n    var start = function start(event, shouldDelay) {\n      event.persist();\n\n      _this._cancelPressOutDelayTimeout();\n\n      _this._longPressDispatched = false;\n      _this._responder = event.currentTarget;\n      _this._selectionTerminated = false;\n      _this._touchState = NOT_RESPONDER;\n      _this._isPointerTouch = event.nativeEvent.type === 'touchstart';\n\n      _this._receiveSignal(RESPONDER_GRANT, event);\n\n      var delayPressStart = normalizeDelay(_this._config.delayPressStart, 0, DEFAULT_PRESS_DELAY_MS);\n\n      if (shouldDelay !== false && delayPressStart > 0) {\n        _this._pressDelayTimeout = setTimeout(function () {\n          _this._receiveSignal(DELAY, event);\n        }, delayPressStart);\n      } else {\n        _this._receiveSignal(DELAY, event);\n      }\n\n      var delayLongPress = normalizeDelay(_this._config.delayLongPress, 10, DEFAULT_LONG_PRESS_DELAY_MS);\n      _this._longPressDelayTimeout = setTimeout(function () {\n        _this._handleLongPress(event);\n      }, delayLongPress + delayPressStart);\n    };\n\n    var end = function end(event) {\n      _this._receiveSignal(RESPONDER_RELEASE, event);\n    };\n\n    var keyupHandler = function keyupHandler(event) {\n      if (_this._touchState !== NOT_RESPONDER) {\n        end(event);\n        document.removeEventListener('keyup', keyupHandler);\n      }\n    };\n\n    return {\n      onStartShouldSetResponder: function onStartShouldSetResponder() {\n        var disabled = _this._config.disabled;\n\n        if (disabled == null) {\n          return true;\n        }\n\n        return !disabled;\n      },\n      onKeyDown: function onKeyDown(event) {\n        if (isValidKeyPress(event)) {\n          if (_this._touchState === NOT_RESPONDER) {\n            start(event, false); // Listen to 'keyup' on document to account for situations where\n            // focus is moved to another element during 'keydown'.\n\n            document.addEventListener('keyup', keyupHandler);\n          }\n\n          event.stopPropagation();\n        }\n      },\n      onResponderGrant: function onResponderGrant(event) {\n        return start(event);\n      },\n      onResponderMove: function onResponderMove(event) {\n        if (_this._config.onPressMove != null) {\n          _this._config.onPressMove(event);\n        }\n\n        var touch = getTouchFromResponderEvent(event);\n\n        if (_this._touchActivatePosition != null) {\n          var deltaX = _this._touchActivatePosition.pageX - touch.pageX;\n          var deltaY = _this._touchActivatePosition.pageY - touch.pageY;\n\n          if (Math.hypot(deltaX, deltaY) > 10) {\n            _this._cancelLongPressDelayTimeout();\n          }\n        }\n      },\n      onResponderRelease: function onResponderRelease(event) {\n        return end(event);\n      },\n      onResponderTerminate: function onResponderTerminate(event) {\n        if (event.nativeEvent.type === 'selectionchange') {\n          _this._selectionTerminated = true;\n        }\n\n        _this._receiveSignal(RESPONDER_TERMINATED, event);\n      },\n      onResponderTerminationRequest: function onResponderTerminationRequest(event) {\n        var _this$_config = _this._config,\n            cancelable = _this$_config.cancelable,\n            disabled = _this$_config.disabled,\n            onLongPress = _this$_config.onLongPress; // If `onLongPress` is provided, don't terminate on `contextmenu` as default\n        // behavior will be prevented for non-mouse pointers.\n\n        if (!disabled && onLongPress != null && _this._isPointerTouch && event.nativeEvent.type === 'contextmenu') {\n          return false;\n        }\n\n        if (cancelable == null) {\n          return true;\n        }\n\n        return cancelable;\n      },\n      // NOTE: this diverges from react-native in 3 significant ways:\n      // * The `onPress` callback is not connected to the responder system (the native\n      //  `click` event must be used but is dispatched in many scenarios where no pointers\n      //   are on the screen.) Therefore, it's possible for `onPress` to be called without\n      //   `onPress{Start,End}` being called first.\n      // * The `onPress` callback is only be called on the first ancestor of the native\n      //   `click` target that is using the PressResponder.\n      // * The event's `nativeEvent` is a `MouseEvent` not a `TouchEvent`.\n      onClick: function onClick(event) {\n        var _this$_config2 = _this._config,\n            disabled = _this$_config2.disabled,\n            onPress = _this$_config2.onPress;\n\n        if (!disabled) {\n          // If long press dispatched, cancel default click behavior.\n          // If the responder terminated because text was selected during the gesture,\n          // cancel the default click behavior.\n          if (_this._longPressDispatched || _this._selectionTerminated) {\n            event.preventDefault();\n          } else if (onPress != null && event.ctrlKey === false && event.altKey === false) {\n            onPress(event);\n          }\n        }\n\n        event.stopPropagation();\n      },\n      // If `onLongPress` is provided and a touch pointer is being used, prevent the\n      // default context menu from opening.\n      onContextMenu: function onContextMenu(event) {\n        var _this$_config3 = _this._config,\n            disabled = _this$_config3.disabled,\n            onLongPress = _this$_config3.onLongPress;\n\n        if (!disabled && onLongPress != null && _this._isPointerTouch && !event.defaultPrevented) {\n          event.preventDefault();\n        }\n\n        event.stopPropagation();\n      }\n    };\n  }\n  /**\n   * Receives a state machine signal, performs side effects of the transition\n   * and stores the new state. Validates the transition as well.\n   */\n  ;\n\n  _proto._receiveSignal = function _receiveSignal(signal, event) {\n    var prevState = this._touchState;\n    var nextState = null;\n\n    if (Transitions[prevState] != null) {\n      nextState = Transitions[prevState][signal];\n    }\n\n    if (this._responder == null && signal === RESPONDER_RELEASE) {\n      return;\n    }\n\n    if (nextState == null || nextState === ERROR) {\n      console.error(\"PressResponder: Invalid signal \" + signal + \" for state \" + prevState + \" on responder\");\n    } else if (prevState !== nextState) {\n      this._performTransitionSideEffects(prevState, nextState, signal, event);\n\n      this._touchState = nextState;\n    }\n  }\n  /**\n   * Performs a transition between touchable states and identify any activations\n   * or deactivations (and callback invocations).\n   */\n  ;\n\n  _proto._performTransitionSideEffects = function _performTransitionSideEffects(prevState, nextState, signal, event) {\n    if (isTerminalSignal(signal)) {\n      this._isPointerTouch = false;\n      this._touchActivatePosition = null;\n\n      this._cancelLongPressDelayTimeout();\n    }\n\n    if (isPressStartSignal(prevState) && signal === LONG_PRESS_DETECTED) {\n      var onLongPress = this._config.onLongPress; // Long press is not supported for keyboards because 'click' can be dispatched\n      // immediately (and multiple times) after 'keydown'.\n\n      if (onLongPress != null && event.nativeEvent.key == null) {\n        onLongPress(event);\n        this._longPressDispatched = true;\n      }\n    }\n\n    var isPrevActive = isActiveSignal(prevState);\n    var isNextActive = isActiveSignal(nextState);\n\n    if (!isPrevActive && isNextActive) {\n      this._activate(event);\n    } else if (isPrevActive && !isNextActive) {\n      this._deactivate(event);\n    }\n\n    if (isPressStartSignal(prevState) && signal === RESPONDER_RELEASE) {\n      var _this$_config4 = this._config,\n          _onLongPress = _this$_config4.onLongPress,\n          onPress = _this$_config4.onPress;\n\n      if (onPress != null) {\n        var isPressCanceledByLongPress = _onLongPress != null && prevState === RESPONDER_ACTIVE_LONG_PRESS_START;\n\n        if (!isPressCanceledByLongPress) {\n          // If we never activated (due to delays), activate and deactivate now.\n          if (!isNextActive && !isPrevActive) {\n            this._activate(event);\n\n            this._deactivate(event);\n          }\n        }\n      }\n    }\n\n    this._cancelPressDelayTimeout();\n  };\n\n  _proto._activate = function _activate(event) {\n    var _this$_config5 = this._config,\n        onPressChange = _this$_config5.onPressChange,\n        onPressStart = _this$_config5.onPressStart;\n    var touch = getTouchFromResponderEvent(event);\n    this._touchActivatePosition = {\n      pageX: touch.pageX,\n      pageY: touch.pageY\n    };\n\n    if (onPressStart != null) {\n      onPressStart(event);\n    }\n\n    if (onPressChange != null) {\n      onPressChange(true);\n    }\n  };\n\n  _proto._deactivate = function _deactivate(event) {\n    var _this$_config6 = this._config,\n        onPressChange = _this$_config6.onPressChange,\n        onPressEnd = _this$_config6.onPressEnd;\n\n    function end() {\n      if (onPressEnd != null) {\n        onPressEnd(event);\n      }\n\n      if (onPressChange != null) {\n        onPressChange(false);\n      }\n    }\n\n    var delayPressEnd = normalizeDelay(this._config.delayPressEnd);\n\n    if (delayPressEnd > 0) {\n      this._pressOutDelayTimeout = setTimeout(function () {\n        end();\n      }, delayPressEnd);\n    } else {\n      end();\n    }\n  };\n\n  _proto._handleLongPress = function _handleLongPress(event) {\n    if (this._touchState === RESPONDER_ACTIVE_PRESS_START || this._touchState === RESPONDER_ACTIVE_LONG_PRESS_START) {\n      this._receiveSignal(LONG_PRESS_DETECTED, event);\n    }\n  };\n\n  _proto._cancelLongPressDelayTimeout = function _cancelLongPressDelayTimeout() {\n    if (this._longPressDelayTimeout != null) {\n      clearTimeout(this._longPressDelayTimeout);\n      this._longPressDelayTimeout = null;\n    }\n  };\n\n  _proto._cancelPressDelayTimeout = function _cancelPressDelayTimeout() {\n    if (this._pressDelayTimeout != null) {\n      clearTimeout(this._pressDelayTimeout);\n      this._pressDelayTimeout = null;\n    }\n  };\n\n  _proto._cancelPressOutDelayTimeout = function _cancelPressOutDelayTimeout() {\n    if (this._pressOutDelayTimeout != null) {\n      clearTimeout(this._pressOutDelayTimeout);\n      this._pressOutDelayTimeout = null;\n    }\n  };\n\n  return PressResponder;\n}();\n\nexports[\"default\"] = PressResponder;\n\nfunction normalizeDelay(delay, min, fallback) {\n  if (min === void 0) {\n    min = 0;\n  }\n\n  if (fallback === void 0) {\n    fallback = 0;\n  }\n\n  return Math.max(min, delay !== null && delay !== void 0 ? delay : fallback);\n}\n\nfunction getTouchFromResponderEvent(event) {\n  var _event$nativeEvent = event.nativeEvent,\n      changedTouches = _event$nativeEvent.changedTouches,\n      touches = _event$nativeEvent.touches;\n\n  if (touches != null && touches.length > 0) {\n    return touches[0];\n  }\n\n  if (changedTouches != null && changedTouches.length > 0) {\n    return changedTouches[0];\n  }\n\n  return event.nativeEvent;\n}\n\nmodule.exports = exports[\"default\"];\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = __webpack_module__.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      __webpack_module__.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      import.meta.webpackHot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          __webpack_module__.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        __webpack_module__.hot.invalidate();\n      }\n    }\n  }\n})();","map":{"version":3,"sources":["/Users/jun/Desktop/dev/react-practice/with-react-native-web-app/node_modules/react-native-web/dist/cjs/hooks/usePressEvents/PressResponder.js"],"names":["exports","DELAY","ERROR","LONG_PRESS_DETECTED","NOT_RESPONDER","RESPONDER_ACTIVE_LONG_PRESS_START","RESPONDER_ACTIVE_PRESS_START","RESPONDER_INACTIVE_PRESS_START","RESPONDER_GRANT","RESPONDER_RELEASE","RESPONDER_TERMINATED","Transitions","isActiveSignal","signal","isPressStartSignal","isTerminalSignal","isValidKeyPress","key","event","target","role","isSpacebar","DEFAULT_LONG_PRESS_DELAY_MS","DEFAULT_PRESS_DELAY_MS","PressResponder","_proto","_this","start","delayPressStart","normalizeDelay","shouldDelay","setTimeout","delayLongPress","end","keyupHandler","document","onStartShouldSetResponder","disabled","onKeyDown","onResponderGrant","onResponderMove","touch","getTouchFromResponderEvent","deltaX","deltaY","Math","onResponderRelease","onResponderTerminate","onResponderTerminationRequest","_this$_config","cancelable","onLongPress","onClick","_this$_config2","onPress","onContextMenu","_this$_config3","prevState","nextState","console","isPrevActive","isNextActive","_this$_config4","_onLongPress","isPressCanceledByLongPress","_this$_config5","onPressChange","onPressStart","pageX","pageY","_this$_config6","onPressEnd","delayPressEnd","clearTimeout","min","fallback","delay","_event$nativeEvent","changedTouches","touches","module"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n'use strict';\n\nexports.__esModule = true;\nexports.default = void 0;\nvar DELAY = 'DELAY';\nvar ERROR = 'ERROR';\nvar LONG_PRESS_DETECTED = 'LONG_PRESS_DETECTED';\nvar NOT_RESPONDER = 'NOT_RESPONDER';\nvar RESPONDER_ACTIVE_LONG_PRESS_START = 'RESPONDER_ACTIVE_LONG_PRESS_START';\nvar RESPONDER_ACTIVE_PRESS_START = 'RESPONDER_ACTIVE_PRESS_START';\nvar RESPONDER_INACTIVE_PRESS_START = 'RESPONDER_INACTIVE_PRESS_START';\nvar RESPONDER_GRANT = 'RESPONDER_GRANT';\nvar RESPONDER_RELEASE = 'RESPONDER_RELEASE';\nvar RESPONDER_TERMINATED = 'RESPONDER_TERMINATED';\nvar Transitions = Object.freeze({\n  NOT_RESPONDER: {\n    DELAY: ERROR,\n    RESPONDER_GRANT: RESPONDER_INACTIVE_PRESS_START,\n    RESPONDER_RELEASE: ERROR,\n    RESPONDER_TERMINATED: ERROR,\n    LONG_PRESS_DETECTED: ERROR\n  },\n  RESPONDER_INACTIVE_PRESS_START: {\n    DELAY: RESPONDER_ACTIVE_PRESS_START,\n    RESPONDER_GRANT: ERROR,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: ERROR\n  },\n  RESPONDER_ACTIVE_PRESS_START: {\n    DELAY: ERROR,\n    RESPONDER_GRANT: ERROR,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: RESPONDER_ACTIVE_LONG_PRESS_START\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_START: {\n    DELAY: ERROR,\n    RESPONDER_GRANT: ERROR,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: RESPONDER_ACTIVE_LONG_PRESS_START\n  },\n  ERROR: {\n    DELAY: NOT_RESPONDER,\n    RESPONDER_GRANT: RESPONDER_INACTIVE_PRESS_START,\n    RESPONDER_RELEASE: NOT_RESPONDER,\n    RESPONDER_TERMINATED: NOT_RESPONDER,\n    LONG_PRESS_DETECTED: NOT_RESPONDER\n  }\n});\n\nvar isActiveSignal = function isActiveSignal(signal) {\n  return signal === RESPONDER_ACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_LONG_PRESS_START;\n};\n\nvar isPressStartSignal = function isPressStartSignal(signal) {\n  return signal === RESPONDER_INACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_PRESS_START || signal === RESPONDER_ACTIVE_LONG_PRESS_START;\n};\n\nvar isTerminalSignal = function isTerminalSignal(signal) {\n  return signal === RESPONDER_TERMINATED || signal === RESPONDER_RELEASE;\n};\n\nvar isValidKeyPress = function isValidKeyPress(event) {\n  var key = event.key;\n  var target = event.currentTarget;\n  var role = target.getAttribute('role');\n  var isSpacebar = key === ' ' || key === 'Spacebar';\n  return !event.repeat && (key === 'Enter' || isSpacebar && (role === 'button' || role === 'menuitem'));\n};\n\nvar DEFAULT_LONG_PRESS_DELAY_MS = 450; // 500 - 50\n\nvar DEFAULT_PRESS_DELAY_MS = 50;\n/**\n * =========================== PressResponder Tutorial ===========================\n *\n * The `PressResponder` class helps you create press interactions by analyzing the\n * geometry of elements and observing when another responder (e.g. ScrollView)\n * has stolen the touch lock. It offers hooks for your component to provide\n * interaction feedback to the user:\n *\n * - When a press has activated (e.g. highlight an element)\n * - When a press has deactivated (e.g. un-highlight an element)\n * - When a press sould trigger an action, meaning it activated and deactivated\n *   while within the geometry of the element without the lock being stolen.\n *\n * A high quality interaction isn't as simple as you might think. There should\n * be a slight delay before activation. Moving your finger beyond an element's\n * bounds should trigger deactivation, but moving the same finger back within an\n * element's bounds should trigger reactivation.\n *\n * In order to use `PressResponder`, do the following:\n *\n *     const pressResponder = new PressResponder(config);\n *\n * 2. Choose the rendered component who should collect the press events. On that\n *    element, spread `pressability.getEventHandlers()` into its props.\n *\n *    return (\n *      <View {...this.state.pressResponder.getEventHandlers()} />\n *    );\n *\n * 3. Reset `PressResponder` when your component unmounts.\n *\n *    componentWillUnmount() {\n *      this.state.pressResponder.reset();\n *    }\n *\n * ==================== Implementation Details ====================\n *\n * `PressResponder` only assumes that there exists a `HitRect` node. The `PressRect`\n * is an abstract box that is extended beyond the `HitRect`.\n *\n * # Geometry\n *\n *  ┌────────────────────────┐\n *  │  ┌──────────────────┐  │ - Presses start anywhere within `HitRect`.\n *  │  │  ┌────────────┐  │  │\n *  │  │  │ VisualRect │  │  │\n *  │  │  └────────────┘  │  │ - When pressed down for sufficient amount of time\n *  │  │    HitRect       │  │   before letting up, `VisualRect` activates.\n *  │  └──────────────────┘  │\n *  │       Out Region   o   │\n *  └────────────────────│───┘\n *                       └────── When the press is released outside the `HitRect`,\n *                               the responder is NOT eligible for a \"press\".\n *\n * # State Machine\n *\n * ┌───────────────┐ ◀──── RESPONDER_RELEASE\n * │ NOT_RESPONDER │\n * └───┬───────────┘ ◀──── RESPONDER_TERMINATED\n *     │\n *     │ RESPONDER_GRANT (HitRect)\n *     │\n *     ▼\n * ┌─────────────────────┐          ┌───────────────────┐              ┌───────────────────┐\n * │ RESPONDER_INACTIVE_ │  DELAY   │ RESPONDER_ACTIVE_ │  T + DELAY   │ RESPONDER_ACTIVE_ │\n * │ PRESS_START         ├────────▶ │ PRESS_START       ├────────────▶ │ LONG_PRESS_START  │\n * └─────────────────────┘          └───────────────────┘              └───────────────────┘\n *\n * T + DELAY => LONG_PRESS_DELAY + DELAY\n *\n * Not drawn are the side effects of each transition. The most important side\n * effect is the invocation of `onLongPress`. Only when the browser produces a\n * `click` event is `onPress` invoked.\n */\n\nvar PressResponder =\n/*#__PURE__*/\nfunction () {\n  function PressResponder(config) {\n    this._eventHandlers = null;\n    this._isPointerTouch = false;\n    this._longPressDelayTimeout = null;\n    this._longPressDispatched = false;\n    this._pressDelayTimeout = null;\n    this._pressOutDelayTimeout = null;\n    this._touchState = NOT_RESPONDER;\n    this.configure(config);\n  }\n\n  var _proto = PressResponder.prototype;\n\n  _proto.configure = function configure(config) {\n    this._config = config;\n  }\n  /**\n   * Resets any pending timers. This should be called on unmount.\n   */\n  ;\n\n  _proto.reset = function reset() {\n    this._cancelLongPressDelayTimeout();\n\n    this._cancelPressDelayTimeout();\n\n    this._cancelPressOutDelayTimeout();\n  }\n  /**\n   * Returns a set of props to spread into the interactive element.\n   */\n  ;\n\n  _proto.getEventHandlers = function getEventHandlers() {\n    if (this._eventHandlers == null) {\n      this._eventHandlers = this._createEventHandlers();\n    }\n\n    return this._eventHandlers;\n  };\n\n  _proto._createEventHandlers = function _createEventHandlers() {\n    var _this = this;\n\n    var start = function start(event, shouldDelay) {\n      event.persist();\n\n      _this._cancelPressOutDelayTimeout();\n\n      _this._longPressDispatched = false;\n      _this._responder = event.currentTarget;\n      _this._selectionTerminated = false;\n      _this._touchState = NOT_RESPONDER;\n      _this._isPointerTouch = event.nativeEvent.type === 'touchstart';\n\n      _this._receiveSignal(RESPONDER_GRANT, event);\n\n      var delayPressStart = normalizeDelay(_this._config.delayPressStart, 0, DEFAULT_PRESS_DELAY_MS);\n\n      if (shouldDelay !== false && delayPressStart > 0) {\n        _this._pressDelayTimeout = setTimeout(function () {\n          _this._receiveSignal(DELAY, event);\n        }, delayPressStart);\n      } else {\n        _this._receiveSignal(DELAY, event);\n      }\n\n      var delayLongPress = normalizeDelay(_this._config.delayLongPress, 10, DEFAULT_LONG_PRESS_DELAY_MS);\n      _this._longPressDelayTimeout = setTimeout(function () {\n        _this._handleLongPress(event);\n      }, delayLongPress + delayPressStart);\n    };\n\n    var end = function end(event) {\n      _this._receiveSignal(RESPONDER_RELEASE, event);\n    };\n\n    var keyupHandler = function keyupHandler(event) {\n      if (_this._touchState !== NOT_RESPONDER) {\n        end(event);\n        document.removeEventListener('keyup', keyupHandler);\n      }\n    };\n\n    return {\n      onStartShouldSetResponder: function onStartShouldSetResponder() {\n        var disabled = _this._config.disabled;\n\n        if (disabled == null) {\n          return true;\n        }\n\n        return !disabled;\n      },\n      onKeyDown: function onKeyDown(event) {\n        if (isValidKeyPress(event)) {\n          if (_this._touchState === NOT_RESPONDER) {\n            start(event, false); // Listen to 'keyup' on document to account for situations where\n            // focus is moved to another element during 'keydown'.\n\n            document.addEventListener('keyup', keyupHandler);\n          }\n\n          event.stopPropagation();\n        }\n      },\n      onResponderGrant: function onResponderGrant(event) {\n        return start(event);\n      },\n      onResponderMove: function onResponderMove(event) {\n        if (_this._config.onPressMove != null) {\n          _this._config.onPressMove(event);\n        }\n\n        var touch = getTouchFromResponderEvent(event);\n\n        if (_this._touchActivatePosition != null) {\n          var deltaX = _this._touchActivatePosition.pageX - touch.pageX;\n          var deltaY = _this._touchActivatePosition.pageY - touch.pageY;\n\n          if (Math.hypot(deltaX, deltaY) > 10) {\n            _this._cancelLongPressDelayTimeout();\n          }\n        }\n      },\n      onResponderRelease: function onResponderRelease(event) {\n        return end(event);\n      },\n      onResponderTerminate: function onResponderTerminate(event) {\n        if (event.nativeEvent.type === 'selectionchange') {\n          _this._selectionTerminated = true;\n        }\n\n        _this._receiveSignal(RESPONDER_TERMINATED, event);\n      },\n      onResponderTerminationRequest: function onResponderTerminationRequest(event) {\n        var _this$_config = _this._config,\n            cancelable = _this$_config.cancelable,\n            disabled = _this$_config.disabled,\n            onLongPress = _this$_config.onLongPress; // If `onLongPress` is provided, don't terminate on `contextmenu` as default\n        // behavior will be prevented for non-mouse pointers.\n\n        if (!disabled && onLongPress != null && _this._isPointerTouch && event.nativeEvent.type === 'contextmenu') {\n          return false;\n        }\n\n        if (cancelable == null) {\n          return true;\n        }\n\n        return cancelable;\n      },\n      // NOTE: this diverges from react-native in 3 significant ways:\n      // * The `onPress` callback is not connected to the responder system (the native\n      //  `click` event must be used but is dispatched in many scenarios where no pointers\n      //   are on the screen.) Therefore, it's possible for `onPress` to be called without\n      //   `onPress{Start,End}` being called first.\n      // * The `onPress` callback is only be called on the first ancestor of the native\n      //   `click` target that is using the PressResponder.\n      // * The event's `nativeEvent` is a `MouseEvent` not a `TouchEvent`.\n      onClick: function onClick(event) {\n        var _this$_config2 = _this._config,\n            disabled = _this$_config2.disabled,\n            onPress = _this$_config2.onPress;\n\n        if (!disabled) {\n          // If long press dispatched, cancel default click behavior.\n          // If the responder terminated because text was selected during the gesture,\n          // cancel the default click behavior.\n          if (_this._longPressDispatched || _this._selectionTerminated) {\n            event.preventDefault();\n          } else if (onPress != null && event.ctrlKey === false && event.altKey === false) {\n            onPress(event);\n          }\n        }\n\n        event.stopPropagation();\n      },\n      // If `onLongPress` is provided and a touch pointer is being used, prevent the\n      // default context menu from opening.\n      onContextMenu: function onContextMenu(event) {\n        var _this$_config3 = _this._config,\n            disabled = _this$_config3.disabled,\n            onLongPress = _this$_config3.onLongPress;\n\n        if (!disabled && onLongPress != null && _this._isPointerTouch && !event.defaultPrevented) {\n          event.preventDefault();\n        }\n\n        event.stopPropagation();\n      }\n    };\n  }\n  /**\n   * Receives a state machine signal, performs side effects of the transition\n   * and stores the new state. Validates the transition as well.\n   */\n  ;\n\n  _proto._receiveSignal = function _receiveSignal(signal, event) {\n    var prevState = this._touchState;\n    var nextState = null;\n\n    if (Transitions[prevState] != null) {\n      nextState = Transitions[prevState][signal];\n    }\n\n    if (this._responder == null && signal === RESPONDER_RELEASE) {\n      return;\n    }\n\n    if (nextState == null || nextState === ERROR) {\n      console.error(\"PressResponder: Invalid signal \" + signal + \" for state \" + prevState + \" on responder\");\n    } else if (prevState !== nextState) {\n      this._performTransitionSideEffects(prevState, nextState, signal, event);\n\n      this._touchState = nextState;\n    }\n  }\n  /**\n   * Performs a transition between touchable states and identify any activations\n   * or deactivations (and callback invocations).\n   */\n  ;\n\n  _proto._performTransitionSideEffects = function _performTransitionSideEffects(prevState, nextState, signal, event) {\n    if (isTerminalSignal(signal)) {\n      this._isPointerTouch = false;\n      this._touchActivatePosition = null;\n\n      this._cancelLongPressDelayTimeout();\n    }\n\n    if (isPressStartSignal(prevState) && signal === LONG_PRESS_DETECTED) {\n      var onLongPress = this._config.onLongPress; // Long press is not supported for keyboards because 'click' can be dispatched\n      // immediately (and multiple times) after 'keydown'.\n\n      if (onLongPress != null && event.nativeEvent.key == null) {\n        onLongPress(event);\n        this._longPressDispatched = true;\n      }\n    }\n\n    var isPrevActive = isActiveSignal(prevState);\n    var isNextActive = isActiveSignal(nextState);\n\n    if (!isPrevActive && isNextActive) {\n      this._activate(event);\n    } else if (isPrevActive && !isNextActive) {\n      this._deactivate(event);\n    }\n\n    if (isPressStartSignal(prevState) && signal === RESPONDER_RELEASE) {\n      var _this$_config4 = this._config,\n          _onLongPress = _this$_config4.onLongPress,\n          onPress = _this$_config4.onPress;\n\n      if (onPress != null) {\n        var isPressCanceledByLongPress = _onLongPress != null && prevState === RESPONDER_ACTIVE_LONG_PRESS_START;\n\n        if (!isPressCanceledByLongPress) {\n          // If we never activated (due to delays), activate and deactivate now.\n          if (!isNextActive && !isPrevActive) {\n            this._activate(event);\n\n            this._deactivate(event);\n          }\n        }\n      }\n    }\n\n    this._cancelPressDelayTimeout();\n  };\n\n  _proto._activate = function _activate(event) {\n    var _this$_config5 = this._config,\n        onPressChange = _this$_config5.onPressChange,\n        onPressStart = _this$_config5.onPressStart;\n    var touch = getTouchFromResponderEvent(event);\n    this._touchActivatePosition = {\n      pageX: touch.pageX,\n      pageY: touch.pageY\n    };\n\n    if (onPressStart != null) {\n      onPressStart(event);\n    }\n\n    if (onPressChange != null) {\n      onPressChange(true);\n    }\n  };\n\n  _proto._deactivate = function _deactivate(event) {\n    var _this$_config6 = this._config,\n        onPressChange = _this$_config6.onPressChange,\n        onPressEnd = _this$_config6.onPressEnd;\n\n    function end() {\n      if (onPressEnd != null) {\n        onPressEnd(event);\n      }\n\n      if (onPressChange != null) {\n        onPressChange(false);\n      }\n    }\n\n    var delayPressEnd = normalizeDelay(this._config.delayPressEnd);\n\n    if (delayPressEnd > 0) {\n      this._pressOutDelayTimeout = setTimeout(function () {\n        end();\n      }, delayPressEnd);\n    } else {\n      end();\n    }\n  };\n\n  _proto._handleLongPress = function _handleLongPress(event) {\n    if (this._touchState === RESPONDER_ACTIVE_PRESS_START || this._touchState === RESPONDER_ACTIVE_LONG_PRESS_START) {\n      this._receiveSignal(LONG_PRESS_DETECTED, event);\n    }\n  };\n\n  _proto._cancelLongPressDelayTimeout = function _cancelLongPressDelayTimeout() {\n    if (this._longPressDelayTimeout != null) {\n      clearTimeout(this._longPressDelayTimeout);\n      this._longPressDelayTimeout = null;\n    }\n  };\n\n  _proto._cancelPressDelayTimeout = function _cancelPressDelayTimeout() {\n    if (this._pressDelayTimeout != null) {\n      clearTimeout(this._pressDelayTimeout);\n      this._pressDelayTimeout = null;\n    }\n  };\n\n  _proto._cancelPressOutDelayTimeout = function _cancelPressOutDelayTimeout() {\n    if (this._pressOutDelayTimeout != null) {\n      clearTimeout(this._pressOutDelayTimeout);\n      this._pressOutDelayTimeout = null;\n    }\n  };\n\n  return PressResponder;\n}();\n\nexports.default = PressResponder;\n\nfunction normalizeDelay(delay, min, fallback) {\n  if (min === void 0) {\n    min = 0;\n  }\n\n  if (fallback === void 0) {\n    fallback = 0;\n  }\n\n  return Math.max(min, delay !== null && delay !== void 0 ? delay : fallback);\n}\n\nfunction getTouchFromResponderEvent(event) {\n  var _event$nativeEvent = event.nativeEvent,\n      changedTouches = _event$nativeEvent.changedTouches,\n      touches = _event$nativeEvent.touches;\n\n  if (touches != null && touches.length > 0) {\n    return touches[0];\n  }\n\n  if (changedTouches != null && changedTouches.length > 0) {\n    return changedTouches[0];\n  }\n\n  return event.nativeEvent;\n}\n\nmodule.exports = exports.default;"]},"metadata":{},"sourceType":"module"}