{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _Dimensions = _interopRequireDefault(require(\"../../exports/Dimensions\"));\n\nvar _findNodeHandle = _interopRequireDefault(require(\"../../exports/findNodeHandle\"));\n\nvar _invariant = _interopRequireDefault(require(\"fbjs/lib/invariant\"));\n\nvar _Platform = _interopRequireDefault(require(\"../../exports/Platform\"));\n\nvar _TextInputState = _interopRequireDefault(require(\"../TextInputState\"));\n\nvar _UIManager = _interopRequireDefault(require(\"../../exports/UIManager\"));\n\nvar _warning = _interopRequireDefault(require(\"fbjs/lib/warning\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n/**\n * Copyright (c) Nicolas Gallagher.\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/**\n * Mixin that can be integrated in order to handle scrolling that plays well\n * with `ResponderEventPlugin`. Integrate with your platform specific scroll\n * views, or even your custom built (every-frame animating) scroll views so that\n * all of these systems play well with the `ResponderEventPlugin`.\n *\n * iOS scroll event timing nuances:\n * ===============================\n *\n *\n * Scrolling without bouncing, if you touch down:\n * -------------------------------\n *\n * 1. `onMomentumScrollBegin` (when animation begins after letting up)\n *    ... physical touch starts ...\n * 2. `onTouchStartCapture`   (when you press down to stop the scroll)\n * 3. `onTouchStart`          (same, but bubble phase)\n * 4. `onResponderRelease`    (when lifting up - you could pause forever before * lifting)\n * 5. `onMomentumScrollEnd`\n *\n *\n * Scrolling with bouncing, if you touch down:\n * -------------------------------\n *\n * 1. `onMomentumScrollBegin` (when animation begins after letting up)\n *    ... bounce begins ...\n *    ... some time elapses ...\n *    ... physical touch during bounce ...\n * 2. `onMomentumScrollEnd`   (Makes no sense why this occurs first during bounce)\n * 3. `onTouchStartCapture`   (immediately after `onMomentumScrollEnd`)\n * 4. `onTouchStart`          (same, but bubble phase)\n * 5. `onTouchEnd`            (You could hold the touch start for a long time)\n * 6. `onMomentumScrollBegin` (When releasing the view starts bouncing back)\n *\n * So when we receive an `onTouchStart`, how can we tell if we are touching\n * *during* an animation (which then causes the animation to stop)? The only way\n * to tell is if the `touchStart` occurred immediately after the\n * `onMomentumScrollEnd`.\n *\n * This is abstracted out for you, so you can just call this.scrollResponderIsAnimating() if\n * necessary\n *\n * `ScrollResponder` also includes logic for blurring a currently focused input\n * if one is focused while scrolling. The `ScrollResponder` is a natural place\n * to put this logic since it can support not dismissing the keyboard while\n * scrolling, unless a recognized \"tap\"-like gesture has occurred.\n *\n * The public lifecycle API includes events for keyboard interaction, responder\n * interaction, and scrolling (among others). The keyboard callbacks\n * `onKeyboardWill/Did/*` are *global* events, but are invoked on scroll\n * responder's props so that you can guarantee that the scroll responder's\n * internal state has been updated accordingly (and deterministically) by\n * the time the props callbacks are invoke. Otherwise, you would always wonder\n * if the scroll responder is currently in a state where it recognizes new\n * keyboard positions etc. If coordinating scrolling with keyboard movement,\n * *always* use these hooks instead of listening to your own global keyboard\n * events.\n *\n * Public keyboard lifecycle API: (props callbacks)\n *\n * Standard Keyboard Appearance Sequence:\n *\n *   this.props.onKeyboardWillShow\n *   this.props.onKeyboardDidShow\n *\n * `onScrollResponderKeyboardDismissed` will be invoked if an appropriate\n * tap inside the scroll responder's scrollable region was responsible\n * for the dismissal of the keyboard. There are other reasons why the\n * keyboard could be dismissed.\n *\n *   this.props.onScrollResponderKeyboardDismissed\n *\n * Standard Keyboard Hide Sequence:\n *\n *   this.props.onKeyboardWillHide\n *   this.props.onKeyboardDidHide\n */\n\n\nvar emptyObject = {};\nvar IS_ANIMATING_TOUCH_START_THRESHOLD_MS = 16;\nvar ScrollResponderMixin = {\n  // mixins: [Subscribable.Mixin],\n  scrollResponderMixinGetInitialState: function scrollResponderMixinGetInitialState() {\n    return {\n      isTouching: false,\n      lastMomentumScrollBeginTime: 0,\n      lastMomentumScrollEndTime: 0,\n      // Reset to false every time becomes responder. This is used to:\n      // - Determine if the scroll view has been scrolled and therefore should\n      // refuse to give up its responder lock.\n      // - Determine if releasing should dismiss the keyboard when we are in\n      // tap-to-dismiss mode (!this.props.keyboardShouldPersistTaps).\n      observedScrollSinceBecomingResponder: false,\n      becameResponderWhileAnimating: false\n    };\n  },\n\n  /**\n   * Invoke this from an `onScroll` event.\n   */\n  scrollResponderHandleScrollShouldSetResponder: function scrollResponderHandleScrollShouldSetResponder() {\n    return this.state.isTouching;\n  },\n\n  /**\n   * Merely touch starting is not sufficient for a scroll view to become the\n   * responder. Being the \"responder\" means that the very next touch move/end\n   * event will result in an action/movement.\n   *\n   * Invoke this from an `onStartShouldSetResponder` event.\n   *\n   * `onStartShouldSetResponder` is used when the next move/end will trigger\n   * some UI movement/action, but when you want to yield priority to views\n   * nested inside of the view.\n   *\n   * There may be some cases where scroll views actually should return `true`\n   * from `onStartShouldSetResponder`: Any time we are detecting a standard tap\n   * that gives priority to nested views.\n   *\n   * - If a single tap on the scroll view triggers an action such as\n   *   recentering a map style view yet wants to give priority to interaction\n   *   views inside (such as dropped pins or labels), then we would return true\n   *   from this method when there is a single touch.\n   *\n   * - Similar to the previous case, if a two finger \"tap\" should trigger a\n   *   zoom, we would check the `touches` count, and if `>= 2`, we would return\n   *   true.\n   *\n   */\n  scrollResponderHandleStartShouldSetResponder: function scrollResponderHandleStartShouldSetResponder() {\n    return false;\n  },\n\n  /**\n   * There are times when the scroll view wants to become the responder\n   * (meaning respond to the next immediate `touchStart/touchEnd`), in a way\n   * that *doesn't* give priority to nested views (hence the capture phase):\n   *\n   * - Currently animating.\n   * - Tapping anywhere that is not the focused input, while the keyboard is\n   *   up (which should dismiss the keyboard).\n   *\n   * Invoke this from an `onStartShouldSetResponderCapture` event.\n   */\n  scrollResponderHandleStartShouldSetResponderCapture: function scrollResponderHandleStartShouldSetResponderCapture(e) {\n    // First see if we want to eat taps while the keyboard is up\n    // var currentlyFocusedTextInput = TextInputState.currentlyFocusedField();\n    // if (!this.props.keyboardShouldPersistTaps &&\n    //   currentlyFocusedTextInput != null &&\n    //   e.target !== currentlyFocusedTextInput) {\n    //   return true;\n    // }\n    return this.scrollResponderIsAnimating();\n  },\n\n  /**\n   * Invoke this from an `onResponderReject` event.\n   *\n   * Some other element is not yielding its role as responder. Normally, we'd\n   * just disable the `UIScrollView`, but a touch has already began on it, the\n   * `UIScrollView` will not accept being disabled after that. The easiest\n   * solution for now is to accept the limitation of disallowing this\n   * altogether. To improve this, find a way to disable the `UIScrollView` after\n   * a touch has already started.\n   */\n  scrollResponderHandleResponderReject: function scrollResponderHandleResponderReject() {\n    (0, _warning[\"default\"])(false, \"ScrollView doesn't take rejection well - scrolls anyway\");\n  },\n\n  /**\n   * We will allow the scroll view to give up its lock iff it acquired the lock\n   * during an animation. This is a very useful default that happens to satisfy\n   * many common user experiences.\n   *\n   * - Stop a scroll on the left edge, then turn that into an outer view's\n   *   backswipe.\n   * - Stop a scroll mid-bounce at the top, continue pulling to have the outer\n   *   view dismiss.\n   * - However, without catching the scroll view mid-bounce (while it is\n   *   motionless), if you drag far enough for the scroll view to become\n   *   responder (and therefore drag the scroll view a bit), any backswipe\n   *   navigation of a swipe gesture higher in the view hierarchy, should be\n   *   rejected.\n   */\n  scrollResponderHandleTerminationRequest: function scrollResponderHandleTerminationRequest() {\n    return !this.state.observedScrollSinceBecomingResponder;\n  },\n\n  /**\n   * Invoke this from an `onTouchEnd` event.\n   *\n   * @param {SyntheticEvent} e Event.\n   */\n  scrollResponderHandleTouchEnd: function scrollResponderHandleTouchEnd(e) {\n    var nativeEvent = e.nativeEvent;\n    this.state.isTouching = nativeEvent.touches.length !== 0;\n    this.props.onTouchEnd && this.props.onTouchEnd(e);\n  },\n\n  /**\n   * Invoke this from an `onResponderRelease` event.\n   */\n  scrollResponderHandleResponderRelease: function scrollResponderHandleResponderRelease(e) {\n    this.props.onResponderRelease && this.props.onResponderRelease(e); // By default scroll views will unfocus a textField\n    // if another touch occurs outside of it\n\n    var currentlyFocusedTextInput = _TextInputState[\"default\"].currentlyFocusedField();\n\n    if (!this.props.keyboardShouldPersistTaps && currentlyFocusedTextInput != null && e.target !== currentlyFocusedTextInput && !this.state.observedScrollSinceBecomingResponder && !this.state.becameResponderWhileAnimating) {\n      this.props.onScrollResponderKeyboardDismissed && this.props.onScrollResponderKeyboardDismissed(e);\n\n      _TextInputState[\"default\"].blurTextInput(currentlyFocusedTextInput);\n    }\n  },\n  scrollResponderHandleScroll: function scrollResponderHandleScroll(e) {\n    this.state.observedScrollSinceBecomingResponder = true;\n    this.props.onScroll && this.props.onScroll(e);\n  },\n\n  /**\n   * Invoke this from an `onResponderGrant` event.\n   */\n  scrollResponderHandleResponderGrant: function scrollResponderHandleResponderGrant(e) {\n    this.state.observedScrollSinceBecomingResponder = false;\n    this.props.onResponderGrant && this.props.onResponderGrant(e);\n    this.state.becameResponderWhileAnimating = this.scrollResponderIsAnimating();\n  },\n\n  /**\n   * Unfortunately, `onScrollBeginDrag` also fires when *stopping* the scroll\n   * animation, and there's not an easy way to distinguish a drag vs. stopping\n   * momentum.\n   *\n   * Invoke this from an `onScrollBeginDrag` event.\n   */\n  scrollResponderHandleScrollBeginDrag: function scrollResponderHandleScrollBeginDrag(e) {\n    this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);\n  },\n\n  /**\n   * Invoke this from an `onScrollEndDrag` event.\n   */\n  scrollResponderHandleScrollEndDrag: function scrollResponderHandleScrollEndDrag(e) {\n    this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);\n  },\n\n  /**\n   * Invoke this from an `onMomentumScrollBegin` event.\n   */\n  scrollResponderHandleMomentumScrollBegin: function scrollResponderHandleMomentumScrollBegin(e) {\n    this.state.lastMomentumScrollBeginTime = Date.now();\n    this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);\n  },\n\n  /**\n   * Invoke this from an `onMomentumScrollEnd` event.\n   */\n  scrollResponderHandleMomentumScrollEnd: function scrollResponderHandleMomentumScrollEnd(e) {\n    this.state.lastMomentumScrollEndTime = Date.now();\n    this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);\n  },\n\n  /**\n   * Invoke this from an `onTouchStart` event.\n   *\n   * Since we know that the `SimpleEventPlugin` occurs later in the plugin\n   * order, after `ResponderEventPlugin`, we can detect that we were *not*\n   * permitted to be the responder (presumably because a contained view became\n   * responder). The `onResponderReject` won't fire in that case - it only\n   * fires when a *current* responder rejects our request.\n   *\n   * @param {SyntheticEvent} e Touch Start event.\n   */\n  scrollResponderHandleTouchStart: function scrollResponderHandleTouchStart(e) {\n    this.state.isTouching = true;\n    this.props.onTouchStart && this.props.onTouchStart(e);\n  },\n\n  /**\n   * Invoke this from an `onTouchMove` event.\n   *\n   * Since we know that the `SimpleEventPlugin` occurs later in the plugin\n   * order, after `ResponderEventPlugin`, we can detect that we were *not*\n   * permitted to be the responder (presumably because a contained view became\n   * responder). The `onResponderReject` won't fire in that case - it only\n   * fires when a *current* responder rejects our request.\n   *\n   * @param {SyntheticEvent} e Touch Start event.\n   */\n  scrollResponderHandleTouchMove: function scrollResponderHandleTouchMove(e) {\n    this.props.onTouchMove && this.props.onTouchMove(e);\n  },\n\n  /**\n   * A helper function for this class that lets us quickly determine if the\n   * view is currently animating. This is particularly useful to know when\n   * a touch has just started or ended.\n   */\n  scrollResponderIsAnimating: function scrollResponderIsAnimating() {\n    var now = Date.now();\n    var timeSinceLastMomentumScrollEnd = now - this.state.lastMomentumScrollEndTime;\n    var isAnimating = timeSinceLastMomentumScrollEnd < IS_ANIMATING_TOUCH_START_THRESHOLD_MS || this.state.lastMomentumScrollEndTime < this.state.lastMomentumScrollBeginTime;\n    return isAnimating;\n  },\n\n  /**\n   * Returns the node that represents native view that can be scrolled.\n   * Components can pass what node to use by defining a `getScrollableNode`\n   * function otherwise `this` is used.\n   */\n  scrollResponderGetScrollableNode: function scrollResponderGetScrollableNode() {\n    return this.getScrollableNode ? this.getScrollableNode() : (0, _findNodeHandle[\"default\"])(this);\n  },\n\n  /**\n   * A helper function to scroll to a specific point in the scrollview.\n   * This is currently used to help focus on child textviews, but can also\n   * be used to quickly scroll to any element we want to focus. Syntax:\n   *\n   * scrollResponderScrollTo(options: {x: number = 0; y: number = 0; animated: boolean = true})\n   *\n   * Note: The weird argument signature is due to the fact that, for historical reasons,\n   * the function also accepts separate arguments as as alternative to the options object.\n   * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.\n   */\n  scrollResponderScrollTo: function scrollResponderScrollTo(x, y, animated) {\n    if (typeof x === 'number') {\n      console.warn('`scrollResponderScrollTo(x, y, animated)` is deprecated. Use `scrollResponderScrollTo({x: 5, y: 5, animated: true})` instead.');\n    } else {\n      var _ref = x || emptyObject;\n\n      x = _ref.x;\n      y = _ref.y;\n      animated = _ref.animated;\n    }\n\n    var node = this.scrollResponderGetScrollableNode();\n    var left = x || 0;\n    var top = y || 0;\n\n    if (typeof node.scroll === 'function') {\n      node.scroll({\n        top: top,\n        left: left,\n        behavior: !animated ? 'auto' : 'smooth'\n      });\n    } else {\n      node.scrollLeft = left;\n      node.scrollTop = top;\n    }\n  },\n\n  /**\n   * A helper function to zoom to a specific rect in the scrollview. The argument has the shape\n   * {x: number; y: number; width: number; height: number; animated: boolean = true}\n   *\n   * @platform ios\n   */\n  scrollResponderZoomTo: function scrollResponderZoomTo(rect, animated) // deprecated, put this inside the rect argument instead\n  {\n    if (_Platform[\"default\"].OS !== 'ios') {\n      (0, _invariant[\"default\"])('zoomToRect is not implemented');\n    }\n  },\n\n  /**\n   * Displays the scroll indicators momentarily.\n   */\n  scrollResponderFlashScrollIndicators: function scrollResponderFlashScrollIndicators() {},\n\n  /**\n   * This method should be used as the callback to onFocus in a TextInputs'\n   * parent view. Note that any module using this mixin needs to return\n   * the parent view's ref in getScrollViewRef() in order to use this method.\n   * @param {any} nodeHandle The TextInput node handle\n   * @param {number} additionalOffset The scroll view's top \"contentInset\".\n   *        Default is 0.\n   * @param {bool} preventNegativeScrolling Whether to allow pulling the content\n   *        down to make it meet the keyboard's top. Default is false.\n   */\n  scrollResponderScrollNativeHandleToKeyboard: function scrollResponderScrollNativeHandleToKeyboard(nodeHandle, additionalOffset, preventNegativeScrollOffset) {\n    this.additionalScrollOffset = additionalOffset || 0;\n    this.preventNegativeScrollOffset = !!preventNegativeScrollOffset;\n\n    _UIManager[\"default\"].measureLayout(nodeHandle, (0, _findNodeHandle[\"default\"])(this.getInnerViewNode()), this.scrollResponderTextInputFocusError, this.scrollResponderInputMeasureAndScrollToKeyboard);\n  },\n\n  /**\n   * The calculations performed here assume the scroll view takes up the entire\n   * screen - even if has some content inset. We then measure the offsets of the\n   * keyboard, and compensate both for the scroll view's \"contentInset\".\n   *\n   * @param {number} left Position of input w.r.t. table view.\n   * @param {number} top Position of input w.r.t. table view.\n   * @param {number} width Width of the text input.\n   * @param {number} height Height of the text input.\n   */\n  scrollResponderInputMeasureAndScrollToKeyboard: function scrollResponderInputMeasureAndScrollToKeyboard(left, top, width, height) {\n    var keyboardScreenY = _Dimensions[\"default\"].get('window').height;\n\n    if (this.keyboardWillOpenTo) {\n      keyboardScreenY = this.keyboardWillOpenTo.endCoordinates.screenY;\n    }\n\n    var scrollOffsetY = top - keyboardScreenY + height + this.additionalScrollOffset; // By default, this can scroll with negative offset, pulling the content\n    // down so that the target component's bottom meets the keyboard's top.\n    // If requested otherwise, cap the offset at 0 minimum to avoid content\n    // shifting down.\n\n    if (this.preventNegativeScrollOffset) {\n      scrollOffsetY = Math.max(0, scrollOffsetY);\n    }\n\n    this.scrollResponderScrollTo({\n      x: 0,\n      y: scrollOffsetY,\n      animated: true\n    });\n    this.additionalOffset = 0;\n    this.preventNegativeScrollOffset = false;\n  },\n  scrollResponderTextInputFocusError: function scrollResponderTextInputFocusError(e) {\n    console.error('Error measuring text field: ', e);\n  },\n\n  /**\n   * `componentWillMount` is the closest thing to a  standard \"constructor\" for\n   * React components.\n   *\n   * The `keyboardWillShow` is called before input focus.\n   */\n  UNSAFE_componentWillMount: function UNSAFE_componentWillMount() {\n    this.keyboardWillOpenTo = null;\n    this.additionalScrollOffset = 0; // this.addListenerOn(RCTDeviceEventEmitter, 'keyboardWillShow', this.scrollResponderKeyboardWillShow);\n    // this.addListenerOn(RCTDeviceEventEmitter, 'keyboardWillHide', this.scrollResponderKeyboardWillHide);\n    // this.addListenerOn(RCTDeviceEventEmitter, 'keyboardDidShow', this.scrollResponderKeyboardDidShow);\n    // this.addListenerOn(RCTDeviceEventEmitter, 'keyboardDidHide', this.scrollResponderKeyboardDidHide);\n  },\n\n  /**\n   * Warning, this may be called several times for a single keyboard opening.\n   * It's best to store the information in this method and then take any action\n   * at a later point (either in `keyboardDidShow` or other).\n   *\n   * Here's the order that events occur in:\n   * - focus\n   * - willShow {startCoordinates, endCoordinates} several times\n   * - didShow several times\n   * - blur\n   * - willHide {startCoordinates, endCoordinates} several times\n   * - didHide several times\n   *\n   * The `ScrollResponder` providesModule callbacks for each of these events.\n   * Even though any user could have easily listened to keyboard events\n   * themselves, using these `props` callbacks ensures that ordering of events\n   * is consistent - and not dependent on the order that the keyboard events are\n   * subscribed to. This matters when telling the scroll view to scroll to where\n   * the keyboard is headed - the scroll responder better have been notified of\n   * the keyboard destination before being instructed to scroll to where the\n   * keyboard will be. Stick to the `ScrollResponder` callbacks, and everything\n   * will work.\n   *\n   * WARNING: These callbacks will fire even if a keyboard is displayed in a\n   * different navigation pane. Filter out the events to determine if they are\n   * relevant to you. (For example, only if you receive these callbacks after\n   * you had explicitly focused a node etc).\n   */\n  scrollResponderKeyboardWillShow: function scrollResponderKeyboardWillShow(e) {\n    this.keyboardWillOpenTo = e;\n    this.props.onKeyboardWillShow && this.props.onKeyboardWillShow(e);\n  },\n  scrollResponderKeyboardWillHide: function scrollResponderKeyboardWillHide(e) {\n    this.keyboardWillOpenTo = null;\n    this.props.onKeyboardWillHide && this.props.onKeyboardWillHide(e);\n  },\n  scrollResponderKeyboardDidShow: function scrollResponderKeyboardDidShow(e) {\n    // TODO(7693961): The event for DidShow is not available on iOS yet.\n    // Use the one from WillShow and do not assign.\n    if (e) {\n      this.keyboardWillOpenTo = e;\n    }\n\n    this.props.onKeyboardDidShow && this.props.onKeyboardDidShow(e);\n  },\n  scrollResponderKeyboardDidHide: function scrollResponderKeyboardDidHide(e) {\n    this.keyboardWillOpenTo = null;\n    this.props.onKeyboardDidHide && this.props.onKeyboardDidHide(e);\n  }\n};\nvar ScrollResponder = {\n  Mixin: ScrollResponderMixin\n};\nvar _default = ScrollResponder;\nexports[\"default\"] = _default;\nmodule.exports = exports[\"default\"];\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = __webpack_module__.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      __webpack_module__.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      import.meta.webpackHot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          __webpack_module__.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        __webpack_module__.hot.invalidate();\n      }\n    }\n  }\n})();","map":{"version":3,"sources":["/Users/jun/Desktop/dev/react-practice/with-react-native-web-app/node_modules/react-native-web/dist/cjs/modules/ScrollResponder/index.js"],"names":["exports","_Dimensions","_interopRequireDefault","require","_findNodeHandle","_invariant","_Platform","_TextInputState","_UIManager","_warning","obj","emptyObject","IS_ANIMATING_TOUCH_START_THRESHOLD_MS","ScrollResponderMixin","scrollResponderMixinGetInitialState","isTouching","lastMomentumScrollBeginTime","lastMomentumScrollEndTime","observedScrollSinceBecomingResponder","becameResponderWhileAnimating","scrollResponderHandleScrollShouldSetResponder","scrollResponderHandleStartShouldSetResponder","scrollResponderHandleStartShouldSetResponderCapture","scrollResponderHandleResponderReject","scrollResponderHandleTerminationRequest","scrollResponderHandleTouchEnd","nativeEvent","e","scrollResponderHandleResponderRelease","currentlyFocusedTextInput","scrollResponderHandleScroll","scrollResponderHandleResponderGrant","scrollResponderHandleScrollBeginDrag","scrollResponderHandleScrollEndDrag","scrollResponderHandleMomentumScrollBegin","Date","scrollResponderHandleMomentumScrollEnd","scrollResponderHandleTouchStart","scrollResponderHandleTouchMove","scrollResponderIsAnimating","now","timeSinceLastMomentumScrollEnd","isAnimating","scrollResponderGetScrollableNode","scrollResponderScrollTo","console","_ref","x","y","animated","node","left","top","behavior","scrollResponderZoomTo","scrollResponderFlashScrollIndicators","scrollResponderScrollNativeHandleToKeyboard","additionalOffset","scrollResponderInputMeasureAndScrollToKeyboard","keyboardScreenY","scrollOffsetY","Math","scrollResponderTextInputFocusError","UNSAFE_componentWillMount","scrollResponderKeyboardWillShow","scrollResponderKeyboardWillHide","scrollResponderKeyboardDidShow","scrollResponderKeyboardDidHide","ScrollResponder","Mixin","_default","module"],"mappings":"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","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _Dimensions = _interopRequireDefault(require(\"../../exports/Dimensions\"));\n\nvar _findNodeHandle = _interopRequireDefault(require(\"../../exports/findNodeHandle\"));\n\nvar _invariant = _interopRequireDefault(require(\"fbjs/lib/invariant\"));\n\nvar _Platform = _interopRequireDefault(require(\"../../exports/Platform\"));\n\nvar _TextInputState = _interopRequireDefault(require(\"../TextInputState\"));\n\nvar _UIManager = _interopRequireDefault(require(\"../../exports/UIManager\"));\n\nvar _warning = _interopRequireDefault(require(\"fbjs/lib/warning\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) Nicolas Gallagher.\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/**\n * Mixin that can be integrated in order to handle scrolling that plays well\n * with `ResponderEventPlugin`. Integrate with your platform specific scroll\n * views, or even your custom built (every-frame animating) scroll views so that\n * all of these systems play well with the `ResponderEventPlugin`.\n *\n * iOS scroll event timing nuances:\n * ===============================\n *\n *\n * Scrolling without bouncing, if you touch down:\n * -------------------------------\n *\n * 1. `onMomentumScrollBegin` (when animation begins after letting up)\n *    ... physical touch starts ...\n * 2. `onTouchStartCapture`   (when you press down to stop the scroll)\n * 3. `onTouchStart`          (same, but bubble phase)\n * 4. `onResponderRelease`    (when lifting up - you could pause forever before * lifting)\n * 5. `onMomentumScrollEnd`\n *\n *\n * Scrolling with bouncing, if you touch down:\n * -------------------------------\n *\n * 1. `onMomentumScrollBegin` (when animation begins after letting up)\n *    ... bounce begins ...\n *    ... some time elapses ...\n *    ... physical touch during bounce ...\n * 2. `onMomentumScrollEnd`   (Makes no sense why this occurs first during bounce)\n * 3. `onTouchStartCapture`   (immediately after `onMomentumScrollEnd`)\n * 4. `onTouchStart`          (same, but bubble phase)\n * 5. `onTouchEnd`            (You could hold the touch start for a long time)\n * 6. `onMomentumScrollBegin` (When releasing the view starts bouncing back)\n *\n * So when we receive an `onTouchStart`, how can we tell if we are touching\n * *during* an animation (which then causes the animation to stop)? The only way\n * to tell is if the `touchStart` occurred immediately after the\n * `onMomentumScrollEnd`.\n *\n * This is abstracted out for you, so you can just call this.scrollResponderIsAnimating() if\n * necessary\n *\n * `ScrollResponder` also includes logic for blurring a currently focused input\n * if one is focused while scrolling. The `ScrollResponder` is a natural place\n * to put this logic since it can support not dismissing the keyboard while\n * scrolling, unless a recognized \"tap\"-like gesture has occurred.\n *\n * The public lifecycle API includes events for keyboard interaction, responder\n * interaction, and scrolling (among others). The keyboard callbacks\n * `onKeyboardWill/Did/*` are *global* events, but are invoked on scroll\n * responder's props so that you can guarantee that the scroll responder's\n * internal state has been updated accordingly (and deterministically) by\n * the time the props callbacks are invoke. Otherwise, you would always wonder\n * if the scroll responder is currently in a state where it recognizes new\n * keyboard positions etc. If coordinating scrolling with keyboard movement,\n * *always* use these hooks instead of listening to your own global keyboard\n * events.\n *\n * Public keyboard lifecycle API: (props callbacks)\n *\n * Standard Keyboard Appearance Sequence:\n *\n *   this.props.onKeyboardWillShow\n *   this.props.onKeyboardDidShow\n *\n * `onScrollResponderKeyboardDismissed` will be invoked if an appropriate\n * tap inside the scroll responder's scrollable region was responsible\n * for the dismissal of the keyboard. There are other reasons why the\n * keyboard could be dismissed.\n *\n *   this.props.onScrollResponderKeyboardDismissed\n *\n * Standard Keyboard Hide Sequence:\n *\n *   this.props.onKeyboardWillHide\n *   this.props.onKeyboardDidHide\n */\nvar emptyObject = {};\nvar IS_ANIMATING_TOUCH_START_THRESHOLD_MS = 16;\nvar ScrollResponderMixin = {\n  // mixins: [Subscribable.Mixin],\n  scrollResponderMixinGetInitialState: function scrollResponderMixinGetInitialState() {\n    return {\n      isTouching: false,\n      lastMomentumScrollBeginTime: 0,\n      lastMomentumScrollEndTime: 0,\n      // Reset to false every time becomes responder. This is used to:\n      // - Determine if the scroll view has been scrolled and therefore should\n      // refuse to give up its responder lock.\n      // - Determine if releasing should dismiss the keyboard when we are in\n      // tap-to-dismiss mode (!this.props.keyboardShouldPersistTaps).\n      observedScrollSinceBecomingResponder: false,\n      becameResponderWhileAnimating: false\n    };\n  },\n\n  /**\n   * Invoke this from an `onScroll` event.\n   */\n  scrollResponderHandleScrollShouldSetResponder: function scrollResponderHandleScrollShouldSetResponder() {\n    return this.state.isTouching;\n  },\n\n  /**\n   * Merely touch starting is not sufficient for a scroll view to become the\n   * responder. Being the \"responder\" means that the very next touch move/end\n   * event will result in an action/movement.\n   *\n   * Invoke this from an `onStartShouldSetResponder` event.\n   *\n   * `onStartShouldSetResponder` is used when the next move/end will trigger\n   * some UI movement/action, but when you want to yield priority to views\n   * nested inside of the view.\n   *\n   * There may be some cases where scroll views actually should return `true`\n   * from `onStartShouldSetResponder`: Any time we are detecting a standard tap\n   * that gives priority to nested views.\n   *\n   * - If a single tap on the scroll view triggers an action such as\n   *   recentering a map style view yet wants to give priority to interaction\n   *   views inside (such as dropped pins or labels), then we would return true\n   *   from this method when there is a single touch.\n   *\n   * - Similar to the previous case, if a two finger \"tap\" should trigger a\n   *   zoom, we would check the `touches` count, and if `>= 2`, we would return\n   *   true.\n   *\n   */\n  scrollResponderHandleStartShouldSetResponder: function scrollResponderHandleStartShouldSetResponder() {\n    return false;\n  },\n\n  /**\n   * There are times when the scroll view wants to become the responder\n   * (meaning respond to the next immediate `touchStart/touchEnd`), in a way\n   * that *doesn't* give priority to nested views (hence the capture phase):\n   *\n   * - Currently animating.\n   * - Tapping anywhere that is not the focused input, while the keyboard is\n   *   up (which should dismiss the keyboard).\n   *\n   * Invoke this from an `onStartShouldSetResponderCapture` event.\n   */\n  scrollResponderHandleStartShouldSetResponderCapture: function scrollResponderHandleStartShouldSetResponderCapture(e) {\n    // First see if we want to eat taps while the keyboard is up\n    // var currentlyFocusedTextInput = TextInputState.currentlyFocusedField();\n    // if (!this.props.keyboardShouldPersistTaps &&\n    //   currentlyFocusedTextInput != null &&\n    //   e.target !== currentlyFocusedTextInput) {\n    //   return true;\n    // }\n    return this.scrollResponderIsAnimating();\n  },\n\n  /**\n   * Invoke this from an `onResponderReject` event.\n   *\n   * Some other element is not yielding its role as responder. Normally, we'd\n   * just disable the `UIScrollView`, but a touch has already began on it, the\n   * `UIScrollView` will not accept being disabled after that. The easiest\n   * solution for now is to accept the limitation of disallowing this\n   * altogether. To improve this, find a way to disable the `UIScrollView` after\n   * a touch has already started.\n   */\n  scrollResponderHandleResponderReject: function scrollResponderHandleResponderReject() {\n    (0, _warning.default)(false, \"ScrollView doesn't take rejection well - scrolls anyway\");\n  },\n\n  /**\n   * We will allow the scroll view to give up its lock iff it acquired the lock\n   * during an animation. This is a very useful default that happens to satisfy\n   * many common user experiences.\n   *\n   * - Stop a scroll on the left edge, then turn that into an outer view's\n   *   backswipe.\n   * - Stop a scroll mid-bounce at the top, continue pulling to have the outer\n   *   view dismiss.\n   * - However, without catching the scroll view mid-bounce (while it is\n   *   motionless), if you drag far enough for the scroll view to become\n   *   responder (and therefore drag the scroll view a bit), any backswipe\n   *   navigation of a swipe gesture higher in the view hierarchy, should be\n   *   rejected.\n   */\n  scrollResponderHandleTerminationRequest: function scrollResponderHandleTerminationRequest() {\n    return !this.state.observedScrollSinceBecomingResponder;\n  },\n\n  /**\n   * Invoke this from an `onTouchEnd` event.\n   *\n   * @param {SyntheticEvent} e Event.\n   */\n  scrollResponderHandleTouchEnd: function scrollResponderHandleTouchEnd(e) {\n    var nativeEvent = e.nativeEvent;\n    this.state.isTouching = nativeEvent.touches.length !== 0;\n    this.props.onTouchEnd && this.props.onTouchEnd(e);\n  },\n\n  /**\n   * Invoke this from an `onResponderRelease` event.\n   */\n  scrollResponderHandleResponderRelease: function scrollResponderHandleResponderRelease(e) {\n    this.props.onResponderRelease && this.props.onResponderRelease(e); // By default scroll views will unfocus a textField\n    // if another touch occurs outside of it\n\n    var currentlyFocusedTextInput = _TextInputState.default.currentlyFocusedField();\n\n    if (!this.props.keyboardShouldPersistTaps && currentlyFocusedTextInput != null && e.target !== currentlyFocusedTextInput && !this.state.observedScrollSinceBecomingResponder && !this.state.becameResponderWhileAnimating) {\n      this.props.onScrollResponderKeyboardDismissed && this.props.onScrollResponderKeyboardDismissed(e);\n\n      _TextInputState.default.blurTextInput(currentlyFocusedTextInput);\n    }\n  },\n  scrollResponderHandleScroll: function scrollResponderHandleScroll(e) {\n    this.state.observedScrollSinceBecomingResponder = true;\n    this.props.onScroll && this.props.onScroll(e);\n  },\n\n  /**\n   * Invoke this from an `onResponderGrant` event.\n   */\n  scrollResponderHandleResponderGrant: function scrollResponderHandleResponderGrant(e) {\n    this.state.observedScrollSinceBecomingResponder = false;\n    this.props.onResponderGrant && this.props.onResponderGrant(e);\n    this.state.becameResponderWhileAnimating = this.scrollResponderIsAnimating();\n  },\n\n  /**\n   * Unfortunately, `onScrollBeginDrag` also fires when *stopping* the scroll\n   * animation, and there's not an easy way to distinguish a drag vs. stopping\n   * momentum.\n   *\n   * Invoke this from an `onScrollBeginDrag` event.\n   */\n  scrollResponderHandleScrollBeginDrag: function scrollResponderHandleScrollBeginDrag(e) {\n    this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);\n  },\n\n  /**\n   * Invoke this from an `onScrollEndDrag` event.\n   */\n  scrollResponderHandleScrollEndDrag: function scrollResponderHandleScrollEndDrag(e) {\n    this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);\n  },\n\n  /**\n   * Invoke this from an `onMomentumScrollBegin` event.\n   */\n  scrollResponderHandleMomentumScrollBegin: function scrollResponderHandleMomentumScrollBegin(e) {\n    this.state.lastMomentumScrollBeginTime = Date.now();\n    this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);\n  },\n\n  /**\n   * Invoke this from an `onMomentumScrollEnd` event.\n   */\n  scrollResponderHandleMomentumScrollEnd: function scrollResponderHandleMomentumScrollEnd(e) {\n    this.state.lastMomentumScrollEndTime = Date.now();\n    this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);\n  },\n\n  /**\n   * Invoke this from an `onTouchStart` event.\n   *\n   * Since we know that the `SimpleEventPlugin` occurs later in the plugin\n   * order, after `ResponderEventPlugin`, we can detect that we were *not*\n   * permitted to be the responder (presumably because a contained view became\n   * responder). The `onResponderReject` won't fire in that case - it only\n   * fires when a *current* responder rejects our request.\n   *\n   * @param {SyntheticEvent} e Touch Start event.\n   */\n  scrollResponderHandleTouchStart: function scrollResponderHandleTouchStart(e) {\n    this.state.isTouching = true;\n    this.props.onTouchStart && this.props.onTouchStart(e);\n  },\n\n  /**\n   * Invoke this from an `onTouchMove` event.\n   *\n   * Since we know that the `SimpleEventPlugin` occurs later in the plugin\n   * order, after `ResponderEventPlugin`, we can detect that we were *not*\n   * permitted to be the responder (presumably because a contained view became\n   * responder). The `onResponderReject` won't fire in that case - it only\n   * fires when a *current* responder rejects our request.\n   *\n   * @param {SyntheticEvent} e Touch Start event.\n   */\n  scrollResponderHandleTouchMove: function scrollResponderHandleTouchMove(e) {\n    this.props.onTouchMove && this.props.onTouchMove(e);\n  },\n\n  /**\n   * A helper function for this class that lets us quickly determine if the\n   * view is currently animating. This is particularly useful to know when\n   * a touch has just started or ended.\n   */\n  scrollResponderIsAnimating: function scrollResponderIsAnimating() {\n    var now = Date.now();\n    var timeSinceLastMomentumScrollEnd = now - this.state.lastMomentumScrollEndTime;\n    var isAnimating = timeSinceLastMomentumScrollEnd < IS_ANIMATING_TOUCH_START_THRESHOLD_MS || this.state.lastMomentumScrollEndTime < this.state.lastMomentumScrollBeginTime;\n    return isAnimating;\n  },\n\n  /**\n   * Returns the node that represents native view that can be scrolled.\n   * Components can pass what node to use by defining a `getScrollableNode`\n   * function otherwise `this` is used.\n   */\n  scrollResponderGetScrollableNode: function scrollResponderGetScrollableNode() {\n    return this.getScrollableNode ? this.getScrollableNode() : (0, _findNodeHandle.default)(this);\n  },\n\n  /**\n   * A helper function to scroll to a specific point in the scrollview.\n   * This is currently used to help focus on child textviews, but can also\n   * be used to quickly scroll to any element we want to focus. Syntax:\n   *\n   * scrollResponderScrollTo(options: {x: number = 0; y: number = 0; animated: boolean = true})\n   *\n   * Note: The weird argument signature is due to the fact that, for historical reasons,\n   * the function also accepts separate arguments as as alternative to the options object.\n   * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.\n   */\n  scrollResponderScrollTo: function scrollResponderScrollTo(x, y, animated) {\n    if (typeof x === 'number') {\n      console.warn('`scrollResponderScrollTo(x, y, animated)` is deprecated. Use `scrollResponderScrollTo({x: 5, y: 5, animated: true})` instead.');\n    } else {\n      var _ref = x || emptyObject;\n\n      x = _ref.x;\n      y = _ref.y;\n      animated = _ref.animated;\n    }\n\n    var node = this.scrollResponderGetScrollableNode();\n    var left = x || 0;\n    var top = y || 0;\n\n    if (typeof node.scroll === 'function') {\n      node.scroll({\n        top: top,\n        left: left,\n        behavior: !animated ? 'auto' : 'smooth'\n      });\n    } else {\n      node.scrollLeft = left;\n      node.scrollTop = top;\n    }\n  },\n\n  /**\n   * A helper function to zoom to a specific rect in the scrollview. The argument has the shape\n   * {x: number; y: number; width: number; height: number; animated: boolean = true}\n   *\n   * @platform ios\n   */\n  scrollResponderZoomTo: function scrollResponderZoomTo(rect, animated) // deprecated, put this inside the rect argument instead\n  {\n    if (_Platform.default.OS !== 'ios') {\n      (0, _invariant.default)('zoomToRect is not implemented');\n    }\n  },\n\n  /**\n   * Displays the scroll indicators momentarily.\n   */\n  scrollResponderFlashScrollIndicators: function scrollResponderFlashScrollIndicators() {},\n\n  /**\n   * This method should be used as the callback to onFocus in a TextInputs'\n   * parent view. Note that any module using this mixin needs to return\n   * the parent view's ref in getScrollViewRef() in order to use this method.\n   * @param {any} nodeHandle The TextInput node handle\n   * @param {number} additionalOffset The scroll view's top \"contentInset\".\n   *        Default is 0.\n   * @param {bool} preventNegativeScrolling Whether to allow pulling the content\n   *        down to make it meet the keyboard's top. Default is false.\n   */\n  scrollResponderScrollNativeHandleToKeyboard: function scrollResponderScrollNativeHandleToKeyboard(nodeHandle, additionalOffset, preventNegativeScrollOffset) {\n    this.additionalScrollOffset = additionalOffset || 0;\n    this.preventNegativeScrollOffset = !!preventNegativeScrollOffset;\n\n    _UIManager.default.measureLayout(nodeHandle, (0, _findNodeHandle.default)(this.getInnerViewNode()), this.scrollResponderTextInputFocusError, this.scrollResponderInputMeasureAndScrollToKeyboard);\n  },\n\n  /**\n   * The calculations performed here assume the scroll view takes up the entire\n   * screen - even if has some content inset. We then measure the offsets of the\n   * keyboard, and compensate both for the scroll view's \"contentInset\".\n   *\n   * @param {number} left Position of input w.r.t. table view.\n   * @param {number} top Position of input w.r.t. table view.\n   * @param {number} width Width of the text input.\n   * @param {number} height Height of the text input.\n   */\n  scrollResponderInputMeasureAndScrollToKeyboard: function scrollResponderInputMeasureAndScrollToKeyboard(left, top, width, height) {\n    var keyboardScreenY = _Dimensions.default.get('window').height;\n\n    if (this.keyboardWillOpenTo) {\n      keyboardScreenY = this.keyboardWillOpenTo.endCoordinates.screenY;\n    }\n\n    var scrollOffsetY = top - keyboardScreenY + height + this.additionalScrollOffset; // By default, this can scroll with negative offset, pulling the content\n    // down so that the target component's bottom meets the keyboard's top.\n    // If requested otherwise, cap the offset at 0 minimum to avoid content\n    // shifting down.\n\n    if (this.preventNegativeScrollOffset) {\n      scrollOffsetY = Math.max(0, scrollOffsetY);\n    }\n\n    this.scrollResponderScrollTo({\n      x: 0,\n      y: scrollOffsetY,\n      animated: true\n    });\n    this.additionalOffset = 0;\n    this.preventNegativeScrollOffset = false;\n  },\n  scrollResponderTextInputFocusError: function scrollResponderTextInputFocusError(e) {\n    console.error('Error measuring text field: ', e);\n  },\n\n  /**\n   * `componentWillMount` is the closest thing to a  standard \"constructor\" for\n   * React components.\n   *\n   * The `keyboardWillShow` is called before input focus.\n   */\n  UNSAFE_componentWillMount: function UNSAFE_componentWillMount() {\n    this.keyboardWillOpenTo = null;\n    this.additionalScrollOffset = 0; // this.addListenerOn(RCTDeviceEventEmitter, 'keyboardWillShow', this.scrollResponderKeyboardWillShow);\n    // this.addListenerOn(RCTDeviceEventEmitter, 'keyboardWillHide', this.scrollResponderKeyboardWillHide);\n    // this.addListenerOn(RCTDeviceEventEmitter, 'keyboardDidShow', this.scrollResponderKeyboardDidShow);\n    // this.addListenerOn(RCTDeviceEventEmitter, 'keyboardDidHide', this.scrollResponderKeyboardDidHide);\n  },\n\n  /**\n   * Warning, this may be called several times for a single keyboard opening.\n   * It's best to store the information in this method and then take any action\n   * at a later point (either in `keyboardDidShow` or other).\n   *\n   * Here's the order that events occur in:\n   * - focus\n   * - willShow {startCoordinates, endCoordinates} several times\n   * - didShow several times\n   * - blur\n   * - willHide {startCoordinates, endCoordinates} several times\n   * - didHide several times\n   *\n   * The `ScrollResponder` providesModule callbacks for each of these events.\n   * Even though any user could have easily listened to keyboard events\n   * themselves, using these `props` callbacks ensures that ordering of events\n   * is consistent - and not dependent on the order that the keyboard events are\n   * subscribed to. This matters when telling the scroll view to scroll to where\n   * the keyboard is headed - the scroll responder better have been notified of\n   * the keyboard destination before being instructed to scroll to where the\n   * keyboard will be. Stick to the `ScrollResponder` callbacks, and everything\n   * will work.\n   *\n   * WARNING: These callbacks will fire even if a keyboard is displayed in a\n   * different navigation pane. Filter out the events to determine if they are\n   * relevant to you. (For example, only if you receive these callbacks after\n   * you had explicitly focused a node etc).\n   */\n  scrollResponderKeyboardWillShow: function scrollResponderKeyboardWillShow(e) {\n    this.keyboardWillOpenTo = e;\n    this.props.onKeyboardWillShow && this.props.onKeyboardWillShow(e);\n  },\n  scrollResponderKeyboardWillHide: function scrollResponderKeyboardWillHide(e) {\n    this.keyboardWillOpenTo = null;\n    this.props.onKeyboardWillHide && this.props.onKeyboardWillHide(e);\n  },\n  scrollResponderKeyboardDidShow: function scrollResponderKeyboardDidShow(e) {\n    // TODO(7693961): The event for DidShow is not available on iOS yet.\n    // Use the one from WillShow and do not assign.\n    if (e) {\n      this.keyboardWillOpenTo = e;\n    }\n\n    this.props.onKeyboardDidShow && this.props.onKeyboardDidShow(e);\n  },\n  scrollResponderKeyboardDidHide: function scrollResponderKeyboardDidHide(e) {\n    this.keyboardWillOpenTo = null;\n    this.props.onKeyboardDidHide && this.props.onKeyboardDidHide(e);\n  }\n};\nvar ScrollResponder = {\n  Mixin: ScrollResponderMixin\n};\nvar _default = ScrollResponder;\nexports.default = _default;\nmodule.exports = exports.default;"]},"metadata":{},"sourceType":"module"}