{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * BezierEasing - use bezier curve for transition easing function\n * https://github.com/gre/bezier-easing\n *\n * \n * @format\n * @copyright 2014-2015 Gaëtan Renaudeau. MIT License.\n */\n'use strict'; // These values are established by empiricism with tests (tradeoff: performance VS precision)\n\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\nvar float32ArraySupported = typeof Float32Array === 'function';\n\nfunction A(aA1, aA2) {\n  return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n}\n\nfunction B(aA1, aA2) {\n  return 3.0 * aA2 - 6.0 * aA1;\n}\n\nfunction C(aA1) {\n  return 3.0 * aA1;\n} // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\n\n\nfunction calcBezier(aT, aA1, aA2) {\n  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n} // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\n\n\nfunction getSlope(aT, aA1, aA2) {\n  return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n}\n\nfunction binarySubdivide(aX, _aA, _aB, mX1, mX2) {\n  var currentX,\n      currentT,\n      i = 0,\n      aA = _aA,\n      aB = _aB;\n\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n\n  return currentT;\n}\n\nfunction newtonRaphsonIterate(aX, _aGuessT, mX1, mX2) {\n  var aGuessT = _aGuessT;\n\n  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n    var currentSlope = getSlope(aGuessT, mX1, mX2);\n\n    if (currentSlope === 0.0) {\n      return aGuessT;\n    }\n\n    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n\n  return aGuessT;\n}\n\nmodule.exports = function bezier(mX1, mY1, mX2, mY2) {\n  if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) {\n    throw new Error('bezier x values must be in [0, 1] range');\n  } // Precompute samples table\n\n\n  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n\n  if (mX1 !== mY1 || mX2 !== mY2) {\n    for (var i = 0; i < kSplineTableSize; ++i) {\n      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  function getTForX(aX) {\n    var intervalStart = 0.0;\n    var currentSample = 1;\n    var lastSample = kSplineTableSize - 1;\n\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n\n    --currentSample; // Interpolate to provide an initial guess for t\n\n    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    var guessForT = intervalStart + dist * kSampleStepSize;\n    var initialSlope = getSlope(guessForT, mX1, mX2);\n\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  return function BezierEasing(x) {\n    if (mX1 === mY1 && mX2 === mY2) {\n      return x; // linear\n    } // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n\n\n    if (x === 0) {\n      return 0;\n    }\n\n    if (x === 1) {\n      return 1;\n    }\n\n    return calcBezier(getTForX(x), mY1, mY2);\n  };\n};","map":{"version":3,"sources":["/Users/jun/Desktop/dev/react-practice/with-react-native-web-app/node_modules/react-native-web/dist/cjs/vendor/react-native/Animated/bezier.js"],"names":["NEWTON_ITERATIONS","NEWTON_MIN_SLOPE","SUBDIVISION_PRECISION","SUBDIVISION_MAX_ITERATIONS","kSplineTableSize","kSampleStepSize","float32ArraySupported","A","B","C","i","aA","aB","currentT","currentX","calcBezier","Math","aGuessT","currentSlope","getSlope","module","mX1","mX2","sampleValues","intervalStart","currentSample","lastSample","dist","aX","guessForT","initialSlope","newtonRaphsonIterate","binarySubdivide","x","getTForX"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * BezierEasing - use bezier curve for transition easing function\n * https://github.com/gre/bezier-easing\n *\n * \n * @format\n * @copyright 2014-2015 Gaëtan Renaudeau. MIT License.\n */\n'use strict'; // These values are established by empiricism with tests (tradeoff: performance VS precision)\n\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\nvar float32ArraySupported = typeof Float32Array === 'function';\n\nfunction A(aA1, aA2) {\n  return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n}\n\nfunction B(aA1, aA2) {\n  return 3.0 * aA2 - 6.0 * aA1;\n}\n\nfunction C(aA1) {\n  return 3.0 * aA1;\n} // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\n\n\nfunction calcBezier(aT, aA1, aA2) {\n  return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n} // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\n\n\nfunction getSlope(aT, aA1, aA2) {\n  return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n}\n\nfunction binarySubdivide(aX, _aA, _aB, mX1, mX2) {\n  var currentX,\n      currentT,\n      i = 0,\n      aA = _aA,\n      aB = _aB;\n\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n\n  return currentT;\n}\n\nfunction newtonRaphsonIterate(aX, _aGuessT, mX1, mX2) {\n  var aGuessT = _aGuessT;\n\n  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n    var currentSlope = getSlope(aGuessT, mX1, mX2);\n\n    if (currentSlope === 0.0) {\n      return aGuessT;\n    }\n\n    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n    aGuessT -= currentX / currentSlope;\n  }\n\n  return aGuessT;\n}\n\nmodule.exports = function bezier(mX1, mY1, mX2, mY2) {\n  if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) {\n    throw new Error('bezier x values must be in [0, 1] range');\n  } // Precompute samples table\n\n\n  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n\n  if (mX1 !== mY1 || mX2 !== mY2) {\n    for (var i = 0; i < kSplineTableSize; ++i) {\n      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  function getTForX(aX) {\n    var intervalStart = 0.0;\n    var currentSample = 1;\n    var lastSample = kSplineTableSize - 1;\n\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n\n    --currentSample; // Interpolate to provide an initial guess for t\n\n    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    var guessForT = intervalStart + dist * kSampleStepSize;\n    var initialSlope = getSlope(guessForT, mX1, mX2);\n\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  return function BezierEasing(x) {\n    if (mX1 === mY1 && mX2 === mY2) {\n      return x; // linear\n    } // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n\n\n    if (x === 0) {\n      return 0;\n    }\n\n    if (x === 1) {\n      return 1;\n    }\n\n    return calcBezier(getTForX(x), mY1, mY2);\n  };\n};"]},"metadata":{},"sourceType":"script"}