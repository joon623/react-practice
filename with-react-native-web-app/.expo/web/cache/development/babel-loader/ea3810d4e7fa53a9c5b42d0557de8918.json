{"ast":null,"code":"var _s = $RefreshSig$(),\n    _s2 = $RefreshSig$();\n\nimport React from 'react';\nimport { useEffect } from 'react';\nimport BackHandler from \"react-native-web/dist/cjs/exports/BackHandler\";\nvar keyboardDismissHandlers = [];\nexport var keyboardDismissHandlerManager = {\n  push: function push(handler) {\n    keyboardDismissHandlers.push(handler);\n    return function () {\n      keyboardDismissHandlers = keyboardDismissHandlers.filter(function (h) {\n        return h !== handler;\n      });\n    };\n  },\n  length: function length() {\n    return keyboardDismissHandlers.length;\n  },\n  pop: function pop() {\n    return keyboardDismissHandlers.pop();\n  }\n};\n/**\n * Handles attaching callback for Escape key listener on web and Back button listener on Android\n */\n\nexport var useKeyboardDismissable = function useKeyboardDismissable(_ref) {\n  _s();\n\n  var enabled = _ref.enabled,\n      callback = _ref.callback;\n  React.useEffect(function () {\n    var cleanupFn = function cleanupFn() {};\n\n    if (enabled) {\n      cleanupFn = keyboardDismissHandlerManager.push(callback);\n    } else {\n      cleanupFn();\n    }\n\n    return function () {\n      cleanupFn();\n    };\n  }, [enabled, callback]);\n  useBackHandler({\n    enabled: enabled,\n    callback: callback\n  });\n};\n\n_s(useKeyboardDismissable, \"KlZkzYNTu8FER+U0FBbL+PtOOIo=\", false, function () {\n  return [useBackHandler];\n});\n\nexport function useBackHandler(_ref2) {\n  _s2();\n\n  var enabled = _ref2.enabled,\n      callback = _ref2.callback;\n  useEffect(function () {\n    var backHandler = function backHandler() {\n      callback();\n      return true;\n    };\n\n    if (enabled) {\n      BackHandler.addEventListener('hardwareBackPress', backHandler);\n    } else {\n      BackHandler.removeEventListener('hardwareBackPress', backHandler);\n    }\n\n    return function () {\n      return BackHandler.removeEventListener('hardwareBackPress', backHandler);\n    };\n  }, [enabled, callback]);\n}\n\n_s2(useBackHandler, \"OD7bBpZva5O2jO+Puf00hKivP7c=\");\n\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = __webpack_module__.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      __webpack_module__.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      import.meta.webpackHot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          __webpack_module__.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        __webpack_module__.hot.invalidate();\n      }\n    }\n  }\n})();","map":{"version":3,"sources":["/Users/jun/Desktop/dev/react-practice/with-react-native-web-app/node_modules/native-base/src/hooks/useKeyboardDismissable.ts"],"names":["keyboardDismissHandlers","keyboardDismissHandlerManager","push","h","length","pop","useKeyboardDismissable","enabled","callback","React","cleanupFn","useBackHandler","useEffect","backHandler","BackHandler"],"mappings":";;;AAAA,OAAA,KAAA,MAAA,OAAA;AACA,SAAA,SAAA,QAAA,OAAA;;AAQA,IAAIA,uBAAyC,GAA7C,EAAA;AACA,OAAO,IAAMC,6BAA6B,GAAG;EAC3CC,IAAI,EAAE,SAAA,IAAA,CAAA,OAAA,EAAwB;IAC5BF,uBAAuB,CAAvBA,IAAAA,CAAAA,OAAAA;IACA,OAAO,YAAM;MACXA,uBAAuB,GAAG,uBAAuB,CAAvB,MAAA,CACxB,UAAA,CAAA,EAAA;QAAA,OAAOG,CAAC,KAAR,OAAA;MADFH,CAA0B,CAA1BA;IADF,CAAA;EAHyC,CAAA;EAS3CI,MAAM,EAAE,SAAA,MAAA,GAAA;IAAA,OAAMJ,uBAAuB,CAA7B,MAAA;EATmC,CAAA;EAU3CK,GAAG,EAAE,SAAA,GAAA,GAAM;IACT,OAAOL,uBAAuB,CAA9B,GAAOA,EAAP;EACD;AAZ0C,CAAtC;AAeP;AACA;AACA;;AACA,OAAO,IAAMM,sBAAsB,GAAG,SAAzBA,sBAAyB,CAAA,IAAA,EAAoC;EAAA,EAAA;;EAAA,IAAjCC,OAAiC,GAAA,IAAA,CAAjCA,OAAiC;EAAA,IAAxBC,QAAwB,GAAA,IAAA,CAAxBA,QAAwB;EACxEC,KAAK,CAALA,SAAAA,CAAgB,YAAM;IACpB,IAAIC,SAAS,GAAG,SAAA,SAAA,GAAM,CAAtB,CAAA;;IACA,IAAA,OAAA,EAAa;MACXA,SAAS,GAAGT,6BAA6B,CAA7BA,IAAAA,CAAZS,QAAYT,CAAZS;IADF,CAAA,MAEO;MACLA,SAAS;IACV;;IACD,OAAO,YAAM;MACXA,SAAS;IADX,CAAA;EAPFD,CAAAA,EAUG,CAAA,OAAA,EAVHA,QAUG,CAVHA;EAYAE,cAAc,CAAC;IAAEJ,OAAO,EAAT,OAAA;IAAWC,QAAQ,EAARA;EAAX,CAAD,CAAdG;AAbK,CAAA;;GAAML,sB;UAaXK,c;;;AAGF,OAAO,SAAA,cAAA,CAAA,KAAA,EAAwD;EAAA,GAAA;;EAAA,IAA9BJ,OAA8B,GAAA,KAAA,CAA9BA,OAA8B;EAAA,IAArBC,QAAqB,GAAA,KAAA,CAArBA,QAAqB;EAC7DI,SAAS,CAAC,YAAM;IACd,IAAIC,WAAW,GAAG,SAAdA,WAAc,GAAM;MACtBL,QAAQ;MACR,OAAA,IAAA;IAFF,CAAA;;IAIA,IAAA,OAAA,EAAa;MACXM,WAAW,CAAXA,gBAAAA,CAAAA,mBAAAA,EAAAA,WAAAA;IADF,CAAA,MAEO;MACLA,WAAW,CAAXA,mBAAAA,CAAAA,mBAAAA,EAAAA,WAAAA;IACD;;IACD,OAAO,YAAA;MAAA,OACLA,WAAW,CAAXA,mBAAAA,CAAAA,mBAAAA,EADK,WACLA,CADK;IAAP,CAAA;EAVO,CAAA,EAYN,CAAA,OAAA,EAZHF,QAYG,CAZM,CAATA;AAaD;;IAdeD,c","sourcesContent":["import React from 'react';\nimport { useEffect } from 'react';\nimport { BackHandler } from 'react-native';\n\ntype IParams = {\n  enabled?: boolean;\n  callback: () => any;\n};\n\nlet keyboardDismissHandlers: Array<() => any> = [];\nexport const keyboardDismissHandlerManager = {\n  push: (handler: () => any) => {\n    keyboardDismissHandlers.push(handler);\n    return () => {\n      keyboardDismissHandlers = keyboardDismissHandlers.filter(\n        (h) => h !== handler\n      );\n    };\n  },\n  length: () => keyboardDismissHandlers.length,\n  pop: () => {\n    return keyboardDismissHandlers.pop();\n  },\n};\n\n/**\n * Handles attaching callback for Escape key listener on web and Back button listener on Android\n */\nexport const useKeyboardDismissable = ({ enabled, callback }: IParams) => {\n  React.useEffect(() => {\n    let cleanupFn = () => {};\n    if (enabled) {\n      cleanupFn = keyboardDismissHandlerManager.push(callback);\n    } else {\n      cleanupFn();\n    }\n    return () => {\n      cleanupFn();\n    };\n  }, [enabled, callback]);\n\n  useBackHandler({ enabled, callback });\n};\n\nexport function useBackHandler({ enabled, callback }: IParams) {\n  useEffect(() => {\n    let backHandler = () => {\n      callback();\n      return true;\n    };\n    if (enabled) {\n      BackHandler.addEventListener('hardwareBackPress', backHandler);\n    } else {\n      BackHandler.removeEventListener('hardwareBackPress', backHandler);\n    }\n    return () =>\n      BackHandler.removeEventListener('hardwareBackPress', backHandler);\n  }, [enabled, callback]);\n}\n"]},"metadata":{},"sourceType":"module"}