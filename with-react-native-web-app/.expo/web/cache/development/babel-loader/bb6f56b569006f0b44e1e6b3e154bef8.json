{"ast":null,"code":"import _slicedToArray from \"/Users/jun/Desktop/dev/react-practice/with-react-native-web-app/node_modules/next/dist/compiled/@babel/runtime/helpers/esm/slicedToArray\";\nimport _defineProperty from \"/Users/jun/Desktop/dev/react-practice/with-react-native-web-app/node_modules/next/dist/compiled/@babel/runtime/helpers/esm/defineProperty\";\nimport _objectDestructuringEmpty from \"/Users/jun/Desktop/dev/react-practice/with-react-native-web-app/node_modules/next/dist/compiled/@babel/runtime/helpers/esm/objectDestructuringEmpty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport get from 'lodash.get';\nimport isNil from 'lodash.isnil';\nimport mergeWith from 'lodash.mergewith';\nimport cloneDeep from 'lodash.clonedeep';\nimport { themePropertyMap } from './../../theme/base';\nimport { getClosestBreakpoint, findLastValidBreakpoint, hasValidBreakpointFormat, extractInObject } from './../../theme/tools';\nimport { useContrastText } from '../useContrastText';\n/*\n Extract props from theme props and omit those from props\n*/\n\n/**\n *\n * @param props Props passed by the user\n * @param theme Theme object\n * @param colorModeProps `colorMode` object\n * @param componentTheme Theme for specific components\n * @param currentBreakpoint Current breakpoint values\n * @returns Extracting props from defaultProps while overriding the props that are already present\n */\n\nexport function extractProps(props, theme, _ref, componentTheme, currentBreakpoint) {\n  _objectDestructuringEmpty(_ref);\n\n  var newProps = {};\n\n  for (var property in props) {\n    // If the property exists in themePropertyMap then get its value\n    if (themePropertyMap[property]) {\n      var propValues = extractPropertyFromFunction(property, props, theme, componentTheme);\n\n      if (typeof propValues === 'string' || typeof propValues === 'number') {\n        newProps[property] = propValues;\n      } else if (!isNil(propValues)) {\n        for (var nestedProp in propValues) {\n          newProps[nestedProp] = get(theme, \"\".concat(themePropertyMap[nestedProp], \".\").concat(propValues[nestedProp]), propValues[nestedProp]);\n        }\n      } else if (property === 'shadow') {\n        var shadowProps = theme[themePropertyMap[property]][props[property]];\n\n        if (!isNil(shadowProps)) {\n          newProps = _objectSpread(_objectSpread({}, newProps), shadowProps);\n        }\n      } else {\n        newProps[property] = resolveValueWithBreakpoint(props[property], theme.breakpoints, currentBreakpoint, property);\n      }\n    } else {\n      newProps[property] = resolveValueWithBreakpoint(props[property], theme.breakpoints, currentBreakpoint, property);\n    }\n  }\n\n  return cloneDeep(newProps);\n}\n/*\nRemove props from defaultProps that are already present in props\n*/\n\nfunction filterDefaultProps(props, defaultProps) {\n  var _extractInObject = extractInObject(defaultProps, Object.keys(props)),\n      _extractInObject2 = _slicedToArray(_extractInObject, 2),\n      resultProps = _extractInObject2[1];\n\n  return resultProps;\n}\n/**\n * If property is functional in componentTheme, get its returned object\n *\n * @param property : name of the prop\n * @param props : all props\n * @param theme : provided theme without components\n * @param componentTheme : component specific theme\n * @returns\n */\n\n\nexport var extractPropertyFromFunction = function extractPropertyFromFunction(property, props, theme, componentTheme) {\n  var propValues; // Check if the entry in the theme is a function then calling it with all theme and props as params\n\n  if (componentTheme && typeof componentTheme[themePropertyMap[property]] === 'function') {\n    var funcProps = componentTheme[themePropertyMap[property]](_objectSpread({\n      theme: theme\n    }, props)); // Check if returned object from componentTheme is a nested object\n\n    var isNested = Object.keys(funcProps).some(function (key) {\n      return funcProps[key] && typeof funcProps[key] === 'object';\n    }); // If the returned value is nested object then find the property value in it, otherwise return the whole object\n\n    propValues = isNested ? _objectSpread({}, get(funcProps, \"\".concat(props[property]))) : _objectSpread({}, funcProps);\n  } else {\n    // If the entry is any value other than function then return the whole object or value\n    propValues = get(componentTheme, \"\".concat(themePropertyMap[property], \".\").concat(props[property]));\n  }\n\n  return propValues;\n};\n/*\nMerge _props and apply contrastText color if not passed by theme or user\n*/\n\nexport function mergeUnderscoreProps(newProps, props) {\n  var _s = $RefreshSig$();\n\n  var _props = Object.keys(newProps).filter(function (propName) {\n    return propName.startsWith('_');\n  });\n\n  _s(_props.forEach(_s(function (propName) {\n    var _newProps$bg, _newProps$propName$co, _newProps$propName, _props$propName;\n\n    _s(); // Adding color based on bg contrast if no color is given\n\n\n    var bg = (_newProps$bg = newProps.bg) !== null && _newProps$bg !== void 0 ? _newProps$bg : newProps.backgroundColor;\n    var textColor = bg ? {\n      color: useContrastText(bg, (_newProps$propName$co = (_newProps$propName = newProps[propName]) === null || _newProps$propName === void 0 ? void 0 : _newProps$propName.color) !== null && _newProps$propName$co !== void 0 ? _newProps$propName$co : (_props$propName = props[propName]) === null || _props$propName === void 0 ? void 0 : _props$propName.color)\n    } : {}; // Overriding calculated props with user added props\n\n    newProps[propName] = _objectSpread(_objectSpread(_objectSpread({}, textColor), newProps[propName]), props[propName]);\n  }, \"au9PS1pGMSvlwCC87VHk+2CfJX8=\", false, function () {\n    return [useContrastText];\n  })), \"au9PS1pGMSvlwCC87VHk+2CfJX8=\", false, function () {\n    return [useContrastText];\n  });\n\n  return newProps;\n}\n/**\n *\n * Checks the property and resolves it if it has breakpoints\n * @param values : value from props\n * @param currentBreakpoint : current value for which breakpoint will be calculated\n * @param property : property name\n * @returns\n */\n\nexport var resolveValueWithBreakpoint = function resolveValueWithBreakpoint(values, breakpointTheme, currentBreakpoint, property) {\n  if (hasValidBreakpointFormat(values, breakpointTheme, property)) {\n    // Check the last valid breakpoint value from all values\n    // If current breakpoint is `md` and we have `base` then `lg`, then last value will be taken(`base` in this case)\n    return findLastValidBreakpoint(values, breakpointTheme, currentBreakpoint);\n  } else {\n    return values;\n  }\n};\n/**\n * Takes all prop related data and returns the props that needs to be applied to the component\n *\n * @param theme Theme object\n * @param colorModeProps Color mode information\n * @param componentTheme Theme object for the specific component\n * @param props Props passed by the user\n * @param windowWidth Width of the current window\n * @returns props to be applied\n */\n\nexport function calculateProps(theme, colorModeProps, componentTheme, props, windowWidth) {\n  var currentBreakpoint = getClosestBreakpoint(theme.breakpoints, windowWidth);\n\n  if (!props) {\n    props = {};\n  }\n\n  var newProps;\n\n  if (componentTheme) {\n    // Extracting props from defaultProps\n    newProps = extractProps(filterDefaultProps(props, componentTheme.defaultProps), theme, colorModeProps, componentTheme, currentBreakpoint); // Extracting props from base style\n\n    var componentBaseStyle = typeof componentTheme.baseStyle !== 'function' ? componentTheme.baseStyle : componentTheme.baseStyle(_objectSpread(_objectSpread(_objectSpread({\n      theme: theme\n    }, newProps), props), colorModeProps));\n    newProps = mergeWith(newProps, componentBaseStyle, // @ts-ignore\n    function (objValue, srcValue, key) {\n      if (!isNil(objValue)) {\n        delete newProps[key];\n      }\n    });\n    var variant = props.variant || get(componentTheme, 'defaultProps.variant'); // Extracting props from variant\n\n    if (variant && componentTheme.variants && componentTheme.variants[variant]) {\n      var colorScheme = props.colorScheme || get(componentTheme, 'defaultProps.colorScheme');\n      var variantProps = componentTheme.variants[variant](_objectSpread(_objectSpread(_objectSpread({}, props), newProps), {}, {\n        colorScheme: colorScheme,\n        theme: theme\n      }, colorModeProps));\n      variantProps = extractProps(variantProps, theme, colorModeProps, componentTheme, currentBreakpoint); // added this to handle order of props\n\n      newProps = mergeWith(newProps, variantProps, // @ts-ignore\n      function (objValue, srcValue, key) {\n        if (!isNil(objValue)) {\n          delete newProps[key];\n        }\n      });\n      delete newProps.variant;\n      delete newProps.colorScheme;\n    }\n  } // Extracting props from normal props\n\n\n  var extractedProps = extractProps(props, theme, colorModeProps, componentTheme, currentBreakpoint); // added this to handle order of props\n  // @ts-ignore\n\n  newProps = mergeWith(newProps, extractedProps, function (objValue, srcValue, key) {\n    if (!isNil(objValue)) {\n      delete newProps[key];\n    }\n  });\n  newProps = mergeUnderscoreProps(newProps, props);\n  return newProps;\n}\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = __webpack_module__.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      __webpack_module__.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      import.meta.webpackHot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          __webpack_module__.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        __webpack_module__.hot.invalidate();\n      }\n    }\n  }\n})();","map":{"version":3,"sources":["/Users/jun/Desktop/dev/react-practice/with-react-native-web-app/node_modules/native-base/src/hooks/useThemeProps/utils.ts"],"names":["newProps","themePropertyMap","propValues","extractPropertyFromFunction","isNil","get","property","shadowProps","theme","props","resolveValueWithBreakpoint","cloneDeep","resultProps","extractInObject","Object","componentTheme","funcProps","isNested","_props","propName","bg","textColor","color","useContrastText","hasValidBreakpointFormat","findLastValidBreakpoint","currentBreakpoint","getClosestBreakpoint","extractProps","filterDefaultProps","componentBaseStyle","mergeWith","variant","colorScheme","variantProps","extractedProps","mergeUnderscoreProps"],"mappings":"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","sourcesContent":["import get from 'lodash.get';\nimport isNil from 'lodash.isnil';\nimport mergeWith from 'lodash.mergewith';\nimport cloneDeep from 'lodash.clonedeep';\nimport { themePropertyMap } from './../../theme/base';\nimport {\n  getClosestBreakpoint,\n  findLastValidBreakpoint,\n  hasValidBreakpointFormat,\n  extractInObject,\n} from './../../theme/tools';\nimport { useContrastText } from '../useContrastText';\n\n/*\n Extract props from theme props and omit those from props\n*/\n/**\n *\n * @param props Props passed by the user\n * @param theme Theme object\n * @param colorModeProps `colorMode` object\n * @param componentTheme Theme for specific components\n * @param currentBreakpoint Current breakpoint values\n * @returns Extracting props from defaultProps while overriding the props that are already present\n */\nexport function extractProps(\n  props: any,\n  theme: any,\n  {},\n  componentTheme: any,\n  currentBreakpoint: number\n) {\n  let newProps: any = {};\n  for (let property in props) {\n    // If the property exists in themePropertyMap then get its value\n    if (themePropertyMap[property]) {\n      let propValues = extractPropertyFromFunction(\n        property,\n        props,\n        theme,\n        componentTheme\n      );\n      if (typeof propValues === 'string' || typeof propValues === 'number') {\n        newProps[property] = propValues;\n      } else if (!isNil(propValues)) {\n        for (let nestedProp in propValues) {\n          newProps[nestedProp] = get(\n            theme,\n            `${themePropertyMap[nestedProp]}.${propValues[nestedProp]}`,\n            propValues[nestedProp]\n          );\n        }\n      } else if (property === 'shadow') {\n        let shadowProps = theme[themePropertyMap[property]][props[property]];\n        if (!isNil(shadowProps)) {\n          newProps = { ...newProps, ...shadowProps };\n        }\n      } else {\n        newProps[property] = resolveValueWithBreakpoint(\n          props[property],\n          theme.breakpoints,\n          currentBreakpoint,\n          property\n        );\n      }\n    } else {\n      newProps[property] = resolveValueWithBreakpoint(\n        props[property],\n        theme.breakpoints,\n        currentBreakpoint,\n        property\n      );\n    }\n  }\n  return cloneDeep(newProps);\n}\n\n/*\nRemove props from defaultProps that are already present in props\n*/\nfunction filterDefaultProps(props: any, defaultProps: any) {\n  let [, resultProps] = extractInObject(defaultProps, Object.keys(props));\n  return resultProps;\n}\n\n/**\n * If property is functional in componentTheme, get its returned object\n *\n * @param property : name of the prop\n * @param props : all props\n * @param theme : provided theme without components\n * @param componentTheme : component specific theme\n * @returns\n */\nexport const extractPropertyFromFunction = (\n  property: string,\n  props: any,\n  theme: any,\n  componentTheme: any\n) => {\n  let propValues;\n  // Check if the entry in the theme is a function then calling it with all theme and props as params\n  if (\n    componentTheme &&\n    typeof componentTheme[themePropertyMap[property]] === 'function'\n  ) {\n    let funcProps = componentTheme[themePropertyMap[property]]({\n      theme,\n      ...props,\n    });\n    // Check if returned object from componentTheme is a nested object\n    let isNested: boolean = Object.keys(funcProps).some(function (key) {\n      return funcProps[key] && typeof funcProps[key] === 'object';\n    });\n    // If the returned value is nested object then find the property value in it, otherwise return the whole object\n    propValues = isNested\n      ? { ...get(funcProps, `${props[property]}`) }\n      : { ...funcProps };\n  } else {\n    // If the entry is any value other than function then return the whole object or value\n    propValues = get(\n      componentTheme,\n      `${themePropertyMap[property]}.${props[property]}`\n    );\n  }\n  return propValues;\n};\n\n/*\nMerge _props and apply contrastText color if not passed by theme or user\n*/\nexport function mergeUnderscoreProps(newProps: any, props: any) {\n  const _props = Object.keys(newProps).filter((propName) =>\n    propName.startsWith('_')\n  );\n  _props.forEach((propName: string) => {\n    // Adding color based on bg contrast if no color is given\n    const bg = newProps.bg ?? newProps.backgroundColor;\n    const textColor = bg\n      ? {\n          color: useContrastText(\n            bg,\n            newProps[propName]?.color ?? props[propName]?.color\n          ),\n        }\n      : {};\n    // Overriding calculated props with user added props\n    newProps[propName] = {\n      ...textColor,\n      ...newProps[propName],\n      ...props[propName],\n    };\n  });\n  return newProps;\n}\n\n/**\n *\n * Checks the property and resolves it if it has breakpoints\n * @param values : value from props\n * @param currentBreakpoint : current value for which breakpoint will be calculated\n * @param property : property name\n * @returns\n */\nexport const resolveValueWithBreakpoint = (\n  values: any,\n  breakpointTheme: any,\n  currentBreakpoint: number,\n  property: any\n) => {\n  if (hasValidBreakpointFormat(values, breakpointTheme, property)) {\n    // Check the last valid breakpoint value from all values\n    // If current breakpoint is `md` and we have `base` then `lg`, then last value will be taken(`base` in this case)\n    return findLastValidBreakpoint(values, breakpointTheme, currentBreakpoint);\n  } else {\n    return values;\n  }\n};\n\n/**\n * Takes all prop related data and returns the props that needs to be applied to the component\n *\n * @param theme Theme object\n * @param colorModeProps Color mode information\n * @param componentTheme Theme object for the specific component\n * @param props Props passed by the user\n * @param windowWidth Width of the current window\n * @returns props to be applied\n */\nexport function calculateProps(\n  theme: any,\n  colorModeProps: any,\n  componentTheme: any,\n  props: any,\n  windowWidth: any\n) {\n  let currentBreakpoint = getClosestBreakpoint(theme.breakpoints, windowWidth);\n  if (!props) {\n    props = {};\n  }\n\n  let newProps: any;\n  if (componentTheme) {\n    // Extracting props from defaultProps\n    newProps = extractProps(\n      filterDefaultProps(props, componentTheme.defaultProps),\n      theme,\n      colorModeProps,\n      componentTheme,\n      currentBreakpoint\n    );\n    // Extracting props from base style\n    let componentBaseStyle =\n      typeof componentTheme.baseStyle !== 'function'\n        ? componentTheme.baseStyle\n        : componentTheme.baseStyle({\n            theme,\n            ...newProps,\n            ...props,\n            ...colorModeProps,\n          });\n    newProps = mergeWith(\n      newProps,\n      componentBaseStyle,\n      // @ts-ignore\n      (objValue, srcValue, key) => {\n        if (!isNil(objValue)) {\n          delete newProps[key];\n        }\n      }\n    );\n\n    const variant =\n      props.variant || get(componentTheme, 'defaultProps.variant');\n    // Extracting props from variant\n    if (\n      variant &&\n      componentTheme.variants &&\n      componentTheme.variants[variant]\n    ) {\n      const colorScheme =\n        props.colorScheme || get(componentTheme, 'defaultProps.colorScheme');\n      let variantProps = componentTheme.variants[variant]({\n        ...props,\n        ...newProps,\n        colorScheme,\n        theme,\n        ...colorModeProps,\n      });\n      variantProps = extractProps(\n        variantProps,\n        theme,\n        colorModeProps,\n        componentTheme,\n        currentBreakpoint\n      );\n      // added this to handle order of props\n      newProps = mergeWith(\n        newProps,\n        variantProps,\n        // @ts-ignore\n        (objValue, srcValue, key) => {\n          if (!isNil(objValue)) {\n            delete newProps[key];\n          }\n        }\n      );\n      delete newProps.variant;\n      delete newProps.colorScheme;\n    }\n  }\n  // Extracting props from normal props\n  let extractedProps = extractProps(\n    props,\n    theme,\n    colorModeProps,\n    componentTheme,\n    currentBreakpoint\n  );\n  // added this to handle order of props\n  // @ts-ignore\n  newProps = mergeWith(newProps, extractedProps, (objValue, srcValue, key) => {\n    if (!isNil(objValue)) {\n      delete newProps[key];\n    }\n  });\n  newProps = mergeUnderscoreProps(newProps, props);\n  return newProps;\n}\n"]},"metadata":{},"sourceType":"module"}