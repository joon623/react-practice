{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = createResponderEvent;\n\nvar _getBoundingClientRect = _interopRequireDefault(require(\"../../modules/getBoundingClientRect\"));\n\nvar _ResponderTouchHistoryStore = _interopRequireDefault(require(\"./ResponderTouchHistoryStore\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n/**\n * Copyright (c) Nicolas Gallagher\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n\nvar emptyFunction = function emptyFunction() {};\n\nvar emptyObject = {};\nvar emptyArray = [];\n/**\n * Safari produces very large identifiers that would cause the `touchBank` array\n * length to be so large as to crash the browser, if not normalized like this.\n * In the future the `touchBank` should use an object/map instead.\n */\n\nfunction normalizeIdentifier(identifier) {\n  return identifier > 20 ? identifier % 20 : identifier;\n}\n/**\n * Converts a native DOM event to a ResponderEvent.\n * Mouse events are transformed into fake touch events.\n */\n\n\nfunction createResponderEvent(domEvent) {\n  var rect;\n  var propagationWasStopped = false;\n  var changedTouches;\n  var touches;\n  var domEventChangedTouches = domEvent.changedTouches;\n  var domEventType = domEvent.type;\n  var metaKey = domEvent.metaKey === true;\n  var shiftKey = domEvent.shiftKey === true;\n  var force = domEventChangedTouches && domEventChangedTouches[0].force || 0;\n  var identifier = normalizeIdentifier(domEventChangedTouches && domEventChangedTouches[0].identifier || 0);\n  var clientX = domEventChangedTouches && domEventChangedTouches[0].clientX || domEvent.clientX;\n  var clientY = domEventChangedTouches && domEventChangedTouches[0].clientY || domEvent.clientY;\n  var pageX = domEventChangedTouches && domEventChangedTouches[0].pageX || domEvent.pageX;\n  var pageY = domEventChangedTouches && domEventChangedTouches[0].pageY || domEvent.pageY;\n  var preventDefault = typeof domEvent.preventDefault === 'function' ? domEvent.preventDefault.bind(domEvent) : emptyFunction;\n  var timestamp = domEvent.timeStamp;\n\n  function normalizeTouches(touches) {\n    return Array.prototype.slice.call(touches).map(function (touch) {\n      return {\n        force: touch.force,\n        identifier: normalizeIdentifier(touch.identifier),\n\n        get locationX() {\n          return locationX(touch.clientX);\n        },\n\n        get locationY() {\n          return locationY(touch.clientY);\n        },\n\n        pageX: touch.pageX,\n        pageY: touch.pageY,\n        target: touch.target,\n        timestamp: timestamp\n      };\n    });\n  }\n\n  if (domEventChangedTouches != null) {\n    changedTouches = normalizeTouches(domEventChangedTouches);\n    touches = normalizeTouches(domEvent.touches);\n  } else {\n    var emulatedTouches = [{\n      force: force,\n      identifier: identifier,\n\n      get locationX() {\n        return locationX(clientX);\n      },\n\n      get locationY() {\n        return locationY(clientY);\n      },\n\n      pageX: pageX,\n      pageY: pageY,\n      target: domEvent.target,\n      timestamp: timestamp\n    }];\n    changedTouches = emulatedTouches;\n    touches = domEventType === 'mouseup' || domEventType === 'dragstart' ? emptyArray : emulatedTouches;\n  }\n\n  var responderEvent = {\n    bubbles: true,\n    cancelable: true,\n    // `currentTarget` is set before dispatch\n    currentTarget: null,\n    defaultPrevented: domEvent.defaultPrevented,\n    dispatchConfig: emptyObject,\n    eventPhase: domEvent.eventPhase,\n    isDefaultPrevented: function isDefaultPrevented() {\n      return domEvent.defaultPrevented;\n    },\n    isPropagationStopped: function isPropagationStopped() {\n      return propagationWasStopped;\n    },\n    isTrusted: domEvent.isTrusted,\n    nativeEvent: {\n      altKey: false,\n      ctrlKey: false,\n      metaKey: metaKey,\n      shiftKey: shiftKey,\n      changedTouches: changedTouches,\n      force: force,\n      identifier: identifier,\n\n      get locationX() {\n        return locationX(clientX);\n      },\n\n      get locationY() {\n        return locationY(clientY);\n      },\n\n      pageX: pageX,\n      pageY: pageY,\n      target: domEvent.target,\n      timestamp: timestamp,\n      touches: touches,\n      type: domEventType\n    },\n    persist: emptyFunction,\n    preventDefault: preventDefault,\n    stopPropagation: function stopPropagation() {\n      propagationWasStopped = true;\n    },\n    target: domEvent.target,\n    timeStamp: timestamp,\n    touchHistory: _ResponderTouchHistoryStore[\"default\"].touchHistory\n  }; // Using getters and functions serves two purposes:\n  // 1) The value of `currentTarget` is not initially available.\n  // 2) Measuring the clientRect may cause layout jank and should only be done on-demand.\n\n  function locationX(x) {\n    rect = rect || (0, _getBoundingClientRect[\"default\"])(responderEvent.currentTarget);\n\n    if (rect) {\n      return x - rect.left;\n    }\n  }\n\n  function locationY(y) {\n    rect = rect || (0, _getBoundingClientRect[\"default\"])(responderEvent.currentTarget);\n\n    if (rect) {\n      return y - rect.top;\n    }\n  }\n\n  return responderEvent;\n}\n\nmodule.exports = exports[\"default\"];\n; // Wrapped in an IIFE to avoid polluting the global scope\n\n;\n\n(function () {\n  var _a, _b; // Legacy CSS implementations will `eval` browser code in a Node.js context\n  // to extract CSS. For backwards compatibility, we need to check we're in a\n  // browser context before continuing.\n\n\n  if (typeof self !== 'undefined' && // AMP / No-JS mode does not inject these helpers:\n  '$RefreshHelpers$' in self) {\n    // @ts-ignore __webpack_module__ is global\n    var currentExports = __webpack_module__.exports; // @ts-ignore __webpack_module__ is global\n\n    var prevExports = (_b = (_a = __webpack_module__.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null; // This cannot happen in MainTemplate because the exports mismatch between\n    // templating and execution.\n\n    self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, __webpack_module__.id); // A module can be accepted automatically based on its exports, e.g. when\n    // it is a Refresh Boundary.\n\n    if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n      // Save the previous exports on update so we can compare the boundary\n      // signatures.\n      __webpack_module__.hot.dispose(function (data) {\n        data.prevExports = currentExports;\n      }); // Unconditionally accept an update to this module, we'll check if it's\n      // still a Refresh Boundary later.\n      // @ts-ignore importMeta is replaced in the loader\n\n\n      import.meta.webpackHot.accept(); // This field is set when the previous version of this module was a\n      // Refresh Boundary, letting us know we need to check for invalidation or\n      // enqueue an update.\n\n      if (prevExports !== null) {\n        // A boundary can become ineligible if its exports are incompatible\n        // with the previous exports.\n        //\n        // For example, if you add/remove/change exports, we'll want to\n        // re-execute the importing modules, and force those components to\n        // re-render. Similarly, if you convert a class component to a\n        // function, we want to invalidate the boundary.\n        if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n          __webpack_module__.hot.invalidate();\n        } else {\n          self.$RefreshHelpers$.scheduleUpdate();\n        }\n      }\n    } else {\n      // Since we just executed the code for the module, it's possible that the\n      // new exports made it ineligible for being a boundary.\n      // We only care about the case when we were _previously_ a boundary,\n      // because we already accepted this update (accidental side effect).\n      var isNoLongerABoundary = prevExports !== null;\n\n      if (isNoLongerABoundary) {\n        __webpack_module__.hot.invalidate();\n      }\n    }\n  }\n})();","map":{"version":3,"sources":["/Users/jun/Desktop/dev/react-practice/with-react-native-web-app/node_modules/react-native-web/dist/cjs/hooks/useResponderEvents/createResponderEvent.js"],"names":["exports","_getBoundingClientRect","_interopRequireDefault","require","_ResponderTouchHistoryStore","obj","emptyFunction","emptyObject","emptyArray","identifier","propagationWasStopped","domEventChangedTouches","domEvent","domEventType","metaKey","shiftKey","force","normalizeIdentifier","clientX","clientY","pageX","pageY","preventDefault","timestamp","touch","locationX","locationY","target","changedTouches","normalizeTouches","touches","emulatedTouches","responderEvent","bubbles","cancelable","currentTarget","defaultPrevented","dispatchConfig","eventPhase","isDefaultPrevented","isPropagationStopped","isTrusted","nativeEvent","altKey","ctrlKey","type","persist","stopPropagation","timeStamp","touchHistory","rect","x","y","module"],"mappings":"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","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = createResponderEvent;\n\nvar _getBoundingClientRect = _interopRequireDefault(require(\"../../modules/getBoundingClientRect\"));\n\nvar _ResponderTouchHistoryStore = _interopRequireDefault(require(\"./ResponderTouchHistoryStore\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Copyright (c) Nicolas Gallagher\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\nvar emptyFunction = function emptyFunction() {};\n\nvar emptyObject = {};\nvar emptyArray = [];\n/**\n * Safari produces very large identifiers that would cause the `touchBank` array\n * length to be so large as to crash the browser, if not normalized like this.\n * In the future the `touchBank` should use an object/map instead.\n */\n\nfunction normalizeIdentifier(identifier) {\n  return identifier > 20 ? identifier % 20 : identifier;\n}\n/**\n * Converts a native DOM event to a ResponderEvent.\n * Mouse events are transformed into fake touch events.\n */\n\n\nfunction createResponderEvent(domEvent) {\n  var rect;\n  var propagationWasStopped = false;\n  var changedTouches;\n  var touches;\n  var domEventChangedTouches = domEvent.changedTouches;\n  var domEventType = domEvent.type;\n  var metaKey = domEvent.metaKey === true;\n  var shiftKey = domEvent.shiftKey === true;\n  var force = domEventChangedTouches && domEventChangedTouches[0].force || 0;\n  var identifier = normalizeIdentifier(domEventChangedTouches && domEventChangedTouches[0].identifier || 0);\n  var clientX = domEventChangedTouches && domEventChangedTouches[0].clientX || domEvent.clientX;\n  var clientY = domEventChangedTouches && domEventChangedTouches[0].clientY || domEvent.clientY;\n  var pageX = domEventChangedTouches && domEventChangedTouches[0].pageX || domEvent.pageX;\n  var pageY = domEventChangedTouches && domEventChangedTouches[0].pageY || domEvent.pageY;\n  var preventDefault = typeof domEvent.preventDefault === 'function' ? domEvent.preventDefault.bind(domEvent) : emptyFunction;\n  var timestamp = domEvent.timeStamp;\n\n  function normalizeTouches(touches) {\n    return Array.prototype.slice.call(touches).map(function (touch) {\n      return {\n        force: touch.force,\n        identifier: normalizeIdentifier(touch.identifier),\n\n        get locationX() {\n          return locationX(touch.clientX);\n        },\n\n        get locationY() {\n          return locationY(touch.clientY);\n        },\n\n        pageX: touch.pageX,\n        pageY: touch.pageY,\n        target: touch.target,\n        timestamp: timestamp\n      };\n    });\n  }\n\n  if (domEventChangedTouches != null) {\n    changedTouches = normalizeTouches(domEventChangedTouches);\n    touches = normalizeTouches(domEvent.touches);\n  } else {\n    var emulatedTouches = [{\n      force: force,\n      identifier: identifier,\n\n      get locationX() {\n        return locationX(clientX);\n      },\n\n      get locationY() {\n        return locationY(clientY);\n      },\n\n      pageX: pageX,\n      pageY: pageY,\n      target: domEvent.target,\n      timestamp: timestamp\n    }];\n    changedTouches = emulatedTouches;\n    touches = domEventType === 'mouseup' || domEventType === 'dragstart' ? emptyArray : emulatedTouches;\n  }\n\n  var responderEvent = {\n    bubbles: true,\n    cancelable: true,\n    // `currentTarget` is set before dispatch\n    currentTarget: null,\n    defaultPrevented: domEvent.defaultPrevented,\n    dispatchConfig: emptyObject,\n    eventPhase: domEvent.eventPhase,\n    isDefaultPrevented: function isDefaultPrevented() {\n      return domEvent.defaultPrevented;\n    },\n    isPropagationStopped: function isPropagationStopped() {\n      return propagationWasStopped;\n    },\n    isTrusted: domEvent.isTrusted,\n    nativeEvent: {\n      altKey: false,\n      ctrlKey: false,\n      metaKey: metaKey,\n      shiftKey: shiftKey,\n      changedTouches: changedTouches,\n      force: force,\n      identifier: identifier,\n\n      get locationX() {\n        return locationX(clientX);\n      },\n\n      get locationY() {\n        return locationY(clientY);\n      },\n\n      pageX: pageX,\n      pageY: pageY,\n      target: domEvent.target,\n      timestamp: timestamp,\n      touches: touches,\n      type: domEventType\n    },\n    persist: emptyFunction,\n    preventDefault: preventDefault,\n    stopPropagation: function stopPropagation() {\n      propagationWasStopped = true;\n    },\n    target: domEvent.target,\n    timeStamp: timestamp,\n    touchHistory: _ResponderTouchHistoryStore.default.touchHistory\n  }; // Using getters and functions serves two purposes:\n  // 1) The value of `currentTarget` is not initially available.\n  // 2) Measuring the clientRect may cause layout jank and should only be done on-demand.\n\n  function locationX(x) {\n    rect = rect || (0, _getBoundingClientRect.default)(responderEvent.currentTarget);\n\n    if (rect) {\n      return x - rect.left;\n    }\n  }\n\n  function locationY(y) {\n    rect = rect || (0, _getBoundingClientRect.default)(responderEvent.currentTarget);\n\n    if (rect) {\n      return y - rect.top;\n    }\n  }\n\n  return responderEvent;\n}\n\nmodule.exports = exports.default;"]},"metadata":{},"sourceType":"module"}