{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n'use strict';\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _AccessibilityUtil = _interopRequireDefault(require(\"../../modules/AccessibilityUtil\"));\n\nvar _BoundingDimensions = _interopRequireDefault(require(\"./BoundingDimensions\"));\n\nvar _findNodeHandle = _interopRequireDefault(require(\"../findNodeHandle\"));\n\nvar _normalizeCssColor = _interopRequireDefault(require(\"normalize-css-color\"));\n\nvar _Position = _interopRequireDefault(require(\"./Position\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _UIManager = _interopRequireDefault(require(\"../UIManager\"));\n\nvar _View = _interopRequireDefault(require(\"../View\"));\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar extractSingleTouch = function extractSingleTouch(nativeEvent) {\n  var touches = nativeEvent.touches;\n  var changedTouches = nativeEvent.changedTouches;\n  var hasTouches = touches && touches.length > 0;\n  var hasChangedTouches = changedTouches && changedTouches.length > 0;\n  return !hasTouches && hasChangedTouches ? changedTouches[0] : hasTouches ? touches[0] : nativeEvent;\n};\n/**\n * `Touchable`: Taps done right.\n *\n * You hook your `ResponderEventPlugin` events into `Touchable`. `Touchable`\n * will measure time/geometry and tells you when to give feedback to the user.\n *\n * ====================== Touchable Tutorial ===============================\n * The `Touchable` mixin helps you handle the \"press\" interaction. It analyzes\n * the geometry of elements, and observes when another responder (scroll view\n * etc) has stolen the touch lock. It notifies your component when it should\n * give feedback to the user. (bouncing/highlighting/unhighlighting).\n *\n * - When a touch was activated (typically you highlight)\n * - When a touch was deactivated (typically you unhighlight)\n * - When a touch was \"pressed\" - a touch ended while still within the geometry\n *   of the element, and no other element (like scroller) has \"stolen\" touch\n *   lock (\"responder\") (Typically you bounce the element).\n *\n * A good tap interaction isn't as simple as you might think. There should be a\n * slight delay before showing a highlight when starting a touch. If a\n * subsequent touch move exceeds the boundary of the element, it should\n * unhighlight, but if that same touch is brought back within the boundary, it\n * should rehighlight again. A touch can move in and out of that boundary\n * several times, each time toggling highlighting, but a \"press\" is only\n * triggered if that touch ends while within the element's boundary and no\n * scroller (or anything else) has stolen the lock on touches.\n *\n * To create a new type of component that handles interaction using the\n * `Touchable` mixin, do the following:\n *\n * - Initialize the `Touchable` state.\n *\n *   getInitialState: function() {\n *     return merge(this.touchableGetInitialState(), yourComponentState);\n *   }\n *\n * - Choose the rendered component who's touches should start the interactive\n *   sequence. On that rendered node, forward all `Touchable` responder\n *   handlers. You can choose any rendered node you like. Choose a node whose\n *   hit target you'd like to instigate the interaction sequence:\n *\n *   // In render function:\n *   return (\n *     <View\n *       onStartShouldSetResponder={this.touchableHandleStartShouldSetResponder}\n *       onResponderTerminationRequest={this.touchableHandleResponderTerminationRequest}\n *       onResponderGrant={this.touchableHandleResponderGrant}\n *       onResponderMove={this.touchableHandleResponderMove}\n *       onResponderRelease={this.touchableHandleResponderRelease}\n *       onResponderTerminate={this.touchableHandleResponderTerminate}>\n *       <View>\n *         Even though the hit detection/interactions are triggered by the\n *         wrapping (typically larger) node, we usually end up implementing\n *         custom logic that highlights this inner one.\n *       </View>\n *     </View>\n *   );\n *\n * - You may set up your own handlers for each of these events, so long as you\n *   also invoke the `touchable*` handlers inside of your custom handler.\n *\n * - Implement the handlers on your component class in order to provide\n *   feedback to the user. See documentation for each of these class methods\n *   that you should implement.\n *\n *   touchableHandlePress: function() {\n *      this.performBounceAnimation();  // or whatever you want to do.\n *   },\n *   touchableHandleActivePressIn: function() {\n *     this.beginHighlighting(...);  // Whatever you like to convey activation\n *   },\n *   touchableHandleActivePressOut: function() {\n *     this.endHighlighting(...);  // Whatever you like to convey deactivation\n *   },\n *\n * - There are more advanced methods you can implement (see documentation below):\n *   touchableGetHighlightDelayMS: function() {\n *     return 20;\n *   }\n *   // In practice, *always* use a predeclared constant (conserve memory).\n *   touchableGetPressRectOffset: function() {\n *     return {top: 20, left: 20, right: 20, bottom: 100};\n *   }\n */\n\n/**\n * Touchable states.\n */\n\n\nvar States = {\n  NOT_RESPONDER: 'NOT_RESPONDER',\n  // Not the responder\n  RESPONDER_INACTIVE_PRESS_IN: 'RESPONDER_INACTIVE_PRESS_IN',\n  // Responder, inactive, in the `PressRect`\n  RESPONDER_INACTIVE_PRESS_OUT: 'RESPONDER_INACTIVE_PRESS_OUT',\n  // Responder, inactive, out of `PressRect`\n  RESPONDER_ACTIVE_PRESS_IN: 'RESPONDER_ACTIVE_PRESS_IN',\n  // Responder, active, in the `PressRect`\n  RESPONDER_ACTIVE_PRESS_OUT: 'RESPONDER_ACTIVE_PRESS_OUT',\n  // Responder, active, out of `PressRect`\n  RESPONDER_ACTIVE_LONG_PRESS_IN: 'RESPONDER_ACTIVE_LONG_PRESS_IN',\n  // Responder, active, in the `PressRect`, after long press threshold\n  RESPONDER_ACTIVE_LONG_PRESS_OUT: 'RESPONDER_ACTIVE_LONG_PRESS_OUT',\n  // Responder, active, out of `PressRect`, after long press threshold\n  ERROR: 'ERROR'\n};\n/*\n * Quick lookup map for states that are considered to be \"active\"\n */\n\nvar baseStatesConditions = {\n  NOT_RESPONDER: false,\n  RESPONDER_INACTIVE_PRESS_IN: false,\n  RESPONDER_INACTIVE_PRESS_OUT: false,\n  RESPONDER_ACTIVE_PRESS_IN: false,\n  RESPONDER_ACTIVE_PRESS_OUT: false,\n  RESPONDER_ACTIVE_LONG_PRESS_IN: false,\n  RESPONDER_ACTIVE_LONG_PRESS_OUT: false,\n  ERROR: false\n};\n\nvar IsActive = _objectSpread({}, baseStatesConditions, {\n  RESPONDER_ACTIVE_PRESS_OUT: true,\n  RESPONDER_ACTIVE_PRESS_IN: true\n});\n/**\n * Quick lookup for states that are considered to be \"pressing\" and are\n * therefore eligible to result in a \"selection\" if the press stops.\n */\n\n\nvar IsPressingIn = _objectSpread({}, baseStatesConditions, {\n  RESPONDER_INACTIVE_PRESS_IN: true,\n  RESPONDER_ACTIVE_PRESS_IN: true,\n  RESPONDER_ACTIVE_LONG_PRESS_IN: true\n});\n\nvar IsLongPressingIn = _objectSpread({}, baseStatesConditions, {\n  RESPONDER_ACTIVE_LONG_PRESS_IN: true\n});\n/**\n * Inputs to the state machine.\n */\n\n\nvar Signals = {\n  DELAY: 'DELAY',\n  RESPONDER_GRANT: 'RESPONDER_GRANT',\n  RESPONDER_RELEASE: 'RESPONDER_RELEASE',\n  RESPONDER_TERMINATED: 'RESPONDER_TERMINATED',\n  ENTER_PRESS_RECT: 'ENTER_PRESS_RECT',\n  LEAVE_PRESS_RECT: 'LEAVE_PRESS_RECT',\n  LONG_PRESS_DETECTED: 'LONG_PRESS_DETECTED'\n};\n/**\n * Mapping from States x Signals => States\n */\n\nvar Transitions = {\n  NOT_RESPONDER: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,\n    RESPONDER_RELEASE: States.ERROR,\n    RESPONDER_TERMINATED: States.ERROR,\n    ENTER_PRESS_RECT: States.ERROR,\n    LEAVE_PRESS_RECT: States.ERROR,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_INACTIVE_PRESS_IN: {\n    DELAY: States.RESPONDER_ACTIVE_PRESS_IN,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_INACTIVE_PRESS_OUT: {\n    DELAY: States.RESPONDER_ACTIVE_PRESS_OUT,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_ACTIVE_PRESS_IN: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN\n  },\n  RESPONDER_ACTIVE_PRESS_OUT: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_IN: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_OUT: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  error: {\n    DELAY: States.NOT_RESPONDER,\n    RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.NOT_RESPONDER,\n    LEAVE_PRESS_RECT: States.NOT_RESPONDER,\n    LONG_PRESS_DETECTED: States.NOT_RESPONDER\n  }\n}; // ==== Typical Constants for integrating into UI components ====\n// var HIT_EXPAND_PX = 20;\n// var HIT_VERT_OFFSET_PX = 10;\n\nvar HIGHLIGHT_DELAY_MS = 130;\nvar PRESS_EXPAND_PX = 20;\nvar LONG_PRESS_THRESHOLD = 500;\nvar LONG_PRESS_DELAY_MS = LONG_PRESS_THRESHOLD - HIGHLIGHT_DELAY_MS;\nvar LONG_PRESS_ALLOWED_MOVEMENT = 10; // Default amount \"active\" region protrudes beyond box\n\n/**\n * By convention, methods prefixed with underscores are meant to be @private,\n * and not @protected. Mixers shouldn't access them - not even to provide them\n * as callback handlers.\n *\n *\n * ========== Geometry =========\n * `Touchable` only assumes that there exists a `HitRect` node. The `PressRect`\n * is an abstract box that is extended beyond the `HitRect`.\n *\n *  +--------------------------+\n *  |                          | - \"Start\" events in `HitRect` cause `HitRect`\n *  |  +--------------------+  |   to become the responder.\n *  |  |  +--------------+  |  | - `HitRect` is typically expanded around\n *  |  |  |              |  |  |   the `VisualRect`, but shifted downward.\n *  |  |  |  VisualRect  |  |  | - After pressing down, after some delay,\n *  |  |  |              |  |  |   and before letting up, the Visual React\n *  |  |  +--------------+  |  |   will become \"active\". This makes it eligible\n *  |  |     HitRect        |  |   for being highlighted (so long as the\n *  |  +--------------------+  |   press remains in the `PressRect`).\n *  |        PressRect     o   |\n *  +----------------------|---+\n *           Out Region    |\n *                         +-----+ This gap between the `HitRect` and\n *                                 `PressRect` allows a touch to move far away\n *                                 from the original hit rect, and remain\n *                                 highlighted, and eligible for a \"Press\".\n *                                 Customize this via\n *                                 `touchableGetPressRectOffset()`.\n *\n *\n *\n * ======= State Machine =======\n *\n * +-------------+ <---+ RESPONDER_RELEASE\n * |NOT_RESPONDER|\n * +-------------+ <---+ RESPONDER_TERMINATED\n *     +\n *     | RESPONDER_GRANT (HitRect)\n *     v\n * +---------------------------+  DELAY   +-------------------------+  T + DELAY     +------------------------------+\n * |RESPONDER_INACTIVE_PRESS_IN|+-------->|RESPONDER_ACTIVE_PRESS_IN| +------------> |RESPONDER_ACTIVE_LONG_PRESS_IN|\n * +---------------------------+          +-------------------------+                +------------------------------+\n *     +            ^                         +           ^                                 +           ^\n *     |LEAVE_      |ENTER_                   |LEAVE_     |ENTER_                           |LEAVE_     |ENTER_\n *     |PRESS_RECT  |PRESS_RECT               |PRESS_RECT |PRESS_RECT                       |PRESS_RECT |PRESS_RECT\n *     |            |                         |           |                                 |           |\n *     v            +                         v           +                                 v           +\n * +----------------------------+  DELAY  +--------------------------+               +-------------------------------+\n * |RESPONDER_INACTIVE_PRESS_OUT|+------->|RESPONDER_ACTIVE_PRESS_OUT|               |RESPONDER_ACTIVE_LONG_PRESS_OUT|\n * +----------------------------+         +--------------------------+               +-------------------------------+\n *\n * T + DELAY => LONG_PRESS_DELAY_MS + DELAY\n *\n * Not drawn are the side effects of each transition. The most important side\n * effect is the `touchableHandlePress` abstract method invocation that occurs\n * when a responder is released while in either of the \"Press\" states.\n *\n * The other important side effects are the highlight abstract method\n * invocations (internal callbacks) to be implemented by the mixer.\n *\n *\n * @lends Touchable.prototype\n */\n\nvar TouchableMixin = {\n  // HACK (part 1): basic support for touchable interactions using a keyboard\n  componentDidMount: function componentDidMount() {\n    var _this = this;\n\n    this._touchableNode = (0, _findNodeHandle[\"default\"])(this);\n\n    if (this._touchableNode && this._touchableNode.addEventListener) {\n      this._touchableBlurListener = function (e) {\n        if (_this._isTouchableKeyboardActive) {\n          if (_this.state.touchable.touchState && _this.state.touchable.touchState !== States.NOT_RESPONDER) {\n            _this.touchableHandleResponderTerminate({\n              nativeEvent: e\n            });\n          }\n\n          _this._isTouchableKeyboardActive = false;\n        }\n      };\n\n      this._touchableNode.addEventListener('blur', this._touchableBlurListener);\n    }\n  },\n\n  /**\n   * Clear all timeouts on unmount\n   */\n  componentWillUnmount: function componentWillUnmount() {\n    if (this._touchableNode && this._touchableNode.addEventListener) {\n      this._touchableNode.removeEventListener('blur', this._touchableBlurListener);\n    }\n\n    this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);\n    this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);\n    this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);\n  },\n\n  /**\n   * It's prefer that mixins determine state in this way, having the class\n   * explicitly mix the state in the one and only `getInitialState` method.\n   *\n   * @return {object} State object to be placed inside of\n   * `this.state.touchable`.\n   */\n  touchableGetInitialState: function touchableGetInitialState() {\n    return {\n      touchable: {\n        touchState: undefined,\n        responderID: null\n      }\n    };\n  },\n  // ==== Hooks to Gesture Responder system ====\n\n  /**\n   * Must return true if embedded in a native platform scroll view.\n   */\n  touchableHandleResponderTerminationRequest: function touchableHandleResponderTerminationRequest() {\n    return !this.props.rejectResponderTermination;\n  },\n\n  /**\n   * Must return true to start the process of `Touchable`.\n   */\n  touchableHandleStartShouldSetResponder: function touchableHandleStartShouldSetResponder() {\n    return !this.props.disabled;\n  },\n\n  /**\n   * Return true to cancel press on long press.\n   */\n  touchableLongPressCancelsPress: function touchableLongPressCancelsPress() {\n    return true;\n  },\n\n  /**\n   * Place as callback for a DOM element's `onResponderGrant` event.\n   * @param {SyntheticEvent} e Synthetic event from event system.\n   *\n   */\n  touchableHandleResponderGrant: function touchableHandleResponderGrant(e) {\n    var dispatchID = e.currentTarget; // Since e is used in a callback invoked on another event loop\n    // (as in setTimeout etc), we need to call e.persist() on the\n    // event to make sure it doesn't get reused in the event object pool.\n\n    e.persist();\n    this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);\n    this.pressOutDelayTimeout = null;\n    this.state.touchable.touchState = States.NOT_RESPONDER;\n    this.state.touchable.responderID = dispatchID;\n\n    this._receiveSignal(Signals.RESPONDER_GRANT, e);\n\n    var delayMS = this.touchableGetHighlightDelayMS !== undefined ? Math.max(this.touchableGetHighlightDelayMS(), 0) : HIGHLIGHT_DELAY_MS;\n    delayMS = isNaN(delayMS) ? HIGHLIGHT_DELAY_MS : delayMS;\n\n    if (delayMS !== 0) {\n      this.touchableDelayTimeout = setTimeout(this._handleDelay.bind(this, e), delayMS);\n    } else {\n      this._handleDelay(e);\n    }\n\n    var longDelayMS = this.touchableGetLongPressDelayMS !== undefined ? Math.max(this.touchableGetLongPressDelayMS(), 10) : LONG_PRESS_DELAY_MS;\n    longDelayMS = isNaN(longDelayMS) ? LONG_PRESS_DELAY_MS : longDelayMS;\n    this.longPressDelayTimeout = setTimeout(this._handleLongDelay.bind(this, e), longDelayMS + delayMS);\n  },\n\n  /**\n   * Place as callback for a DOM element's `onResponderRelease` event.\n   */\n  touchableHandleResponderRelease: function touchableHandleResponderRelease(e) {\n    this.pressInLocation = null;\n\n    this._receiveSignal(Signals.RESPONDER_RELEASE, e);\n  },\n\n  /**\n   * Place as callback for a DOM element's `onResponderTerminate` event.\n   */\n  touchableHandleResponderTerminate: function touchableHandleResponderTerminate(e) {\n    this.pressInLocation = null;\n\n    this._receiveSignal(Signals.RESPONDER_TERMINATED, e);\n  },\n\n  /**\n   * Place as callback for a DOM element's `onResponderMove` event.\n   */\n  touchableHandleResponderMove: function touchableHandleResponderMove(e) {\n    // Measurement may not have returned yet.\n    if (!this.state.touchable.positionOnActivate) {\n      return;\n    }\n\n    var positionOnActivate = this.state.touchable.positionOnActivate;\n    var dimensionsOnActivate = this.state.touchable.dimensionsOnActivate;\n    var pressRectOffset = this.touchableGetPressRectOffset ? this.touchableGetPressRectOffset() : {\n      left: PRESS_EXPAND_PX,\n      right: PRESS_EXPAND_PX,\n      top: PRESS_EXPAND_PX,\n      bottom: PRESS_EXPAND_PX\n    };\n    var pressExpandLeft = pressRectOffset.left;\n    var pressExpandTop = pressRectOffset.top;\n    var pressExpandRight = pressRectOffset.right;\n    var pressExpandBottom = pressRectOffset.bottom;\n    var hitSlop = this.touchableGetHitSlop ? this.touchableGetHitSlop() : null;\n\n    if (hitSlop) {\n      pressExpandLeft += hitSlop.left || 0;\n      pressExpandTop += hitSlop.top || 0;\n      pressExpandRight += hitSlop.right || 0;\n      pressExpandBottom += hitSlop.bottom || 0;\n    }\n\n    var touch = extractSingleTouch(e.nativeEvent);\n    var pageX = touch && touch.pageX;\n    var pageY = touch && touch.pageY;\n\n    if (this.pressInLocation) {\n      var movedDistance = this._getDistanceBetweenPoints(pageX, pageY, this.pressInLocation.pageX, this.pressInLocation.pageY);\n\n      if (movedDistance > LONG_PRESS_ALLOWED_MOVEMENT) {\n        this._cancelLongPressDelayTimeout();\n      }\n    }\n\n    var isTouchWithinActive = pageX > positionOnActivate.left - pressExpandLeft && pageY > positionOnActivate.top - pressExpandTop && pageX < positionOnActivate.left + dimensionsOnActivate.width + pressExpandRight && pageY < positionOnActivate.top + dimensionsOnActivate.height + pressExpandBottom;\n\n    if (isTouchWithinActive) {\n      var prevState = this.state.touchable.touchState;\n\n      this._receiveSignal(Signals.ENTER_PRESS_RECT, e);\n\n      var curState = this.state.touchable.touchState;\n\n      if (curState === States.RESPONDER_INACTIVE_PRESS_IN && prevState !== States.RESPONDER_INACTIVE_PRESS_IN) {\n        // fix for t7967420\n        this._cancelLongPressDelayTimeout();\n      }\n    } else {\n      this._cancelLongPressDelayTimeout();\n\n      this._receiveSignal(Signals.LEAVE_PRESS_RECT, e);\n    }\n  },\n\n  /**\n   * Invoked when the item receives focus. Mixers might override this to\n   * visually distinguish the `VisualRect` so that the user knows that it\n   * currently has the focus. Most platforms only support a single element being\n   * focused at a time, in which case there may have been a previously focused\n   * element that was blurred just prior to this. This can be overridden when\n   * using `Touchable.Mixin.withoutDefaultFocusAndBlur`.\n   */\n  touchableHandleFocus: function touchableHandleFocus(e) {\n    this.props.onFocus && this.props.onFocus(e);\n  },\n\n  /**\n   * Invoked when the item loses focus. Mixers might override this to\n   * visually distinguish the `VisualRect` so that the user knows that it\n   * no longer has focus. Most platforms only support a single element being\n   * focused at a time, in which case the focus may have moved to another.\n   * This can be overridden when using\n   * `Touchable.Mixin.withoutDefaultFocusAndBlur`.\n   */\n  touchableHandleBlur: function touchableHandleBlur(e) {\n    this.props.onBlur && this.props.onBlur(e);\n  },\n  // ==== Abstract Application Callbacks ====\n\n  /**\n   * Invoked when the item should be highlighted. Mixers should implement this\n   * to visually distinguish the `VisualRect` so that the user knows that\n   * releasing a touch will result in a \"selection\" (analog to click).\n   *\n   * @abstract\n   * touchableHandleActivePressIn: function,\n   */\n\n  /**\n   * Invoked when the item is \"active\" (in that it is still eligible to become\n   * a \"select\") but the touch has left the `PressRect`. Usually the mixer will\n   * want to unhighlight the `VisualRect`. If the user (while pressing) moves\n   * back into the `PressRect` `touchableHandleActivePressIn` will be invoked\n   * again and the mixer should probably highlight the `VisualRect` again. This\n   * event will not fire on an `touchEnd/mouseUp` event, only move events while\n   * the user is depressing the mouse/touch.\n   *\n   * @abstract\n   * touchableHandleActivePressOut: function\n   */\n\n  /**\n   * Invoked when the item is \"selected\" - meaning the interaction ended by\n   * letting up while the item was either in the state\n   * `RESPONDER_ACTIVE_PRESS_IN` or `RESPONDER_INACTIVE_PRESS_IN`.\n   *\n   * @abstract\n   * touchableHandlePress: function\n   */\n\n  /**\n   * Invoked when the item is long pressed - meaning the interaction ended by\n   * letting up while the item was in `RESPONDER_ACTIVE_LONG_PRESS_IN`. If\n   * `touchableHandleLongPress` is *not* provided, `touchableHandlePress` will\n   * be called as it normally is. If `touchableHandleLongPress` is provided, by\n   * default any `touchableHandlePress` callback will not be invoked. To\n   * override this default behavior, override `touchableLongPressCancelsPress`\n   * to return false. As a result, `touchableHandlePress` will be called when\n   * lifting up, even if `touchableHandleLongPress` has also been called.\n   *\n   * @abstract\n   * touchableHandleLongPress: function\n   */\n\n  /**\n   * Returns the number of millis to wait before triggering a highlight.\n   *\n   * @abstract\n   * touchableGetHighlightDelayMS: function\n   */\n\n  /**\n   * Returns the amount to extend the `HitRect` into the `PressRect`. Positive\n   * numbers mean the size expands outwards.\n   *\n   * @abstract\n   * touchableGetPressRectOffset: function\n   */\n  // ==== Internal Logic ====\n\n  /**\n   * Measures the `HitRect` node on activation. The Bounding rectangle is with\n   * respect to viewport - not page, so adding the `pageXOffset/pageYOffset`\n   * should result in points that are in the same coordinate system as an\n   * event's `globalX/globalY` data values.\n   *\n   * - Consider caching this for the lifetime of the component, or possibly\n   *   being able to share this cache between any `ScrollMap` view.\n   *\n   * @sideeffects\n   * @private\n   */\n  _remeasureMetricsOnActivation: function _remeasureMetricsOnActivation() {\n    var tag = this.state.touchable.responderID;\n\n    if (tag == null) {\n      return;\n    }\n\n    _UIManager[\"default\"].measure(tag, this._handleQueryLayout);\n  },\n  _handleQueryLayout: function _handleQueryLayout(l, t, w, h, globalX, globalY) {\n    //don't do anything UIManager failed to measure node\n    if (!l && !t && !w && !h && !globalX && !globalY) {\n      return;\n    }\n\n    this.state.touchable.positionOnActivate && _Position[\"default\"].release(this.state.touchable.positionOnActivate);\n    this.state.touchable.dimensionsOnActivate && // $FlowFixMe\n    _BoundingDimensions[\"default\"].release(this.state.touchable.dimensionsOnActivate);\n    this.state.touchable.positionOnActivate = _Position[\"default\"].getPooled(globalX, globalY); // $FlowFixMe\n\n    this.state.touchable.dimensionsOnActivate = _BoundingDimensions[\"default\"].getPooled(w, h);\n  },\n  _handleDelay: function _handleDelay(e) {\n    this.touchableDelayTimeout = null;\n\n    this._receiveSignal(Signals.DELAY, e);\n  },\n  _handleLongDelay: function _handleLongDelay(e) {\n    this.longPressDelayTimeout = null;\n    var curState = this.state.touchable.touchState;\n\n    if (curState !== States.RESPONDER_ACTIVE_PRESS_IN && curState !== States.RESPONDER_ACTIVE_LONG_PRESS_IN) {\n      console.error('Attempted to transition from state `' + curState + '` to `' + States.RESPONDER_ACTIVE_LONG_PRESS_IN + '`, which is not supported. This is ' + 'most likely due to `Touchable.longPressDelayTimeout` not being cancelled.');\n    } else {\n      this._receiveSignal(Signals.LONG_PRESS_DETECTED, e);\n    }\n  },\n\n  /**\n   * Receives a state machine signal, performs side effects of the transition\n   * and stores the new state. Validates the transition as well.\n   *\n   * @param {Signals} signal State machine signal.\n   * @throws Error if invalid state transition or unrecognized signal.\n   * @sideeffects\n   */\n  _receiveSignal: function _receiveSignal(signal, e) {\n    var responderID = this.state.touchable.responderID;\n    var curState = this.state.touchable.touchState;\n    var nextState = Transitions[curState] && Transitions[curState][signal];\n\n    if (!responderID && signal === Signals.RESPONDER_RELEASE) {\n      return;\n    }\n\n    if (!nextState) {\n      throw new Error('Unrecognized signal `' + signal + '` or state `' + curState + '` for Touchable responder `' + responderID + '`');\n    }\n\n    if (nextState === States.ERROR) {\n      throw new Error('Touchable cannot transition from `' + curState + '` to `' + signal + '` for responder `' + responderID + '`');\n    }\n\n    if (curState !== nextState) {\n      this._performSideEffectsForTransition(curState, nextState, signal, e);\n\n      this.state.touchable.touchState = nextState;\n    }\n  },\n  _cancelLongPressDelayTimeout: function _cancelLongPressDelayTimeout() {\n    this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);\n    this.longPressDelayTimeout = null;\n  },\n  _isHighlight: function _isHighlight(state) {\n    return state === States.RESPONDER_ACTIVE_PRESS_IN || state === States.RESPONDER_ACTIVE_LONG_PRESS_IN;\n  },\n  _savePressInLocation: function _savePressInLocation(e) {\n    var touch = extractSingleTouch(e.nativeEvent);\n    var pageX = touch && touch.pageX;\n    var pageY = touch && touch.pageY;\n    var locationX = touch && touch.locationX;\n    var locationY = touch && touch.locationY;\n    this.pressInLocation = {\n      pageX: pageX,\n      pageY: pageY,\n      locationX: locationX,\n      locationY: locationY\n    };\n  },\n  _getDistanceBetweenPoints: function _getDistanceBetweenPoints(aX, aY, bX, bY) {\n    var deltaX = aX - bX;\n    var deltaY = aY - bY;\n    return Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n  },\n\n  /**\n   * Will perform a transition between touchable states, and identify any\n   * highlighting or unhighlighting that must be performed for this particular\n   * transition.\n   *\n   * @param {States} curState Current Touchable state.\n   * @param {States} nextState Next Touchable state.\n   * @param {Signal} signal Signal that triggered the transition.\n   * @param {Event} e Native event.\n   * @sideeffects\n   */\n  _performSideEffectsForTransition: function _performSideEffectsForTransition(curState, nextState, signal, e) {\n    var curIsHighlight = this._isHighlight(curState);\n\n    var newIsHighlight = this._isHighlight(nextState);\n\n    var isFinalSignal = signal === Signals.RESPONDER_TERMINATED || signal === Signals.RESPONDER_RELEASE;\n\n    if (isFinalSignal) {\n      this._cancelLongPressDelayTimeout();\n    }\n\n    var isInitialTransition = curState === States.NOT_RESPONDER && nextState === States.RESPONDER_INACTIVE_PRESS_IN;\n    var isActiveTransition = !IsActive[curState] && IsActive[nextState];\n\n    if (isInitialTransition || isActiveTransition) {\n      this._remeasureMetricsOnActivation();\n    }\n\n    if (IsPressingIn[curState] && signal === Signals.LONG_PRESS_DETECTED) {\n      this.touchableHandleLongPress && this.touchableHandleLongPress(e);\n    }\n\n    if (newIsHighlight && !curIsHighlight) {\n      this._startHighlight(e);\n    } else if (!newIsHighlight && curIsHighlight) {\n      this._endHighlight(e);\n    }\n\n    if (IsPressingIn[curState] && signal === Signals.RESPONDER_RELEASE) {\n      var hasLongPressHandler = !!this.props.onLongPress;\n      var pressIsLongButStillCallOnPress = IsLongPressingIn[curState] && ( // We *are* long pressing.. // But either has no long handler\n      !hasLongPressHandler || !this.touchableLongPressCancelsPress()); // or we're told to ignore it.\n\n      var shouldInvokePress = !IsLongPressingIn[curState] || pressIsLongButStillCallOnPress;\n\n      if (shouldInvokePress && this.touchableHandlePress) {\n        if (!newIsHighlight && !curIsHighlight) {\n          // we never highlighted because of delay, but we should highlight now\n          this._startHighlight(e);\n\n          this._endHighlight(e);\n        }\n\n        this.touchableHandlePress(e);\n      }\n    }\n\n    this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);\n    this.touchableDelayTimeout = null;\n  },\n  _playTouchSound: function _playTouchSound() {\n    _UIManager[\"default\"].playTouchSound();\n  },\n  _startHighlight: function _startHighlight(e) {\n    this._savePressInLocation(e);\n\n    this.touchableHandleActivePressIn && this.touchableHandleActivePressIn(e);\n  },\n  _endHighlight: function _endHighlight(e) {\n    var _this2 = this;\n\n    if (this.touchableHandleActivePressOut) {\n      if (this.touchableGetPressOutDelayMS && this.touchableGetPressOutDelayMS()) {\n        this.pressOutDelayTimeout = setTimeout(function () {\n          _this2.touchableHandleActivePressOut(e);\n        }, this.touchableGetPressOutDelayMS());\n      } else {\n        this.touchableHandleActivePressOut(e);\n      }\n    }\n  },\n  // HACK (part 2): basic support for touchable interactions using a keyboard (including\n  // delays and longPress)\n  touchableHandleKeyEvent: function touchableHandleKeyEvent(e) {\n    var type = e.type,\n        key = e.key;\n\n    if (key === 'Enter' || key === ' ') {\n      if (type === 'keydown') {\n        if (!this._isTouchableKeyboardActive) {\n          if (!this.state.touchable.touchState || this.state.touchable.touchState === States.NOT_RESPONDER) {\n            this.touchableHandleResponderGrant(e);\n            this._isTouchableKeyboardActive = true;\n          }\n        }\n      } else if (type === 'keyup') {\n        if (this._isTouchableKeyboardActive) {\n          if (this.state.touchable.touchState && this.state.touchable.touchState !== States.NOT_RESPONDER) {\n            this.touchableHandleResponderRelease(e);\n            this._isTouchableKeyboardActive = false;\n          }\n        }\n      }\n\n      e.stopPropagation(); // prevent the default behaviour unless the Touchable functions as a link\n      // and Enter is pressed\n\n      if (!(key === 'Enter' && _AccessibilityUtil[\"default\"].propsToAriaRole(this.props) === 'link')) {\n        e.preventDefault();\n      }\n    }\n  },\n  withoutDefaultFocusAndBlur: {}\n};\n/**\n * Provide an optional version of the mixin where `touchableHandleFocus` and\n * `touchableHandleBlur` can be overridden. This allows appropriate defaults to\n * be set on TV platforms, without breaking existing implementations of\n * `Touchable`.\n */\n\nvar touchableHandleFocus = TouchableMixin.touchableHandleFocus,\n    touchableHandleBlur = TouchableMixin.touchableHandleBlur,\n    TouchableMixinWithoutDefaultFocusAndBlur = _objectWithoutPropertiesLoose(TouchableMixin, [\"touchableHandleFocus\", \"touchableHandleBlur\"]);\n\nTouchableMixin.withoutDefaultFocusAndBlur = TouchableMixinWithoutDefaultFocusAndBlur;\nvar Touchable = {\n  Mixin: TouchableMixin,\n  TOUCH_TARGET_DEBUG: false,\n  // Highlights all touchable targets. Toggle with Inspector.\n\n  /**\n   * Renders a debugging overlay to visualize touch target with hitSlop (might not work on Android).\n   */\n  renderDebugView: function renderDebugView(_ref) {\n    var color = _ref.color,\n        hitSlop = _ref.hitSlop;\n\n    if (!Touchable.TOUCH_TARGET_DEBUG) {\n      return null;\n    }\n\n    if (true) {\n      throw Error('Touchable.TOUCH_TARGET_DEBUG should not be enabled in prod!');\n    }\n\n    var debugHitSlopStyle = {};\n    hitSlop = hitSlop || {\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0\n    };\n\n    for (var key in hitSlop) {\n      debugHitSlopStyle[key] = -hitSlop[key];\n    }\n\n    var normalizedColor = (0, _normalizeCssColor[\"default\"])(color);\n\n    if (typeof normalizedColor !== 'number') {\n      return null;\n    }\n\n    var hexColor = '#' + ('00000000' + normalizedColor.toString(16)).substr(-8);\n    return _react[\"default\"].createElement(_View[\"default\"], {\n      pointerEvents: \"none\",\n      style: _objectSpread({\n        position: 'absolute',\n        borderColor: hexColor.slice(0, -2) + '55',\n        // More opaque\n        borderWidth: 1,\n        borderStyle: 'dashed',\n        backgroundColor: hexColor.slice(0, -2) + '0F'\n      }, debugHitSlopStyle)\n    });\n  }\n};\nvar _default = Touchable;\nexports[\"default\"] = _default;\nmodule.exports = exports[\"default\"];","map":{"version":3,"sources":["/Users/jun/Desktop/dev/react-practice/with-react-native-web-app/node_modules/react-native-web/dist/cjs/exports/Touchable/index.js"],"names":["exports","_AccessibilityUtil","_interopRequireDefault","require","_BoundingDimensions","_findNodeHandle","_normalizeCssColor","_Position","_react","_UIManager","_View","obj","default","source","target","sourceKeys","Object","i","key","excluded","keys","symbols","arguments","ownKeys","_defineProperty","value","enumerable","configurable","writable","extractSingleTouch","touches","nativeEvent","changedTouches","hasTouches","hasChangedTouches","States","NOT_RESPONDER","RESPONDER_INACTIVE_PRESS_IN","RESPONDER_INACTIVE_PRESS_OUT","RESPONDER_ACTIVE_PRESS_IN","RESPONDER_ACTIVE_PRESS_OUT","RESPONDER_ACTIVE_LONG_PRESS_IN","RESPONDER_ACTIVE_LONG_PRESS_OUT","ERROR","baseStatesConditions","IsActive","_objectSpread","IsPressingIn","IsLongPressingIn","Signals","DELAY","RESPONDER_GRANT","RESPONDER_RELEASE","RESPONDER_TERMINATED","ENTER_PRESS_RECT","LEAVE_PRESS_RECT","LONG_PRESS_DETECTED","Transitions","error","HIGHLIGHT_DELAY_MS","PRESS_EXPAND_PX","LONG_PRESS_THRESHOLD","LONG_PRESS_DELAY_MS","LONG_PRESS_ALLOWED_MOVEMENT","TouchableMixin","componentDidMount","_this","e","componentWillUnmount","clearTimeout","touchableGetInitialState","touchable","touchState","responderID","touchableHandleResponderTerminationRequest","touchableHandleStartShouldSetResponder","touchableLongPressCancelsPress","touchableHandleResponderGrant","dispatchID","delayMS","Math","isNaN","setTimeout","longDelayMS","touchableHandleResponderRelease","touchableHandleResponderTerminate","touchableHandleResponderMove","positionOnActivate","dimensionsOnActivate","pressRectOffset","left","right","top","bottom","pressExpandLeft","pressExpandTop","pressExpandRight","pressExpandBottom","hitSlop","touch","pageX","pageY","movedDistance","isTouchWithinActive","prevState","curState","touchableHandleFocus","touchableHandleBlur","_remeasureMetricsOnActivation","tag","_handleQueryLayout","_handleDelay","_handleLongDelay","console","_receiveSignal","nextState","signal","_cancelLongPressDelayTimeout","_isHighlight","state","_savePressInLocation","locationX","locationY","_getDistanceBetweenPoints","deltaX","aX","deltaY","aY","_performSideEffectsForTransition","curIsHighlight","newIsHighlight","isFinalSignal","isInitialTransition","isActiveTransition","hasLongPressHandler","pressIsLongButStillCallOnPress","shouldInvokePress","_playTouchSound","_startHighlight","_endHighlight","_this2","touchableHandleKeyEvent","type","withoutDefaultFocusAndBlur","TouchableMixinWithoutDefaultFocusAndBlur","_objectWithoutPropertiesLoose","Touchable","Mixin","TOUCH_TARGET_DEBUG","renderDebugView","color","_ref","Error","debugHitSlopStyle","normalizedColor","hexColor","pointerEvents","style","position","borderColor","borderWidth","borderStyle","backgroundColor","_default","module"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n * @format\n */\n'use strict';\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _AccessibilityUtil = _interopRequireDefault(require(\"../../modules/AccessibilityUtil\"));\n\nvar _BoundingDimensions = _interopRequireDefault(require(\"./BoundingDimensions\"));\n\nvar _findNodeHandle = _interopRequireDefault(require(\"../findNodeHandle\"));\n\nvar _normalizeCssColor = _interopRequireDefault(require(\"normalize-css-color\"));\n\nvar _Position = _interopRequireDefault(require(\"./Position\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _UIManager = _interopRequireDefault(require(\"../UIManager\"));\n\nvar _View = _interopRequireDefault(require(\"../View\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar extractSingleTouch = function extractSingleTouch(nativeEvent) {\n  var touches = nativeEvent.touches;\n  var changedTouches = nativeEvent.changedTouches;\n  var hasTouches = touches && touches.length > 0;\n  var hasChangedTouches = changedTouches && changedTouches.length > 0;\n  return !hasTouches && hasChangedTouches ? changedTouches[0] : hasTouches ? touches[0] : nativeEvent;\n};\n/**\n * `Touchable`: Taps done right.\n *\n * You hook your `ResponderEventPlugin` events into `Touchable`. `Touchable`\n * will measure time/geometry and tells you when to give feedback to the user.\n *\n * ====================== Touchable Tutorial ===============================\n * The `Touchable` mixin helps you handle the \"press\" interaction. It analyzes\n * the geometry of elements, and observes when another responder (scroll view\n * etc) has stolen the touch lock. It notifies your component when it should\n * give feedback to the user. (bouncing/highlighting/unhighlighting).\n *\n * - When a touch was activated (typically you highlight)\n * - When a touch was deactivated (typically you unhighlight)\n * - When a touch was \"pressed\" - a touch ended while still within the geometry\n *   of the element, and no other element (like scroller) has \"stolen\" touch\n *   lock (\"responder\") (Typically you bounce the element).\n *\n * A good tap interaction isn't as simple as you might think. There should be a\n * slight delay before showing a highlight when starting a touch. If a\n * subsequent touch move exceeds the boundary of the element, it should\n * unhighlight, but if that same touch is brought back within the boundary, it\n * should rehighlight again. A touch can move in and out of that boundary\n * several times, each time toggling highlighting, but a \"press\" is only\n * triggered if that touch ends while within the element's boundary and no\n * scroller (or anything else) has stolen the lock on touches.\n *\n * To create a new type of component that handles interaction using the\n * `Touchable` mixin, do the following:\n *\n * - Initialize the `Touchable` state.\n *\n *   getInitialState: function() {\n *     return merge(this.touchableGetInitialState(), yourComponentState);\n *   }\n *\n * - Choose the rendered component who's touches should start the interactive\n *   sequence. On that rendered node, forward all `Touchable` responder\n *   handlers. You can choose any rendered node you like. Choose a node whose\n *   hit target you'd like to instigate the interaction sequence:\n *\n *   // In render function:\n *   return (\n *     <View\n *       onStartShouldSetResponder={this.touchableHandleStartShouldSetResponder}\n *       onResponderTerminationRequest={this.touchableHandleResponderTerminationRequest}\n *       onResponderGrant={this.touchableHandleResponderGrant}\n *       onResponderMove={this.touchableHandleResponderMove}\n *       onResponderRelease={this.touchableHandleResponderRelease}\n *       onResponderTerminate={this.touchableHandleResponderTerminate}>\n *       <View>\n *         Even though the hit detection/interactions are triggered by the\n *         wrapping (typically larger) node, we usually end up implementing\n *         custom logic that highlights this inner one.\n *       </View>\n *     </View>\n *   );\n *\n * - You may set up your own handlers for each of these events, so long as you\n *   also invoke the `touchable*` handlers inside of your custom handler.\n *\n * - Implement the handlers on your component class in order to provide\n *   feedback to the user. See documentation for each of these class methods\n *   that you should implement.\n *\n *   touchableHandlePress: function() {\n *      this.performBounceAnimation();  // or whatever you want to do.\n *   },\n *   touchableHandleActivePressIn: function() {\n *     this.beginHighlighting(...);  // Whatever you like to convey activation\n *   },\n *   touchableHandleActivePressOut: function() {\n *     this.endHighlighting(...);  // Whatever you like to convey deactivation\n *   },\n *\n * - There are more advanced methods you can implement (see documentation below):\n *   touchableGetHighlightDelayMS: function() {\n *     return 20;\n *   }\n *   // In practice, *always* use a predeclared constant (conserve memory).\n *   touchableGetPressRectOffset: function() {\n *     return {top: 20, left: 20, right: 20, bottom: 100};\n *   }\n */\n\n/**\n * Touchable states.\n */\n\n\nvar States = {\n  NOT_RESPONDER: 'NOT_RESPONDER',\n  // Not the responder\n  RESPONDER_INACTIVE_PRESS_IN: 'RESPONDER_INACTIVE_PRESS_IN',\n  // Responder, inactive, in the `PressRect`\n  RESPONDER_INACTIVE_PRESS_OUT: 'RESPONDER_INACTIVE_PRESS_OUT',\n  // Responder, inactive, out of `PressRect`\n  RESPONDER_ACTIVE_PRESS_IN: 'RESPONDER_ACTIVE_PRESS_IN',\n  // Responder, active, in the `PressRect`\n  RESPONDER_ACTIVE_PRESS_OUT: 'RESPONDER_ACTIVE_PRESS_OUT',\n  // Responder, active, out of `PressRect`\n  RESPONDER_ACTIVE_LONG_PRESS_IN: 'RESPONDER_ACTIVE_LONG_PRESS_IN',\n  // Responder, active, in the `PressRect`, after long press threshold\n  RESPONDER_ACTIVE_LONG_PRESS_OUT: 'RESPONDER_ACTIVE_LONG_PRESS_OUT',\n  // Responder, active, out of `PressRect`, after long press threshold\n  ERROR: 'ERROR'\n};\n\n/*\n * Quick lookup map for states that are considered to be \"active\"\n */\nvar baseStatesConditions = {\n  NOT_RESPONDER: false,\n  RESPONDER_INACTIVE_PRESS_IN: false,\n  RESPONDER_INACTIVE_PRESS_OUT: false,\n  RESPONDER_ACTIVE_PRESS_IN: false,\n  RESPONDER_ACTIVE_PRESS_OUT: false,\n  RESPONDER_ACTIVE_LONG_PRESS_IN: false,\n  RESPONDER_ACTIVE_LONG_PRESS_OUT: false,\n  ERROR: false\n};\n\nvar IsActive = _objectSpread({}, baseStatesConditions, {\n  RESPONDER_ACTIVE_PRESS_OUT: true,\n  RESPONDER_ACTIVE_PRESS_IN: true\n});\n/**\n * Quick lookup for states that are considered to be \"pressing\" and are\n * therefore eligible to result in a \"selection\" if the press stops.\n */\n\n\nvar IsPressingIn = _objectSpread({}, baseStatesConditions, {\n  RESPONDER_INACTIVE_PRESS_IN: true,\n  RESPONDER_ACTIVE_PRESS_IN: true,\n  RESPONDER_ACTIVE_LONG_PRESS_IN: true\n});\n\nvar IsLongPressingIn = _objectSpread({}, baseStatesConditions, {\n  RESPONDER_ACTIVE_LONG_PRESS_IN: true\n});\n/**\n * Inputs to the state machine.\n */\n\n\nvar Signals = {\n  DELAY: 'DELAY',\n  RESPONDER_GRANT: 'RESPONDER_GRANT',\n  RESPONDER_RELEASE: 'RESPONDER_RELEASE',\n  RESPONDER_TERMINATED: 'RESPONDER_TERMINATED',\n  ENTER_PRESS_RECT: 'ENTER_PRESS_RECT',\n  LEAVE_PRESS_RECT: 'LEAVE_PRESS_RECT',\n  LONG_PRESS_DETECTED: 'LONG_PRESS_DETECTED'\n};\n\n/**\n * Mapping from States x Signals => States\n */\nvar Transitions = {\n  NOT_RESPONDER: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,\n    RESPONDER_RELEASE: States.ERROR,\n    RESPONDER_TERMINATED: States.ERROR,\n    ENTER_PRESS_RECT: States.ERROR,\n    LEAVE_PRESS_RECT: States.ERROR,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_INACTIVE_PRESS_IN: {\n    DELAY: States.RESPONDER_ACTIVE_PRESS_IN,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_INACTIVE_PRESS_OUT: {\n    DELAY: States.RESPONDER_ACTIVE_PRESS_OUT,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_INACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_ACTIVE_PRESS_IN: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN\n  },\n  RESPONDER_ACTIVE_PRESS_OUT: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_IN: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.RESPONDER_ACTIVE_LONG_PRESS_IN\n  },\n  RESPONDER_ACTIVE_LONG_PRESS_OUT: {\n    DELAY: States.ERROR,\n    RESPONDER_GRANT: States.ERROR,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_IN,\n    LEAVE_PRESS_RECT: States.RESPONDER_ACTIVE_LONG_PRESS_OUT,\n    LONG_PRESS_DETECTED: States.ERROR\n  },\n  error: {\n    DELAY: States.NOT_RESPONDER,\n    RESPONDER_GRANT: States.RESPONDER_INACTIVE_PRESS_IN,\n    RESPONDER_RELEASE: States.NOT_RESPONDER,\n    RESPONDER_TERMINATED: States.NOT_RESPONDER,\n    ENTER_PRESS_RECT: States.NOT_RESPONDER,\n    LEAVE_PRESS_RECT: States.NOT_RESPONDER,\n    LONG_PRESS_DETECTED: States.NOT_RESPONDER\n  }\n}; // ==== Typical Constants for integrating into UI components ====\n// var HIT_EXPAND_PX = 20;\n// var HIT_VERT_OFFSET_PX = 10;\n\nvar HIGHLIGHT_DELAY_MS = 130;\nvar PRESS_EXPAND_PX = 20;\nvar LONG_PRESS_THRESHOLD = 500;\nvar LONG_PRESS_DELAY_MS = LONG_PRESS_THRESHOLD - HIGHLIGHT_DELAY_MS;\nvar LONG_PRESS_ALLOWED_MOVEMENT = 10; // Default amount \"active\" region protrudes beyond box\n\n/**\n * By convention, methods prefixed with underscores are meant to be @private,\n * and not @protected. Mixers shouldn't access them - not even to provide them\n * as callback handlers.\n *\n *\n * ========== Geometry =========\n * `Touchable` only assumes that there exists a `HitRect` node. The `PressRect`\n * is an abstract box that is extended beyond the `HitRect`.\n *\n *  +--------------------------+\n *  |                          | - \"Start\" events in `HitRect` cause `HitRect`\n *  |  +--------------------+  |   to become the responder.\n *  |  |  +--------------+  |  | - `HitRect` is typically expanded around\n *  |  |  |              |  |  |   the `VisualRect`, but shifted downward.\n *  |  |  |  VisualRect  |  |  | - After pressing down, after some delay,\n *  |  |  |              |  |  |   and before letting up, the Visual React\n *  |  |  +--------------+  |  |   will become \"active\". This makes it eligible\n *  |  |     HitRect        |  |   for being highlighted (so long as the\n *  |  +--------------------+  |   press remains in the `PressRect`).\n *  |        PressRect     o   |\n *  +----------------------|---+\n *           Out Region    |\n *                         +-----+ This gap between the `HitRect` and\n *                                 `PressRect` allows a touch to move far away\n *                                 from the original hit rect, and remain\n *                                 highlighted, and eligible for a \"Press\".\n *                                 Customize this via\n *                                 `touchableGetPressRectOffset()`.\n *\n *\n *\n * ======= State Machine =======\n *\n * +-------------+ <---+ RESPONDER_RELEASE\n * |NOT_RESPONDER|\n * +-------------+ <---+ RESPONDER_TERMINATED\n *     +\n *     | RESPONDER_GRANT (HitRect)\n *     v\n * +---------------------------+  DELAY   +-------------------------+  T + DELAY     +------------------------------+\n * |RESPONDER_INACTIVE_PRESS_IN|+-------->|RESPONDER_ACTIVE_PRESS_IN| +------------> |RESPONDER_ACTIVE_LONG_PRESS_IN|\n * +---------------------------+          +-------------------------+                +------------------------------+\n *     +            ^                         +           ^                                 +           ^\n *     |LEAVE_      |ENTER_                   |LEAVE_     |ENTER_                           |LEAVE_     |ENTER_\n *     |PRESS_RECT  |PRESS_RECT               |PRESS_RECT |PRESS_RECT                       |PRESS_RECT |PRESS_RECT\n *     |            |                         |           |                                 |           |\n *     v            +                         v           +                                 v           +\n * +----------------------------+  DELAY  +--------------------------+               +-------------------------------+\n * |RESPONDER_INACTIVE_PRESS_OUT|+------->|RESPONDER_ACTIVE_PRESS_OUT|               |RESPONDER_ACTIVE_LONG_PRESS_OUT|\n * +----------------------------+         +--------------------------+               +-------------------------------+\n *\n * T + DELAY => LONG_PRESS_DELAY_MS + DELAY\n *\n * Not drawn are the side effects of each transition. The most important side\n * effect is the `touchableHandlePress` abstract method invocation that occurs\n * when a responder is released while in either of the \"Press\" states.\n *\n * The other important side effects are the highlight abstract method\n * invocations (internal callbacks) to be implemented by the mixer.\n *\n *\n * @lends Touchable.prototype\n */\n\nvar TouchableMixin = {\n  // HACK (part 1): basic support for touchable interactions using a keyboard\n  componentDidMount: function componentDidMount() {\n    var _this = this;\n\n    this._touchableNode = (0, _findNodeHandle.default)(this);\n\n    if (this._touchableNode && this._touchableNode.addEventListener) {\n      this._touchableBlurListener = function (e) {\n        if (_this._isTouchableKeyboardActive) {\n          if (_this.state.touchable.touchState && _this.state.touchable.touchState !== States.NOT_RESPONDER) {\n            _this.touchableHandleResponderTerminate({\n              nativeEvent: e\n            });\n          }\n\n          _this._isTouchableKeyboardActive = false;\n        }\n      };\n\n      this._touchableNode.addEventListener('blur', this._touchableBlurListener);\n    }\n  },\n\n  /**\n   * Clear all timeouts on unmount\n   */\n  componentWillUnmount: function componentWillUnmount() {\n    if (this._touchableNode && this._touchableNode.addEventListener) {\n      this._touchableNode.removeEventListener('blur', this._touchableBlurListener);\n    }\n\n    this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);\n    this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);\n    this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);\n  },\n\n  /**\n   * It's prefer that mixins determine state in this way, having the class\n   * explicitly mix the state in the one and only `getInitialState` method.\n   *\n   * @return {object} State object to be placed inside of\n   * `this.state.touchable`.\n   */\n  touchableGetInitialState: function touchableGetInitialState() {\n    return {\n      touchable: {\n        touchState: undefined,\n        responderID: null\n      }\n    };\n  },\n  // ==== Hooks to Gesture Responder system ====\n\n  /**\n   * Must return true if embedded in a native platform scroll view.\n   */\n  touchableHandleResponderTerminationRequest: function touchableHandleResponderTerminationRequest() {\n    return !this.props.rejectResponderTermination;\n  },\n\n  /**\n   * Must return true to start the process of `Touchable`.\n   */\n  touchableHandleStartShouldSetResponder: function touchableHandleStartShouldSetResponder() {\n    return !this.props.disabled;\n  },\n\n  /**\n   * Return true to cancel press on long press.\n   */\n  touchableLongPressCancelsPress: function touchableLongPressCancelsPress() {\n    return true;\n  },\n\n  /**\n   * Place as callback for a DOM element's `onResponderGrant` event.\n   * @param {SyntheticEvent} e Synthetic event from event system.\n   *\n   */\n  touchableHandleResponderGrant: function touchableHandleResponderGrant(e) {\n    var dispatchID = e.currentTarget; // Since e is used in a callback invoked on another event loop\n    // (as in setTimeout etc), we need to call e.persist() on the\n    // event to make sure it doesn't get reused in the event object pool.\n\n    e.persist();\n    this.pressOutDelayTimeout && clearTimeout(this.pressOutDelayTimeout);\n    this.pressOutDelayTimeout = null;\n    this.state.touchable.touchState = States.NOT_RESPONDER;\n    this.state.touchable.responderID = dispatchID;\n\n    this._receiveSignal(Signals.RESPONDER_GRANT, e);\n\n    var delayMS = this.touchableGetHighlightDelayMS !== undefined ? Math.max(this.touchableGetHighlightDelayMS(), 0) : HIGHLIGHT_DELAY_MS;\n    delayMS = isNaN(delayMS) ? HIGHLIGHT_DELAY_MS : delayMS;\n\n    if (delayMS !== 0) {\n      this.touchableDelayTimeout = setTimeout(this._handleDelay.bind(this, e), delayMS);\n    } else {\n      this._handleDelay(e);\n    }\n\n    var longDelayMS = this.touchableGetLongPressDelayMS !== undefined ? Math.max(this.touchableGetLongPressDelayMS(), 10) : LONG_PRESS_DELAY_MS;\n    longDelayMS = isNaN(longDelayMS) ? LONG_PRESS_DELAY_MS : longDelayMS;\n    this.longPressDelayTimeout = setTimeout(this._handleLongDelay.bind(this, e), longDelayMS + delayMS);\n  },\n\n  /**\n   * Place as callback for a DOM element's `onResponderRelease` event.\n   */\n  touchableHandleResponderRelease: function touchableHandleResponderRelease(e) {\n    this.pressInLocation = null;\n\n    this._receiveSignal(Signals.RESPONDER_RELEASE, e);\n  },\n\n  /**\n   * Place as callback for a DOM element's `onResponderTerminate` event.\n   */\n  touchableHandleResponderTerminate: function touchableHandleResponderTerminate(e) {\n    this.pressInLocation = null;\n\n    this._receiveSignal(Signals.RESPONDER_TERMINATED, e);\n  },\n\n  /**\n   * Place as callback for a DOM element's `onResponderMove` event.\n   */\n  touchableHandleResponderMove: function touchableHandleResponderMove(e) {\n    // Measurement may not have returned yet.\n    if (!this.state.touchable.positionOnActivate) {\n      return;\n    }\n\n    var positionOnActivate = this.state.touchable.positionOnActivate;\n    var dimensionsOnActivate = this.state.touchable.dimensionsOnActivate;\n    var pressRectOffset = this.touchableGetPressRectOffset ? this.touchableGetPressRectOffset() : {\n      left: PRESS_EXPAND_PX,\n      right: PRESS_EXPAND_PX,\n      top: PRESS_EXPAND_PX,\n      bottom: PRESS_EXPAND_PX\n    };\n    var pressExpandLeft = pressRectOffset.left;\n    var pressExpandTop = pressRectOffset.top;\n    var pressExpandRight = pressRectOffset.right;\n    var pressExpandBottom = pressRectOffset.bottom;\n    var hitSlop = this.touchableGetHitSlop ? this.touchableGetHitSlop() : null;\n\n    if (hitSlop) {\n      pressExpandLeft += hitSlop.left || 0;\n      pressExpandTop += hitSlop.top || 0;\n      pressExpandRight += hitSlop.right || 0;\n      pressExpandBottom += hitSlop.bottom || 0;\n    }\n\n    var touch = extractSingleTouch(e.nativeEvent);\n    var pageX = touch && touch.pageX;\n    var pageY = touch && touch.pageY;\n\n    if (this.pressInLocation) {\n      var movedDistance = this._getDistanceBetweenPoints(pageX, pageY, this.pressInLocation.pageX, this.pressInLocation.pageY);\n\n      if (movedDistance > LONG_PRESS_ALLOWED_MOVEMENT) {\n        this._cancelLongPressDelayTimeout();\n      }\n    }\n\n    var isTouchWithinActive = pageX > positionOnActivate.left - pressExpandLeft && pageY > positionOnActivate.top - pressExpandTop && pageX < positionOnActivate.left + dimensionsOnActivate.width + pressExpandRight && pageY < positionOnActivate.top + dimensionsOnActivate.height + pressExpandBottom;\n\n    if (isTouchWithinActive) {\n      var prevState = this.state.touchable.touchState;\n\n      this._receiveSignal(Signals.ENTER_PRESS_RECT, e);\n\n      var curState = this.state.touchable.touchState;\n\n      if (curState === States.RESPONDER_INACTIVE_PRESS_IN && prevState !== States.RESPONDER_INACTIVE_PRESS_IN) {\n        // fix for t7967420\n        this._cancelLongPressDelayTimeout();\n      }\n    } else {\n      this._cancelLongPressDelayTimeout();\n\n      this._receiveSignal(Signals.LEAVE_PRESS_RECT, e);\n    }\n  },\n\n  /**\n   * Invoked when the item receives focus. Mixers might override this to\n   * visually distinguish the `VisualRect` so that the user knows that it\n   * currently has the focus. Most platforms only support a single element being\n   * focused at a time, in which case there may have been a previously focused\n   * element that was blurred just prior to this. This can be overridden when\n   * using `Touchable.Mixin.withoutDefaultFocusAndBlur`.\n   */\n  touchableHandleFocus: function touchableHandleFocus(e) {\n    this.props.onFocus && this.props.onFocus(e);\n  },\n\n  /**\n   * Invoked when the item loses focus. Mixers might override this to\n   * visually distinguish the `VisualRect` so that the user knows that it\n   * no longer has focus. Most platforms only support a single element being\n   * focused at a time, in which case the focus may have moved to another.\n   * This can be overridden when using\n   * `Touchable.Mixin.withoutDefaultFocusAndBlur`.\n   */\n  touchableHandleBlur: function touchableHandleBlur(e) {\n    this.props.onBlur && this.props.onBlur(e);\n  },\n  // ==== Abstract Application Callbacks ====\n\n  /**\n   * Invoked when the item should be highlighted. Mixers should implement this\n   * to visually distinguish the `VisualRect` so that the user knows that\n   * releasing a touch will result in a \"selection\" (analog to click).\n   *\n   * @abstract\n   * touchableHandleActivePressIn: function,\n   */\n\n  /**\n   * Invoked when the item is \"active\" (in that it is still eligible to become\n   * a \"select\") but the touch has left the `PressRect`. Usually the mixer will\n   * want to unhighlight the `VisualRect`. If the user (while pressing) moves\n   * back into the `PressRect` `touchableHandleActivePressIn` will be invoked\n   * again and the mixer should probably highlight the `VisualRect` again. This\n   * event will not fire on an `touchEnd/mouseUp` event, only move events while\n   * the user is depressing the mouse/touch.\n   *\n   * @abstract\n   * touchableHandleActivePressOut: function\n   */\n\n  /**\n   * Invoked when the item is \"selected\" - meaning the interaction ended by\n   * letting up while the item was either in the state\n   * `RESPONDER_ACTIVE_PRESS_IN` or `RESPONDER_INACTIVE_PRESS_IN`.\n   *\n   * @abstract\n   * touchableHandlePress: function\n   */\n\n  /**\n   * Invoked when the item is long pressed - meaning the interaction ended by\n   * letting up while the item was in `RESPONDER_ACTIVE_LONG_PRESS_IN`. If\n   * `touchableHandleLongPress` is *not* provided, `touchableHandlePress` will\n   * be called as it normally is. If `touchableHandleLongPress` is provided, by\n   * default any `touchableHandlePress` callback will not be invoked. To\n   * override this default behavior, override `touchableLongPressCancelsPress`\n   * to return false. As a result, `touchableHandlePress` will be called when\n   * lifting up, even if `touchableHandleLongPress` has also been called.\n   *\n   * @abstract\n   * touchableHandleLongPress: function\n   */\n\n  /**\n   * Returns the number of millis to wait before triggering a highlight.\n   *\n   * @abstract\n   * touchableGetHighlightDelayMS: function\n   */\n\n  /**\n   * Returns the amount to extend the `HitRect` into the `PressRect`. Positive\n   * numbers mean the size expands outwards.\n   *\n   * @abstract\n   * touchableGetPressRectOffset: function\n   */\n  // ==== Internal Logic ====\n\n  /**\n   * Measures the `HitRect` node on activation. The Bounding rectangle is with\n   * respect to viewport - not page, so adding the `pageXOffset/pageYOffset`\n   * should result in points that are in the same coordinate system as an\n   * event's `globalX/globalY` data values.\n   *\n   * - Consider caching this for the lifetime of the component, or possibly\n   *   being able to share this cache between any `ScrollMap` view.\n   *\n   * @sideeffects\n   * @private\n   */\n  _remeasureMetricsOnActivation: function _remeasureMetricsOnActivation() {\n    var tag = this.state.touchable.responderID;\n\n    if (tag == null) {\n      return;\n    }\n\n    _UIManager.default.measure(tag, this._handleQueryLayout);\n  },\n  _handleQueryLayout: function _handleQueryLayout(l, t, w, h, globalX, globalY) {\n    //don't do anything UIManager failed to measure node\n    if (!l && !t && !w && !h && !globalX && !globalY) {\n      return;\n    }\n\n    this.state.touchable.positionOnActivate && _Position.default.release(this.state.touchable.positionOnActivate);\n    this.state.touchable.dimensionsOnActivate && // $FlowFixMe\n    _BoundingDimensions.default.release(this.state.touchable.dimensionsOnActivate);\n    this.state.touchable.positionOnActivate = _Position.default.getPooled(globalX, globalY); // $FlowFixMe\n\n    this.state.touchable.dimensionsOnActivate = _BoundingDimensions.default.getPooled(w, h);\n  },\n  _handleDelay: function _handleDelay(e) {\n    this.touchableDelayTimeout = null;\n\n    this._receiveSignal(Signals.DELAY, e);\n  },\n  _handleLongDelay: function _handleLongDelay(e) {\n    this.longPressDelayTimeout = null;\n    var curState = this.state.touchable.touchState;\n\n    if (curState !== States.RESPONDER_ACTIVE_PRESS_IN && curState !== States.RESPONDER_ACTIVE_LONG_PRESS_IN) {\n      console.error('Attempted to transition from state `' + curState + '` to `' + States.RESPONDER_ACTIVE_LONG_PRESS_IN + '`, which is not supported. This is ' + 'most likely due to `Touchable.longPressDelayTimeout` not being cancelled.');\n    } else {\n      this._receiveSignal(Signals.LONG_PRESS_DETECTED, e);\n    }\n  },\n\n  /**\n   * Receives a state machine signal, performs side effects of the transition\n   * and stores the new state. Validates the transition as well.\n   *\n   * @param {Signals} signal State machine signal.\n   * @throws Error if invalid state transition or unrecognized signal.\n   * @sideeffects\n   */\n  _receiveSignal: function _receiveSignal(signal, e) {\n    var responderID = this.state.touchable.responderID;\n    var curState = this.state.touchable.touchState;\n    var nextState = Transitions[curState] && Transitions[curState][signal];\n\n    if (!responderID && signal === Signals.RESPONDER_RELEASE) {\n      return;\n    }\n\n    if (!nextState) {\n      throw new Error('Unrecognized signal `' + signal + '` or state `' + curState + '` for Touchable responder `' + responderID + '`');\n    }\n\n    if (nextState === States.ERROR) {\n      throw new Error('Touchable cannot transition from `' + curState + '` to `' + signal + '` for responder `' + responderID + '`');\n    }\n\n    if (curState !== nextState) {\n      this._performSideEffectsForTransition(curState, nextState, signal, e);\n\n      this.state.touchable.touchState = nextState;\n    }\n  },\n  _cancelLongPressDelayTimeout: function _cancelLongPressDelayTimeout() {\n    this.longPressDelayTimeout && clearTimeout(this.longPressDelayTimeout);\n    this.longPressDelayTimeout = null;\n  },\n  _isHighlight: function _isHighlight(state) {\n    return state === States.RESPONDER_ACTIVE_PRESS_IN || state === States.RESPONDER_ACTIVE_LONG_PRESS_IN;\n  },\n  _savePressInLocation: function _savePressInLocation(e) {\n    var touch = extractSingleTouch(e.nativeEvent);\n    var pageX = touch && touch.pageX;\n    var pageY = touch && touch.pageY;\n    var locationX = touch && touch.locationX;\n    var locationY = touch && touch.locationY;\n    this.pressInLocation = {\n      pageX: pageX,\n      pageY: pageY,\n      locationX: locationX,\n      locationY: locationY\n    };\n  },\n  _getDistanceBetweenPoints: function _getDistanceBetweenPoints(aX, aY, bX, bY) {\n    var deltaX = aX - bX;\n    var deltaY = aY - bY;\n    return Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n  },\n\n  /**\n   * Will perform a transition between touchable states, and identify any\n   * highlighting or unhighlighting that must be performed for this particular\n   * transition.\n   *\n   * @param {States} curState Current Touchable state.\n   * @param {States} nextState Next Touchable state.\n   * @param {Signal} signal Signal that triggered the transition.\n   * @param {Event} e Native event.\n   * @sideeffects\n   */\n  _performSideEffectsForTransition: function _performSideEffectsForTransition(curState, nextState, signal, e) {\n    var curIsHighlight = this._isHighlight(curState);\n\n    var newIsHighlight = this._isHighlight(nextState);\n\n    var isFinalSignal = signal === Signals.RESPONDER_TERMINATED || signal === Signals.RESPONDER_RELEASE;\n\n    if (isFinalSignal) {\n      this._cancelLongPressDelayTimeout();\n    }\n\n    var isInitialTransition = curState === States.NOT_RESPONDER && nextState === States.RESPONDER_INACTIVE_PRESS_IN;\n    var isActiveTransition = !IsActive[curState] && IsActive[nextState];\n\n    if (isInitialTransition || isActiveTransition) {\n      this._remeasureMetricsOnActivation();\n    }\n\n    if (IsPressingIn[curState] && signal === Signals.LONG_PRESS_DETECTED) {\n      this.touchableHandleLongPress && this.touchableHandleLongPress(e);\n    }\n\n    if (newIsHighlight && !curIsHighlight) {\n      this._startHighlight(e);\n    } else if (!newIsHighlight && curIsHighlight) {\n      this._endHighlight(e);\n    }\n\n    if (IsPressingIn[curState] && signal === Signals.RESPONDER_RELEASE) {\n      var hasLongPressHandler = !!this.props.onLongPress;\n      var pressIsLongButStillCallOnPress = IsLongPressingIn[curState] && ( // We *are* long pressing.. // But either has no long handler\n      !hasLongPressHandler || !this.touchableLongPressCancelsPress()); // or we're told to ignore it.\n\n      var shouldInvokePress = !IsLongPressingIn[curState] || pressIsLongButStillCallOnPress;\n\n      if (shouldInvokePress && this.touchableHandlePress) {\n        if (!newIsHighlight && !curIsHighlight) {\n          // we never highlighted because of delay, but we should highlight now\n          this._startHighlight(e);\n\n          this._endHighlight(e);\n        }\n\n        this.touchableHandlePress(e);\n      }\n    }\n\n    this.touchableDelayTimeout && clearTimeout(this.touchableDelayTimeout);\n    this.touchableDelayTimeout = null;\n  },\n  _playTouchSound: function _playTouchSound() {\n    _UIManager.default.playTouchSound();\n  },\n  _startHighlight: function _startHighlight(e) {\n    this._savePressInLocation(e);\n\n    this.touchableHandleActivePressIn && this.touchableHandleActivePressIn(e);\n  },\n  _endHighlight: function _endHighlight(e) {\n    var _this2 = this;\n\n    if (this.touchableHandleActivePressOut) {\n      if (this.touchableGetPressOutDelayMS && this.touchableGetPressOutDelayMS()) {\n        this.pressOutDelayTimeout = setTimeout(function () {\n          _this2.touchableHandleActivePressOut(e);\n        }, this.touchableGetPressOutDelayMS());\n      } else {\n        this.touchableHandleActivePressOut(e);\n      }\n    }\n  },\n  // HACK (part 2): basic support for touchable interactions using a keyboard (including\n  // delays and longPress)\n  touchableHandleKeyEvent: function touchableHandleKeyEvent(e) {\n    var type = e.type,\n        key = e.key;\n\n    if (key === 'Enter' || key === ' ') {\n      if (type === 'keydown') {\n        if (!this._isTouchableKeyboardActive) {\n          if (!this.state.touchable.touchState || this.state.touchable.touchState === States.NOT_RESPONDER) {\n            this.touchableHandleResponderGrant(e);\n            this._isTouchableKeyboardActive = true;\n          }\n        }\n      } else if (type === 'keyup') {\n        if (this._isTouchableKeyboardActive) {\n          if (this.state.touchable.touchState && this.state.touchable.touchState !== States.NOT_RESPONDER) {\n            this.touchableHandleResponderRelease(e);\n            this._isTouchableKeyboardActive = false;\n          }\n        }\n      }\n\n      e.stopPropagation(); // prevent the default behaviour unless the Touchable functions as a link\n      // and Enter is pressed\n\n      if (!(key === 'Enter' && _AccessibilityUtil.default.propsToAriaRole(this.props) === 'link')) {\n        e.preventDefault();\n      }\n    }\n  },\n  withoutDefaultFocusAndBlur: {}\n};\n/**\n * Provide an optional version of the mixin where `touchableHandleFocus` and\n * `touchableHandleBlur` can be overridden. This allows appropriate defaults to\n * be set on TV platforms, without breaking existing implementations of\n * `Touchable`.\n */\n\nvar touchableHandleFocus = TouchableMixin.touchableHandleFocus,\n    touchableHandleBlur = TouchableMixin.touchableHandleBlur,\n    TouchableMixinWithoutDefaultFocusAndBlur = _objectWithoutPropertiesLoose(TouchableMixin, [\"touchableHandleFocus\", \"touchableHandleBlur\"]);\n\nTouchableMixin.withoutDefaultFocusAndBlur = TouchableMixinWithoutDefaultFocusAndBlur;\nvar Touchable = {\n  Mixin: TouchableMixin,\n  TOUCH_TARGET_DEBUG: false,\n  // Highlights all touchable targets. Toggle with Inspector.\n\n  /**\n   * Renders a debugging overlay to visualize touch target with hitSlop (might not work on Android).\n   */\n  renderDebugView: function renderDebugView(_ref) {\n    var color = _ref.color,\n        hitSlop = _ref.hitSlop;\n\n    if (!Touchable.TOUCH_TARGET_DEBUG) {\n      return null;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      throw Error('Touchable.TOUCH_TARGET_DEBUG should not be enabled in prod!');\n    }\n\n    var debugHitSlopStyle = {};\n    hitSlop = hitSlop || {\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0\n    };\n\n    for (var key in hitSlop) {\n      debugHitSlopStyle[key] = -hitSlop[key];\n    }\n\n    var normalizedColor = (0, _normalizeCssColor.default)(color);\n\n    if (typeof normalizedColor !== 'number') {\n      return null;\n    }\n\n    var hexColor = '#' + ('00000000' + normalizedColor.toString(16)).substr(-8);\n    return _react.default.createElement(_View.default, {\n      pointerEvents: \"none\",\n      style: _objectSpread({\n        position: 'absolute',\n        borderColor: hexColor.slice(0, -2) + '55',\n        // More opaque\n        borderWidth: 1,\n        borderStyle: 'dashed',\n        backgroundColor: hexColor.slice(0, -2) + '0F'\n      }, debugHitSlopStyle)\n    });\n  }\n};\nvar _default = Touchable;\nexports.default = _default;\nmodule.exports = exports.default;"]},"metadata":{},"sourceType":"script"}