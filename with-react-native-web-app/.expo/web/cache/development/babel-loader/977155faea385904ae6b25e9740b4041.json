{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = void 0;\n\nvar _ResponderEventTypes = require(\"./ResponderEventTypes\");\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/**\n * Tracks the position and time of each active touch by `touch.identifier`. We\n * should typically only see IDs in the range of 1-20 because IDs get recycled\n * when touches end and start again.\n */\n\n\nvar __DEV__ = true;\nvar MAX_TOUCH_BANK = 20;\nvar touchBank = [];\nvar touchHistory = {\n  touchBank: touchBank,\n  numberActiveTouches: 0,\n  // If there is only one active touch, we remember its location. This prevents\n  // us having to loop through all of the touches all the time in the most\n  // common case.\n  indexOfSingleActiveTouch: -1,\n  mostRecentTimeStamp: 0\n};\n\nfunction timestampForTouch(touch) {\n  // The legacy internal implementation provides \"timeStamp\", which has been\n  // renamed to \"timestamp\".\n  return touch.timeStamp || touch.timestamp;\n}\n/**\n * TODO: Instead of making gestures recompute filtered velocity, we could\n * include a built in velocity computation that can be reused globally.\n */\n\n\nfunction createTouchRecord(touch) {\n  return {\n    touchActive: true,\n    startPageX: touch.pageX,\n    startPageY: touch.pageY,\n    startTimeStamp: timestampForTouch(touch),\n    currentPageX: touch.pageX,\n    currentPageY: touch.pageY,\n    currentTimeStamp: timestampForTouch(touch),\n    previousPageX: touch.pageX,\n    previousPageY: touch.pageY,\n    previousTimeStamp: timestampForTouch(touch)\n  };\n}\n\nfunction resetTouchRecord(touchRecord, touch) {\n  touchRecord.touchActive = true;\n  touchRecord.startPageX = touch.pageX;\n  touchRecord.startPageY = touch.pageY;\n  touchRecord.startTimeStamp = timestampForTouch(touch);\n  touchRecord.currentPageX = touch.pageX;\n  touchRecord.currentPageY = touch.pageY;\n  touchRecord.currentTimeStamp = timestampForTouch(touch);\n  touchRecord.previousPageX = touch.pageX;\n  touchRecord.previousPageY = touch.pageY;\n  touchRecord.previousTimeStamp = timestampForTouch(touch);\n}\n\nfunction getTouchIdentifier(_ref) {\n  var identifier = _ref.identifier;\n\n  if (identifier == null) {\n    console.error('Touch object is missing identifier.');\n  }\n\n  if (__DEV__) {\n    if (identifier > MAX_TOUCH_BANK) {\n      console.error('Touch identifier %s is greater than maximum supported %s which causes ' + 'performance issues backfilling array locations for all of the indices.', identifier, MAX_TOUCH_BANK);\n    }\n  }\n\n  return identifier;\n}\n\nfunction recordTouchStart(touch) {\n  var identifier = getTouchIdentifier(touch);\n  var touchRecord = touchBank[identifier];\n\n  if (touchRecord) {\n    resetTouchRecord(touchRecord, touch);\n  } else {\n    touchBank[identifier] = createTouchRecord(touch);\n  }\n\n  touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n}\n\nfunction recordTouchMove(touch) {\n  var touchRecord = touchBank[getTouchIdentifier(touch)];\n\n  if (touchRecord) {\n    touchRecord.touchActive = true;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.warn('Cannot record touch move without a touch start.\\n', \"Touch Move: \" + printTouch(touch) + \"\\n\", \"Touch Bank: \" + printTouchBank());\n  }\n}\n\nfunction recordTouchEnd(touch) {\n  var touchRecord = touchBank[getTouchIdentifier(touch)];\n\n  if (touchRecord) {\n    touchRecord.touchActive = false;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.warn('Cannot record touch end without a touch start.\\n', \"Touch End: \" + printTouch(touch) + \"\\n\", \"Touch Bank: \" + printTouchBank());\n  }\n}\n\nfunction printTouch(touch) {\n  return JSON.stringify({\n    identifier: touch.identifier,\n    pageX: touch.pageX,\n    pageY: touch.pageY,\n    timestamp: timestampForTouch(touch)\n  });\n}\n\nfunction printTouchBank() {\n  var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));\n\n  if (touchBank.length > MAX_TOUCH_BANK) {\n    printed += ' (original size: ' + touchBank.length + ')';\n  }\n\n  return printed;\n}\n\nvar ResponderTouchHistoryStore = {\n  recordTouchTrack: function recordTouchTrack(topLevelType, nativeEvent) {\n    if ((0, _ResponderEventTypes.isMoveish)(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchMove);\n    } else if ((0, _ResponderEventTypes.isStartish)(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchStart);\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n\n      if (touchHistory.numberActiveTouches === 1) {\n        touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;\n      }\n    } else if ((0, _ResponderEventTypes.isEndish)(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchEnd);\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n\n      if (touchHistory.numberActiveTouches === 1) {\n        for (var i = 0; i < touchBank.length; i++) {\n          var touchTrackToCheck = touchBank[i];\n\n          if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {\n            touchHistory.indexOfSingleActiveTouch = i;\n            break;\n          }\n        }\n\n        if (__DEV__) {\n          var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];\n\n          if (!(activeRecord != null && activeRecord.touchActive)) {\n            console.error('Cannot find single active touch.');\n          }\n        }\n      }\n    }\n  },\n  touchHistory: touchHistory\n};\nvar _default = ResponderTouchHistoryStore;\nexports[\"default\"] = _default;\nmodule.exports = exports[\"default\"];","map":{"version":3,"sources":["/Users/jun/Desktop/dev/react-practice/with-react-native-web-app/node_modules/react-native-web/dist/cjs/hooks/useResponderEvents/ResponderTouchHistoryStore.js"],"names":["exports","_ResponderEventTypes","require","__DEV__","MAX_TOUCH_BANK","touchBank","touchHistory","numberActiveTouches","indexOfSingleActiveTouch","mostRecentTimeStamp","touch","touchActive","startPageX","startPageY","startTimeStamp","timestampForTouch","currentPageX","currentPageY","currentTimeStamp","previousPageX","previousPageY","previousTimeStamp","touchRecord","identifier","_ref","console","getTouchIdentifier","resetTouchRecord","createTouchRecord","printTouch","printTouchBank","pageX","pageY","timestamp","printed","JSON","ResponderTouchHistoryStore","recordTouchTrack","nativeEvent","i","touchTrackToCheck","activeRecord","_default","module"],"mappings":"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","sourcesContent":["\"use strict\";\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar _ResponderEventTypes = require(\"./ResponderEventTypes\");\n\n/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * \n */\n\n/**\n * Tracks the position and time of each active touch by `touch.identifier`. We\n * should typically only see IDs in the range of 1-20 because IDs get recycled\n * when touches end and start again.\n */\nvar __DEV__ = process.env.NODE_ENV !== 'production';\n\nvar MAX_TOUCH_BANK = 20;\nvar touchBank = [];\nvar touchHistory = {\n  touchBank: touchBank,\n  numberActiveTouches: 0,\n  // If there is only one active touch, we remember its location. This prevents\n  // us having to loop through all of the touches all the time in the most\n  // common case.\n  indexOfSingleActiveTouch: -1,\n  mostRecentTimeStamp: 0\n};\n\nfunction timestampForTouch(touch) {\n  // The legacy internal implementation provides \"timeStamp\", which has been\n  // renamed to \"timestamp\".\n  return touch.timeStamp || touch.timestamp;\n}\n/**\n * TODO: Instead of making gestures recompute filtered velocity, we could\n * include a built in velocity computation that can be reused globally.\n */\n\n\nfunction createTouchRecord(touch) {\n  return {\n    touchActive: true,\n    startPageX: touch.pageX,\n    startPageY: touch.pageY,\n    startTimeStamp: timestampForTouch(touch),\n    currentPageX: touch.pageX,\n    currentPageY: touch.pageY,\n    currentTimeStamp: timestampForTouch(touch),\n    previousPageX: touch.pageX,\n    previousPageY: touch.pageY,\n    previousTimeStamp: timestampForTouch(touch)\n  };\n}\n\nfunction resetTouchRecord(touchRecord, touch) {\n  touchRecord.touchActive = true;\n  touchRecord.startPageX = touch.pageX;\n  touchRecord.startPageY = touch.pageY;\n  touchRecord.startTimeStamp = timestampForTouch(touch);\n  touchRecord.currentPageX = touch.pageX;\n  touchRecord.currentPageY = touch.pageY;\n  touchRecord.currentTimeStamp = timestampForTouch(touch);\n  touchRecord.previousPageX = touch.pageX;\n  touchRecord.previousPageY = touch.pageY;\n  touchRecord.previousTimeStamp = timestampForTouch(touch);\n}\n\nfunction getTouchIdentifier(_ref) {\n  var identifier = _ref.identifier;\n\n  if (identifier == null) {\n    console.error('Touch object is missing identifier.');\n  }\n\n  if (__DEV__) {\n    if (identifier > MAX_TOUCH_BANK) {\n      console.error('Touch identifier %s is greater than maximum supported %s which causes ' + 'performance issues backfilling array locations for all of the indices.', identifier, MAX_TOUCH_BANK);\n    }\n  }\n\n  return identifier;\n}\n\nfunction recordTouchStart(touch) {\n  var identifier = getTouchIdentifier(touch);\n  var touchRecord = touchBank[identifier];\n\n  if (touchRecord) {\n    resetTouchRecord(touchRecord, touch);\n  } else {\n    touchBank[identifier] = createTouchRecord(touch);\n  }\n\n  touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n}\n\nfunction recordTouchMove(touch) {\n  var touchRecord = touchBank[getTouchIdentifier(touch)];\n\n  if (touchRecord) {\n    touchRecord.touchActive = true;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.warn('Cannot record touch move without a touch start.\\n', \"Touch Move: \" + printTouch(touch) + \"\\n\", \"Touch Bank: \" + printTouchBank());\n  }\n}\n\nfunction recordTouchEnd(touch) {\n  var touchRecord = touchBank[getTouchIdentifier(touch)];\n\n  if (touchRecord) {\n    touchRecord.touchActive = false;\n    touchRecord.previousPageX = touchRecord.currentPageX;\n    touchRecord.previousPageY = touchRecord.currentPageY;\n    touchRecord.previousTimeStamp = touchRecord.currentTimeStamp;\n    touchRecord.currentPageX = touch.pageX;\n    touchRecord.currentPageY = touch.pageY;\n    touchRecord.currentTimeStamp = timestampForTouch(touch);\n    touchHistory.mostRecentTimeStamp = timestampForTouch(touch);\n  } else {\n    console.warn('Cannot record touch end without a touch start.\\n', \"Touch End: \" + printTouch(touch) + \"\\n\", \"Touch Bank: \" + printTouchBank());\n  }\n}\n\nfunction printTouch(touch) {\n  return JSON.stringify({\n    identifier: touch.identifier,\n    pageX: touch.pageX,\n    pageY: touch.pageY,\n    timestamp: timestampForTouch(touch)\n  });\n}\n\nfunction printTouchBank() {\n  var printed = JSON.stringify(touchBank.slice(0, MAX_TOUCH_BANK));\n\n  if (touchBank.length > MAX_TOUCH_BANK) {\n    printed += ' (original size: ' + touchBank.length + ')';\n  }\n\n  return printed;\n}\n\nvar ResponderTouchHistoryStore = {\n  recordTouchTrack: function recordTouchTrack(topLevelType, nativeEvent) {\n    if ((0, _ResponderEventTypes.isMoveish)(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchMove);\n    } else if ((0, _ResponderEventTypes.isStartish)(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchStart);\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n\n      if (touchHistory.numberActiveTouches === 1) {\n        touchHistory.indexOfSingleActiveTouch = nativeEvent.touches[0].identifier;\n      }\n    } else if ((0, _ResponderEventTypes.isEndish)(topLevelType)) {\n      nativeEvent.changedTouches.forEach(recordTouchEnd);\n      touchHistory.numberActiveTouches = nativeEvent.touches.length;\n\n      if (touchHistory.numberActiveTouches === 1) {\n        for (var i = 0; i < touchBank.length; i++) {\n          var touchTrackToCheck = touchBank[i];\n\n          if (touchTrackToCheck != null && touchTrackToCheck.touchActive) {\n            touchHistory.indexOfSingleActiveTouch = i;\n            break;\n          }\n        }\n\n        if (__DEV__) {\n          var activeRecord = touchBank[touchHistory.indexOfSingleActiveTouch];\n\n          if (!(activeRecord != null && activeRecord.touchActive)) {\n            console.error('Cannot find single active touch.');\n          }\n        }\n      }\n    }\n  },\n  touchHistory: touchHistory\n};\nvar _default = ResponderTouchHistoryStore;\nexports.default = _default;\nmodule.exports = exports.default;"]},"metadata":{},"sourceType":"script"}